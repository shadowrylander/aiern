#!/usr/bin/env xonsh
import json os
from sys import exit

resources = f"{os.environ["HOME"]}/system/etc/nixos/resources"

# import os
# import re
# import readline
# 
# COMMANDS = ['extra', 'extension', 'stuff', 'errors',
#             'email', 'foobar', 'foo']
# RE_SPACE = re.compile('.*\s+$', re.M)
# 
# class Completer(object):
# 
#     def _listdir(self, root):
#         "List directory 'root' appending the path separator to subdirs."
#         res = []
#         for name in os.listdir(root):
#             path = os.path.join(root, name)
#             if os.path.isdir(path):
#                 name += os.sep
#             res.append(name)
#         return res
# 
#     def _complete_path(self, path=None):
#         "Perform completion of filesystem path."
#         if not path:
#             return self._listdir('.')
#         dirname, rest = os.path.split(path)
#         tmp = dirname if dirname else '.'
#         res = [os.path.join(dirname, p)
#                 for p in self._listdir(tmp) if p.startswith(rest)]
#         # more than one match, or single match which does not exist (typo)
#         if len(res) > 1 or not os.path.exists(path):
#             return res
#         # resolved to a single directory, so return list of files below it
#         if os.path.isdir(path):
#             return [os.path.join(path, p) for p in self._listdir(path)]
#         # exact file match terminates this completion
#         return [path + ' ']
# 
#     def complete_extra(self, args):
#         "Completions for the 'extra' command."
#         if not args:
#             return self._complete_path('.')
#         # treat the last arg as a path and complete it
#         return self._complete_path(args[-1])
# 
#     def complete(self, text, state):
#         "Generic readline completion entry point."
#         buffer = readline.get_line_buffer()
#         line = readline.get_line_buffer().split()
#         # show all commands
#         if not line:
#             return [c + ' ' for c in COMMANDS][state]
#         # account for last argument ending in a space
#         if RE_SPACE.match(buffer):
#             line.append('')
#         # resolve command to the implementation function
#         cmd = line[0].strip()
#         if cmd in COMMANDS:
#             impl = getattr(self, 'complete_%s' % cmd)
#             args = line[1:]
#             if args:
#                 return (impl(args) + [None])[state]
#             return [cmd + ' '][state]
#         results = [c + ' ' for c in COMMANDS if c.startswith(cmd)] + [None]
#         return results[state]
# 
# comp = Completer()
# # we want to treat '/' as part of a word, so override the delimiters
# readline.set_completer_delims(' \t\n;')
# readline.parse_and_bind("tab: complete")
# readline.set_completer(comp.complete)

print('''
    Create a new ZFS device:         c
    Mount a ZFS device:              m
    Update:                          u
            Files:                           f
            Pool:                            p
            Go back:                         g
    Generate nixos config:           g
    Include boostrap config:         b
    One-Stop Install:                a
    Rsync over bootstrap config:     r
    Begin install:                   i
    Show this help text:             h
    Setup:                           s
    Quit:                            q
    Install and Set Up Home-Manager: H
    \n\n
''')

def xrun(command):
    @(command.split())

xrun("nix-env -i sd rsync")

try:

    while true:
        pool_name = raw_input("What's the pool name?\n\t")
        if pool_name == "":
            print("Wait a minute... That's not a valid pool name! Try again, please!\n")
        elif pool_name == "quit bootstrap":
            print("Catch ya' later!")
            exit(0)
        else:
            print("Alright; let's get crackin'!\n\n")
            encrypted = raw_input('''
                Is this pool [to be] encrypted?
                    y | n\n\t
            ''') == "y"
            break

    while true:
        input = input or raw_input("Pick an option, any option! :D\n\t")
        saved_input = [c for c in input]
        input = ""
        for c in saved_input:
            if c == "c":
                if raw_input('THIS WILL DELETE ALL DATA ON THE SELECTED DEVICE / PARTITION! TO CONTINUE, TYPE IN "ZFS CREATE"!\n\t') == "ZFS CREATE":

                    options = {
                        "xattr": "sa",
                        "acltype": "posixacl",
                        "mountpoint": "none",
                        "compression": "zstd-19",
                        "checksum": "edonr",
                        "atime": "off",
                        "relatime": "off",
                    }
                    
                    if encrypted:
                        options["encryption"] = "aes-256-gcm"
                        options["keyformat"] = "passphrase"
                    if (dedup := (raw_input('''
                        Should this pool be deduplicated?
                            y | n\n\t
                    ''') == "y")):
                        options["dedup"] = "edonr,verify"
                    
                    for dataset in $(zfs list -rH).split("\n"):
                        if pool_name in dataset:
                            xrun(f"zpool export {pool_name}")
                            break
                    
                    command = f"zpool create -fo autotrim=on -o altroot=/mnt"
                    
                    for key, value in options.items():
                        command += f" -O {key}={value}"
                    
                    zfs_device = raw_input("Please enter the device to be initialized:\n\t")
                    
                    xrun(f"{command} {pool_name} {zfs_device}")
                    
                    snapDir = [ "snapdir=visible" ]
                    extraCopies = snapDir + [ f"copies={2 if encrypted else 3}" ]
                    cache = [ "sync=disabled" ]
                    ml = "mountpoint=legacy"
                    dd = {  }
                    ddd = { "datasets": {  }}
                    d = "datasets"
                    s = "system"
                    
                    datasets = json.loads('''
                        {
                            "base": {  },
                            "hold": {  },
                            "omniverse": {  },
                            "reserved": {  },
                            "system": {
                                "datasets": {
                                    "home": { "datasets": { "root": { "mountpoint": "/root" }}},
                                    "nix": {  },
                                    "persist": {
                                        "datasets": {
                                            "cache": {
                                                "datasets": { "root": {  }},
                                                "options": [ "sync=disabled" ]
                                            },
                                            "home": { "datasets": { "root": {  }}}
                                        }
                                    },
                                    "root": {  },
                                    "tmp": { "options": [ "sync=disabled" ] }
                                },
                                "options": [ "mountpoint=legacy" ]
                            },
                            "virt": {
                                "datasets": {
                                    "docker": {  },
                                    "kvm": {  },
                                    "podman": { "datasets": {  }},
                                    "qemu": {  },
                                    "vagrant": {  },
                                    "xen": {  }
                                },
                                "options": [ "mountpoint=legacy", "refreservation=none" ],
                                "mountpoint": "/var/lib"
                            }
                        }
                    '''.strip())
                    
                    dsd = datasets[s][d]
                    
                    datasets[args.pool_name] = {
                        "datasets": {
                            "b": {
                                "datasets": {
                                    "a": dd,
                                    "cc": { "options": snapDir },
                                    "cl": dd,
                                    "cj": { "datasets": {
                                        "cc": { "options": extraCopies },
                                        "m": { "options": snapDir }
                                    }},
                                    "eb": { "options": extraCopies },
                                    "oreo": { "option": snapDir },
                                    "p": { "options": snapDir }
                                },
                            },
                            "borg": { "datasets": { "cache": { "options": cache }}},
                            "jails": { "datasets": { "base": dd}},
                            "las": {
                                "datasets": {
                                    "dreadnought": ddd,
                                    "redstone": ddd,
                                    "sinnoh": ddd
                                }
                            },
                            "y": dd,
                            "z": dd
                        },
                        "options": [ ml ]
                    }
                    
                    users = json.loads('''
                        {
                            "primary": "shadowrylander",
                            "secondary": "frost",
                            "nightingale": "curtis"
                        }
                    '''.strip())
                    
                    for user in users.values():
                        dsd["home"][d][user] = dd
                        datasets["virt"][d]["podman"][d][user] = dd
                        for dataset in (persist := dsd["persist"][d]).keys():
                            persist[dataset][d][user] = dd
                    
                    for backup in (las := datasets[pool_name][d]["las"][d]).keys():
                        for zz in [ "zpax", "zsyncs" ]:
                            las[backup][d][zz] = dd
                    
                    with open(f"{resources}/datasets.nix", "w+") as dnix:
                    
                        dnix.write("host: {\n")
                    
                        def recurse(ddict, dname, droot, mountpoint = ""):
                    
                            _dataset = f"{droot}/{dname}"
                    
                            # cc: clone or create
                            # son: snapshot or none
                            if (dname != "base") and (encrypted and dedup):
                                cc = "clone"
                                son = f"{pool_name}/base@root"
                            else:
                                cc = "create"
                                son = ""
                    
                            _doptions = ddict.get("options", [])
                            if _dataset not in ( f"{pool_name}/{dataset}" for dataset in (
                                "system",
                                "system/root",
                                "swap",
                                "base",
                                "hold",
                                "omniverse",
                                "reserved",
                            )):
                                pn1 = pool_name
                                pn2 = f"{pn1}/{pn1}"
                    
                                # TODO: Make this such that the current dataset directory
                                #       is placed under the parent directory's mountpoint
                                if (mountpoint := (_mountpoint := ddict.get("mountpoint", ""))) == "":
                                    if mountpoint = "":
                                        _mountpoint = _dataset.replace(
                                            pn2 if pn2 in _dataset else pn1
                                            "${host}",
                                            1
                                        )
                                    else:
                                        mountpoint = _mountpoint = f"{mountpoint}/{dname}"
                    
                                dnix.write(f'\t"{_dataset}" = "{_mountpoint}";\n')
                            doptions = " -o ".join(_doptions)
                    
                    
                    
                    xrun(f"zfs {cc} {'-o ' if _doptions else ''} {doptions} {son} {_dataset}")
                    xrun(f"zfs snapshot -r {_dataset}@root")
                    
                        for dataset in (ddictd := ddict.get(
                            d,
                            dd
                        )):
                            recurse(ddictd[dataset], dataset, _dataset, mountpoint)
                    
                    for dataset in datasets:
                        recurse(datasets[dataset], dataset, pool_name)
                    
                    dnix.write("}")
                    
                    pool_size_plus_metric = $(zpool get -H size @(pool_name)).split()[2]
                    pool_size = round(float(pool_size_plus_metric[:-1]), 2)
                    pool_metric = pool_size_plus_metric[-1]
                    
                    def pool_percentage_value(percentage):
                        return (
                            str(
                                round(
                                    (
                                        (float(percentage) / 100)
                                        * pool_size
                                    ),
                                    2,
                                )
                            )
                            + pool_metric
                        )
                    
                    # Apparently, if python internal keywords exist in the argument, such as "set", etc.
                    # the command errors out; perhaps something to raise an issue of.
                    # This seems to work as an alternative.
                    xrun(f"zfs set refreservation={pool_percentage_value(15)} {pool_name}/reserved")
                    
                    if (swap := (raw_input('''
                        Will this pool use SWAP?
                            y | n\n\t
                    ''') == "y")):
                        _swoptions = [
                            "com.sun:auto-snapshot=false",
                            "compression=zle",
                            "logbias=throughput",
                            "primarycache=metadata",
                            "secondarycache=none"
                            "sync=standard",
                        ]
                        swoptions = " -o ".join(_swoptions)
                    
                        ps = $(getconf PAGESIZE)
                        swap_size = int(raw_input("Please enter the (integer) SWAP size in GiB:\n\t"))
                        xrun(f"zfs create -V {2**swap_size}G -b {ps} -o {swoptions} {pool_name}/swap")
                    
                        xrun(f"mkswap -f /dev/zvol/{pool_name}/swap")
                    
                    

                else:
                    print("Sorry; not continuing!\n\n")
            elif c == "m":

                from collections import namedtuple
                from functools import partial
                from os import path as osPath
                from subprocess import DEVNULL
                
                for dataset in $(zfs list).split("\n"):
                    if pool_name in dataset:
                        break
                else:
                    xrun(f"zpool import -f {pool_name}")
                
                if encrypted:
                    xrun(f"zfs load-key {pool_name}")
                
                if osPath.isdir("/mnt"):
                    xrun("umount -R /mnt")
                else:
                    xrun("mkdir /mnt")
                
                xrun(f"mount -t zfs {pool_name}/system/root /mnt")
                
                with open(f"{resources}/datasets.nix") as datasets:
                    for dataset in datasets.readlines()[1:-1]:
                        dataset = dataset.strip().strip('"')
                
                        r = f"{pool_name}/"
                        sr = r + "system/"
                        _mount = dataset.replace(
                            sr if sr in dataset else r,
                            '',
                            1
                        )
                
                        if not osPath.isdir(mount := f"/mnt/{_mount}"):
                            xrun(f"mkdir -p {mount}")
                        xrun(f"mount -t zfs {dataset} {mount}")
                
                if not osPath.isdir(boot := "/mnt/boot/efi"):
                    xrun(f"mkdir -p {boot}")
                
                boot_device = raw_input("Please enter the boot device:\n\t")
                xrun(f"mount {boot_device} {boot}")
                
                if (swap := (raw_input('''
                    Does this pool use SWAP?
                        y | n\n\t
                ''') == "y")):
                    xrun(f"swapon /dev/zvol/{pool_name}/swap")

            elif c == "u":
                while true:
                    input2 = raw_input('''
                        Would you like to update the resource files, or the pool?
                            f | p | [g]o back\n\t
                    ''')
                    for cc in input2:
                        if cc == "f":

                            snapDir = [ "snapdir=visible" ]
                            extraCopies = snapDir + [ f"copies={2 if encrypted else 3}" ]
                            cache = [ "sync=disabled" ]
                            ml = "mountpoint=legacy"
                            dd = {  }
                            ddd = { "datasets": {  }}
                            d = "datasets"
                            s = "system"
                            
                            datasets = json.loads('''
                                {
                                    "base": {  },
                                    "hold": {  },
                                    "omniverse": {  },
                                    "reserved": {  },
                                    "system": {
                                        "datasets": {
                                            "home": { "datasets": { "root": { "mountpoint": "/root" }}},
                                            "nix": {  },
                                            "persist": {
                                                "datasets": {
                                                    "cache": {
                                                        "datasets": { "root": {  }},
                                                        "options": [ "sync=disabled" ]
                                                    },
                                                    "home": { "datasets": { "root": {  }}}
                                                }
                                            },
                                            "root": {  },
                                            "tmp": { "options": [ "sync=disabled" ] }
                                        },
                                        "options": [ "mountpoint=legacy" ]
                                    },
                                    "virt": {
                                        "datasets": {
                                            "docker": {  },
                                            "kvm": {  },
                                            "podman": { "datasets": {  }},
                                            "qemu": {  },
                                            "vagrant": {  },
                                            "xen": {  }
                                        },
                                        "options": [ "mountpoint=legacy", "refreservation=none" ],
                                        "mountpoint": "/var/lib"
                                    }
                                }
                            '''.strip())
                            
                            dsd = datasets[s][d]
                            
                            datasets[args.pool_name] = {
                                "datasets": {
                                    "b": {
                                        "datasets": {
                                            "a": dd,
                                            "cc": { "options": snapDir },
                                            "cl": dd,
                                            "cj": { "datasets": {
                                                "cc": { "options": extraCopies },
                                                "m": { "options": snapDir }
                                            }},
                                            "eb": { "options": extraCopies },
                                            "oreo": { "option": snapDir },
                                            "p": { "options": snapDir }
                                        },
                                    },
                                    "borg": { "datasets": { "cache": { "options": cache }}},
                                    "jails": { "datasets": { "base": dd}},
                                    "las": {
                                        "datasets": {
                                            "dreadnought": ddd,
                                            "redstone": ddd,
                                            "sinnoh": ddd
                                        }
                                    },
                                    "y": dd,
                                    "z": dd
                                },
                                "options": [ ml ]
                            }
                            
                            users = json.loads('''
                                {
                                    "primary": "shadowrylander",
                                    "secondary": "frost",
                                    "nightingale": "curtis"
                                }
                            '''.strip())
                            
                            for user in users.values():
                                dsd["home"][d][user] = dd
                                datasets["virt"][d]["podman"][d][user] = dd
                                for dataset in (persist := dsd["persist"][d]).keys():
                                    persist[dataset][d][user] = dd
                            
                            for backup in (las := datasets[pool_name][d]["las"][d]).keys():
                                for zz in [ "zpax", "zsyncs" ]:
                                    las[backup][d][zz] = dd
                            
                            with open(f"{resources}/datasets.nix", "w+") as dnix:
                            
                                dnix.write("host: {\n")
                            
                                def recurse(ddict, dname, droot, mountpoint = ""):
                            
                                    _dataset = f"{droot}/{dname}"
                            
                                    # cc: clone or create
                                    # son: snapshot or none
                                    if (dname != "base") and (encrypted and dedup):
                                        cc = "clone"
                                        son = f"{pool_name}/base@root"
                                    else:
                                        cc = "create"
                                        son = ""
                            
                                    _doptions = ddict.get("options", [])
                                    if _dataset not in ( f"{pool_name}/{dataset}" for dataset in (
                                        "system",
                                        "system/root",
                                        "swap",
                                        "base",
                                        "hold",
                                        "omniverse",
                                        "reserved",
                                    )):
                                        pn1 = pool_name
                                        pn2 = f"{pn1}/{pn1}"
                            
                                        # TODO: Make this such that the current dataset directory
                                        #       is placed under the parent directory's mountpoint
                                        if (mountpoint := (_mountpoint := ddict.get("mountpoint", ""))) == "":
                                            if mountpoint = "":
                                                _mountpoint = _dataset.replace(
                                                    pn2 if pn2 in _dataset else pn1
                                                    "${host}",
                                                    1
                                                )
                                            else:
                                                mountpoint = _mountpoint = f"{mountpoint}/{dname}"
                            
                                        dnix.write(f'\t"{_dataset}" = "{_mountpoint}";\n')
                                    doptions = " -o ".join(_doptions)
                            
                            
                            
                                for dataset in (ddictd := ddict.get(
                                    d,
                                    dd
                                )):
                                    recurse(ddictd[dataset], dataset, _dataset, mountpoint)
                            
                            for dataset in datasets:
                                recurse(datasets[dataset], dataset, pool_name)
                            
                            dnix.write("}")
                            

                        elif cc == "p":

                            snapDir = [ "snapdir=visible" ]
                            extraCopies = snapDir + [ f"copies={2 if encrypted else 3}" ]
                            cache = [ "sync=disabled" ]
                            ml = "mountpoint=legacy"
                            dd = {  }
                            ddd = { "datasets": {  }}
                            d = "datasets"
                            s = "system"
                            
                            datasets = json.loads('''
                                {
                                    "base": {  },
                                    "hold": {  },
                                    "omniverse": {  },
                                    "reserved": {  },
                                    "system": {
                                        "datasets": {
                                            "home": { "datasets": { "root": { "mountpoint": "/root" }}},
                                            "nix": {  },
                                            "persist": {
                                                "datasets": {
                                                    "cache": {
                                                        "datasets": { "root": {  }},
                                                        "options": [ "sync=disabled" ]
                                                    },
                                                    "home": { "datasets": { "root": {  }}}
                                                }
                                            },
                                            "root": {  },
                                            "tmp": { "options": [ "sync=disabled" ] }
                                        },
                                        "options": [ "mountpoint=legacy" ]
                                    },
                                    "virt": {
                                        "datasets": {
                                            "docker": {  },
                                            "kvm": {  },
                                            "podman": { "datasets": {  }},
                                            "qemu": {  },
                                            "vagrant": {  },
                                            "xen": {  }
                                        },
                                        "options": [ "mountpoint=legacy", "refreservation=none" ],
                                        "mountpoint": "/var/lib"
                                    }
                                }
                            '''.strip())
                            
                            dsd = datasets[s][d]
                            
                            datasets[args.pool_name] = {
                                "datasets": {
                                    "b": {
                                        "datasets": {
                                            "a": dd,
                                            "cc": { "options": snapDir },
                                            "cl": dd,
                                            "cj": { "datasets": {
                                                "cc": { "options": extraCopies },
                                                "m": { "options": snapDir }
                                            }},
                                            "eb": { "options": extraCopies },
                                            "oreo": { "option": snapDir },
                                            "p": { "options": snapDir }
                                        },
                                    },
                                    "borg": { "datasets": { "cache": { "options": cache }}},
                                    "jails": { "datasets": { "base": dd}},
                                    "las": {
                                        "datasets": {
                                            "dreadnought": ddd,
                                            "redstone": ddd,
                                            "sinnoh": ddd
                                        }
                                    },
                                    "y": dd,
                                    "z": dd
                                },
                                "options": [ ml ]
                            }
                            
                            users = json.loads('''
                                {
                                    "primary": "shadowrylander",
                                    "secondary": "frost",
                                    "nightingale": "curtis"
                                }
                            '''.strip())
                            
                            for user in users.values():
                                dsd["home"][d][user] = dd
                                datasets["virt"][d]["podman"][d][user] = dd
                                for dataset in (persist := dsd["persist"][d]).keys():
                                    persist[dataset][d][user] = dd
                            
                            for backup in (las := datasets[pool_name][d]["las"][d]).keys():
                                for zz in [ "zpax", "zsyncs" ]:
                                    las[backup][d][zz] = dd
                            
                            with open(f"{resources}/datasets.nix", "w+") as dnix:
                            
                                dnix.write("host: {\n")
                            
                                def recurse(ddict, dname, droot, mountpoint = ""):
                            
                                    _dataset = f"{droot}/{dname}"
                            
                                    # cc: clone or create
                                    # son: snapshot or none
                                    if (dname != "base") and (encrypted and dedup):
                                        cc = "clone"
                                        son = f"{pool_name}/base@root"
                                    else:
                                        cc = "create"
                                        son = ""
                            
                                    _doptions = ddict.get("options", [])
                                    if _dataset not in ( f"{pool_name}/{dataset}" for dataset in (
                                        "system",
                                        "system/root",
                                        "swap",
                                        "base",
                                        "hold",
                                        "omniverse",
                                        "reserved",
                                    )):
                                        pn1 = pool_name
                                        pn2 = f"{pn1}/{pn1}"
                            
                                        # TODO: Make this such that the current dataset directory
                                        #       is placed under the parent directory's mountpoint
                                        if (mountpoint := (_mountpoint := ddict.get("mountpoint", ""))) == "":
                                            if mountpoint = "":
                                                _mountpoint = _dataset.replace(
                                                    pn2 if pn2 in _dataset else pn1
                                                    "${host}",
                                                    1
                                                )
                                            else:
                                                mountpoint = _mountpoint = f"{mountpoint}/{dname}"
                            
                                        dnix.write(f'\t"{_dataset}" = "{_mountpoint}";\n')
                                    doptions = " -o ".join(_doptions)
                            
                            
                            
                            xrun(f"zfs {cc} {'-o ' if _doptions else ''} {doptions} {son} {_dataset}")
                            xrun(f"zfs snapshot -r {_dataset}@root")
                            
                                for dataset in (ddictd := ddict.get(
                                    d,
                                    dd
                                )):
                                    recurse(ddictd[dataset], dataset, _dataset, mountpoint)
                            
                            for dataset in datasets:
                                recurse(datasets[dataset], dataset, pool_name)
                            
                            dnix.write("}")
                            
                            pool_size_plus_metric = $(zpool get -H size @(pool_name)).split()[2]
                            pool_size = round(float(pool_size_plus_metric[:-1]), 2)
                            pool_metric = pool_size_plus_metric[-1]
                            
                            def pool_percentage_value(percentage):
                                return (
                                    str(
                                        round(
                                            (
                                                (float(percentage) / 100)
                                                * pool_size
                                            ),
                                            2,
                                        )
                                    )
                                    + pool_metric
                                )
                            
                            # Apparently, if python internal keywords exist in the argument, such as "set", etc.
                            # the command errors out; perhaps something to raise an issue of.
                            # This seems to work as an alternative.
                            xrun(f"zfs set refreservation={pool_percentage_value(15)} {pool_name}/reserved")
                            
                            if (swap := (raw_input('''
                                Will this pool use SWAP?
                                    y | n\n\t
                            ''') == "y")):
                                _swoptions = [
                                    "com.sun:auto-snapshot=false",
                                    "compression=zle",
                                    "logbias=throughput",
                                    "primarycache=metadata",
                                    "secondarycache=none"
                                    "sync=standard",
                                ]
                                swoptions = " -o ".join(_swoptions)
                            
                                ps = $(getconf PAGESIZE)
                                swap_size = int(raw_input("Please enter the (integer) SWAP size in GiB:\n\t"))
                                xrun(f"zfs create -V {2**swap_size}G -b {ps} -o {swoptions} {pool_name}/swap")
                            
                                xrun(f"mkswap -f /dev/zvol/{pool_name}/swap")
                            

                        elif cc == "g":
                            print("Goin' back!\n\n")
                            break
                        else:
                            print("Wait a minute... That's not a valid option! Try again, please!\n\n")
            elif c == "g":
                if raw_input('''
                    Would you like to generate a nixos "[hardware-]configuration.nix" file?
                        y | n\n\t
                ''') == "y":
                    xrun("nixos-generate-config")

            # TODO
            elif c == "b":
                if raw_input('''
                    Would you like to include the bootstrap file in the nixos "configuration.nix" file?
                        y | n\n\t
                ''') == "y":
                    xrun('sd "./hardware-configuration.nix" "./bootstrap.nix" /mnt/etc/nixos/configuration.nix')

            # TODO: Also include a one-stop-install, mounting, generating, copying, etc. all in one go
            elif c == "a":
                input = ""
                break

            elif c == "r":
                if raw_input('''
                    Would you like to rsync over the bootstrap files to "/mnt"?
                        y | n\n\t
                ''') == "y":
                    xrun("rsync -avvczz ../../ /mnt/")
            elif c == "i":
                if raw_input('''
                    Would you like to begin the NixOS bootstrap installation?
                        y | n\n\t
                ''') == "y":
                    xrun("nixos-install --show-trace")
            elif c == "h":

                print('''
                    Create a new ZFS device:         c
                    Mount a ZFS device:              m
                    Update:                          u
                            Files:                           f
                            Pool:                            p
                            Go back:                         g
                    Generate nixos config:           g
                    Include boostrap config:         b
                    One-Stop Install:                a
                    Rsync over bootstrap config:     r
                    Begin install:                   i
                    Show this help text:             h
                    Setup:                           s
                    Quit:                            q
                    Install and Set Up Home-Manager: H
                    \n\n
                ''')

            elif c == "s":

                while true:
                    pool_name = raw_input("What's the pool name?\n\t")
                    if pool_name == "":
                        print("Wait a minute... That's not a valid pool name! Try again, please!\n")
                    elif pool_name == "quit bootstrap":
                        print("Catch ya' later!")
                        exit(0)
                    else:
                        print("Alright; let's get crackin'!\n\n")
                        encrypted = raw_input('''
                            Is this pool [to be] encrypted?
                                y | n\n\t
                        ''') == "y"
                        break

            elif c == "H":

                # TODO
                pass

            elif c == "q":
                print("Catch ya' later!")
                break
            else:
                print(f'Wait a minute... The value "{c}" is not a valid option! Try again, please!\n\n')
                break

finally:
    xrun(f"zpool export {pool_name} &> /dev/null")
    exit(0)
