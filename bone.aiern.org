#+setupfile: ./README.org
#+include: ./README.org

This is used to hold detangle-able files for =./oreo.aiern.org=.

* system
** etc
*** nixos
**** overlays
***** _kataContainers.nix

#+call: hash("")

#+RESULTS:
: 0cc55c4a9547e4205ab191c4aeeef795

#+name: 0cc55c4a9547e4205ab191c4aeeef795
#+begin_src nix :tangle (jr/tangle-path) :comments link
{ stdenv, buildGoPackage, fetchFromGitHub, fetchurl, pkgconfig, libseccomp, go
, qemu }:

let
  version = "1.11.2";

  # prepare source to have a structure of GOPATH
  setSourceRoot = ''
    mkdir -p "go/src/$(dirname "$goPackagePath")"
    cp -R source "go/src/$goPackagePath"
    export sourceRoot="go/src/$goPackagePath"
  '';

  # default make flags, set GOPATH, GOCACHE and install prefix
  makeFlags = [
    "GOPATH=$(NIX_BUILD_TOP)/go"
    "GOCACHE=$(TMPDIR)/go-cache"
    "PREFIX=$(out)"
  ];

  # default meta
  meta = with stdenv.lib; {
    homepage = "https://katacontainers.io/";
    license = licenses.asl20;
    maintainers = with maintainers; [ offline ];
    platforms = platforms.linux;
  };

  agent = stdenv.mkDerivation {
    pname = "kata-agent";
    inherit version;

    src = fetchFromGitHub {
      owner = "kata-containers";
      repo = "agent";
      rev = version;
      sha256 = "6Zr7qwBuidJmKdZL2VGmRlKthWletdc0fRS5kA54CHM=";
    };

    goPackagePath = "github.com/kata-containers/agent";

    inherit setSourceRoot;

    nativeBuildInputs = [ pkgconfig go ];
    buildInputs = [ libseccomp ];

    makeFlags = makeFlags ++ [
      "UNIT_DIR=$(out)/lib/systemd/system"
      "SECCOMP=yes"
    ];

    meta = meta // {
      description = "Kata Containers version 1.x agent";
    };
  };

  ksm-throttler = stdenv.mkDerivation {
    pname = "kata-ksm-throttler";
    inherit version;

    src = fetchFromGitHub {
      owner = "kata-containers";
      repo = "ksm-throttler";
      rev = version;
      sha256 = "l+3pMjsfxU8170JKslhqv7PbaU3ROSQoscGQNbNh3+k=";
    };

    goPackagePath = "github.com/kata-containers/ksm-throttler";

    nativeBuildInputs = [ go ];

    inherit setSourceRoot makeFlags;

    meta = meta // {
      description = "Kata Containers KSM throttling daemon";
    };
  };

  proxy = stdenv.mkDerivation {
    pname = "kata-proxy";
    inherit version;

    src = fetchFromGitHub {
      owner = "kata-containers";
      repo = "proxy";
      rev = version;
      sha256 = "M2WaODisDPcpSc5AaMJEWI6MiF8Q1Iz/R6HzqFycOC8=";
    };

    goPackagePath = "github.com/kata-containers/proxy";

    nativeBuildInputs = [ go ];

    inherit setSourceRoot makeFlags;

    meta = meta // {
      description = "Kata Containers version 1.x proxy";
    };
  };

  shim = stdenv.mkDerivation {
    pname = "kata-shim";
    inherit version;

    src = fetchFromGitHub {
      owner = "kata-containers";
      repo = "shim";
      rev = version;
      sha256 = "sQHGCQ1Vowd6Zvm0wrN5Y2lEPzySkE1xlBt7tn3NppU=";
    };

    inherit setSourceRoot makeFlags;

    goPackagePath = "github.com/kata-containers/shim";

    nativeBuildInputs = [ go ];

    meta = meta // {
      description = "Kata Containers version 1.x shim";
    };
  };

  runtime = stdenv.mkDerivation {
    pname = "kata-runtime";
    inherit version;

    src = fetchFromGitHub {
      owner = "kata-containers";
      repo = "runtime";
      rev = version;
      sha256 = "TsXkkENZhH/p2SA4ytsWTiY5SJX+9FxUiX1o/v9RObo=";
    };

    goPackagePath = "github.com/kata-containers/runtime";

    nativeBuildInputs = [ go ];

    inherit setSourceRoot;

    makeFlags = makeFlags ++ [
      "SKIP_GO_VERSION_CHECK=true"
    ];

    patchPhase = ''
      substituteInPlace Makefile --replace '-i -o' '-o'
    '';

    meta = meta // {
      description = "Kata Containers version 1.x runtime";
    };
  };

  images = stdenv.mkDerivation {
    pname = "kata-container-images";
    inherit version;

    src = fetchurl {
      url =
        if stdenv.isx86_64
        then "https://github.com/kata-containers/runtime/releases/download/${version}/kata-static-${version}-x86_64.tar.xz"
        else throw "unsupported platform ${stdenv.system}";
      sha256 = "ai9n/Kb4llAqazuot1GMq/8my0RI4PUpy+/kA5kJdY8=";
    };

    installPhase = ''
      install -Dm644 -t "$out/share/kata-containers/" \
        kata/share/kata-containers/vmlinux-* \
        kata/share/kata-containers/vmlinuz-*
      install -Dm644 -t "$out/share/kata-containers/" \
        kata/share/kata-containers/config-*
      install -Dm644 -t "$out/share/kata-containers/" \
        kata/share/kata-containers/kata-containers*.img

      cd "$out/share/kata-containers/"
      ln -s vmlinux-[0-9].[0-9]* vmlinux.container
      ln -s vmlinuz-[0-9].[0-9]* vmlinuz.container
    '';

    meta = meta // {
      description = "Kata Containers version 1.x images";
    };
  };

  runtime-qemu = stdenv.lib.overrideDerivation runtime (p: {
    makeFlags = p.makeFlags ++ [
      "SHIMPATH=${shim}/libexec/kata-containers/kata-shim"
      "PROXYPATH=${proxy}/libexec/kata-containers/kata-proxy"
      "QEMUBINDIR=${qemu}/bin"
      "INITRDPATH=${images}/share/kata-containers/kata-containers-initrd.img"
      "KERNELDIR=${images}/share/kata-containers"
    ];
  });

in {
  inherit agent ksm-throttler proxy shim runtime images runtime-qemu;
}
#+end_src
**** patches
***** BACKPORT-Linux-5.8-compat-__vmalloc.patch

#+call: hash("")

#+RESULTS:
: 928b7053098bd8b58c6bb3b11c7f2138

#+name: 928b7053098bd8b58c6bb3b11c7f2138
#+begin_src diff :tangle (jr/tangle-path)
From 6cc95288ccea12ad7b67b2b5b3997dfad8e5b5c9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20Niew=C3=B6hner?=
 <c0d3z3r0@users.noreply.github.com>
Date: Tue, 9 Jun 2020 01:32:02 +0200
Subject: [PATCH] BACKPORT: Linux 5.8 compat: __vmalloc()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The `pgprot` argument has been removed from `__vmalloc` in Linux 5.8,
being `PAGE_KERNEL` always now [1].

Detect this during configure and define a wrapper for older kernels.

[1] https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/mm/vmalloc.c?h=next-20200605&id=88dca4ca5a93d2c09e5bbc6a62fbfc3af83c4fca

Reviewed-by: Brian Behlendorf <behlendorf1@llnl.gov>
Co-authored-by: Sebastian Gottschall <s.gottschall@dd-wrt.com>
Co-authored-by: Michael Niewöhner <foss@mniewoehner.de>
Signed-off-by: Sebastian Gottschall <s.gottschall@dd-wrt.com>
Signed-off-by: Michael Niewöhner <foss@mniewoehner.de>
Closes #10422
---
 config/kernel-kmem.m4       | 26 ++++++++++++++++++++++++++
 config/kernel.m4            |  2 ++
 include/spl/sys/kmem.h      |  9 +++++++++
 module/spl/spl-kmem-cache.c |  4 ++--
 module/spl/spl-kmem.c       |  9 ++++-----
 5 files changed, 43 insertions(+), 7 deletions(-)

diff --git a/config/kernel-kmem.m4 b/config/kernel-kmem.m4
index cc055e530..f1c0d2412 100644
--- a/config/kernel-kmem.m4
+++ b/config/kernel-kmem.m4
@@ -56,3 +56,29 @@ AC_DEFUN([SPL_AC_DEBUG_KMEM_TRACKING], [
    AC_MSG_CHECKING([whether detailed kmem tracking is enabled])
    AC_MSG_RESULT([$enable_debug_kmem_tracking])
 ])
+
+dnl #
+dnl # 5.8 API,
+dnl # __vmalloc PAGE_KERNEL removal
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_VMALLOC_PAGE_KERNEL], [
+   ZFS_LINUX_TEST_SRC([__vmalloc], [
+       #include <linux/mm.h>
+       #include <linux/vmalloc.h>
+   ],[
+       void *p __attribute__ ((unused));
+
+       p = __vmalloc(0, GFP_KERNEL, PAGE_KERNEL);
+   ])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_VMALLOC_PAGE_KERNEL], [
+   AC_MSG_CHECKING([whether __vmalloc(ptr, flags, pageflags) is available])
+   ZFS_LINUX_TEST_RESULT([__vmalloc], [
+       AC_MSG_RESULT(yes)
+       AC_DEFINE(HAVE_VMALLOC_PAGE_KERNEL, 1, [__vmalloc page flags exists])
+   ],[
+       AC_MSG_RESULT(no)
+   ])
+])
+-
diff --git a/config/kernel.m4 b/config/kernel.m4
index b67fcef8c..23edfdcd8 100644
--- a/config/kernel.m4
+++ b/config/kernel.m4
@@ -45,6 +45,7 @@ AC_DEFUN([ZFS_AC_KERNEL_TEST_SRC], [
    ZFS_AC_KERNEL_SRC_SCHED
    ZFS_AC_KERNEL_SRC_USLEEP_RANGE
    ZFS_AC_KERNEL_SRC_KMEM_CACHE
+   ZFS_AC_KERNEL_SRC_VMALLOC_PAGE_KERNEL
    ZFS_AC_KERNEL_SRC_WAIT
    ZFS_AC_KERNEL_SRC_INODE_TIMES
    ZFS_AC_KERNEL_SRC_INODE_LOCK
@@ -163,6 +164,7 @@ AC_DEFUN([ZFS_AC_KERNEL_TEST_RESULT], [
    ZFS_AC_KERNEL_SCHED
    ZFS_AC_KERNEL_USLEEP_RANGE
    ZFS_AC_KERNEL_KMEM_CACHE
+   ZFS_AC_KERNEL_VMALLOC_PAGE_KERNEL
    ZFS_AC_KERNEL_WAIT
    ZFS_AC_KERNEL_INODE_TIMES
    ZFS_AC_KERNEL_INODE_LOCK
diff --git a/include/spl/sys/kmem.h b/include/spl/sys/kmem.h
index 72d3a7765..ca15bfe7f 100644
--- a/include/spl/sys/kmem.h
+++ b/include/spl/sys/kmem.h
@@ -169,6 +169,15 @@ extern void *spl_kmem_alloc(size_t sz, int fl, const char *func, int line);
 extern void *spl_kmem_zalloc(size_t sz, int fl, const char *func, int line);
 extern void spl_kmem_free(const void *ptr, size_t sz);
 
+/*
+ * 5.8 API change, pgprot_t argument removed.
+ */
+#ifdef HAVE_VMALLOC_PAGE_KERNEL
+#define    spl_vmalloc(size, flags)    __vmalloc(size, flags, PAGE_KERNEL)
+#else
+#define    spl_vmalloc(size, flags)    __vmalloc(size, flags)
+#endif
+
 /*
  * The following functions are only available for internal use.
  */
diff --git a/module/spl/spl-kmem-cache.c b/module/spl/spl-kmem-cache.c
index d71b4b348..4866b2993 100644
--- a/module/spl/spl-kmem-cache.c
+++ b/module/spl/spl-kmem-cache.c
@@ -203,7 +203,7 @@ kv_alloc(spl_kmem_cache_t *skc, int size, int flags)
        ASSERT(ISP2(size));
        ptr = (void *)__get_free_pages(lflags, get_order(size));
    } else {
-       ptr = __vmalloc(size, lflags | __GFP_HIGHMEM, PAGE_KERNEL);
+       ptr = spl_vmalloc(size, lflags | __GFP_HIGHMEM);
    }
 
    /* Resulting allocated memory will be page aligned */
@@ -1242,7 +1242,7 @@ spl_cache_grow(spl_kmem_cache_t *skc, int flags, void **obj)
     * allocation.
     *
     * However, this can't be applied to KVM_VMEM due to a bug that
-    * __vmalloc() doesn't honor gfp flags in page table allocation.
+    * spl_vmalloc() doesn't honor gfp flags in page table allocation.
     */
    if (!(skc->skc_flags & KMC_VMEM)) {
        rc = __spl_cache_grow(skc, flags | KM_NOSLEEP);
diff --git a/module/spl/spl-kmem.c b/module/spl/spl-kmem.c
index cee69ad43..ca1fc145f 100644
--- a/module/spl/spl-kmem.c
+++ b/module/spl/spl-kmem.c
@@ -172,16 +172,15 @@ spl_kmem_alloc_impl(size_t size, int flags, int node)
         * kmem_zalloc() callers.
         *
         * For vmem_alloc() and vmem_zalloc() callers it is permissible
-        * to use __vmalloc().  However, in general use of __vmalloc()
-        * is strongly discouraged because a global lock must be
-        * acquired.  Contention on this lock can significantly
+        * to use spl_vmalloc().  However, in general use of
+        * spl_vmalloc() is strongly discouraged because a global lock
+        * must be acquired.  Contention on this lock can significantly
         * impact performance so frequently manipulating the virtual
         * address space is strongly discouraged.
         */
        if ((size > spl_kmem_alloc_max) || use_vmem) {
            if (flags & KM_VMEM) {
-               ptr = __vmalloc(size, lflags | __GFP_HIGHMEM,
-                   PAGE_KERNEL);
+               ptr = spl_vmalloc(size, lflags | __GFP_HIGHMEM);
            } else {
                return (NULL);
            }
-- 
2.25.1
#+end_src

***** 0110-initialize-ata-before-graphics.patch

#+call: hash("")

#+RESULTS:
: fc3edbb09363ebff0f5ab7c7a91e8816

#+name: fc3edbb09363ebff0f5ab7c7a91e8816
#+begin_src diff :tangle (jr/tangle-path)
From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Arjan van de Ven <arjan@linux.intel.com>
Date: Thu, 2 Jun 2016 23:36:32 -0500
Subject: [PATCH] initialize ata before graphics

ATA init is the long pole in the boot process, and its asynchronous.
move the graphics init after it so that ata and graphics initialize
in parallel
---
 drivers/Makefile | 15 ++++++++-------
 1 file changed, 8 insertions(+), 7 deletions(-)

diff --git a/drivers/Makefile b/drivers/Makefile
index c0cd1b9..af1e2fb 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -59,15 +59,8 @@ obj-y                += char/
 # iommu/ comes before gpu as gpu are using iommu controllers
 obj-y              += iommu/
 
-# gpu/ comes after char for AGP vs DRM startup and after iommu
-obj-y              += gpu/
-
 obj-$(CONFIG_CONNECTOR)        += connector/
 
-# i810fb and intelfb depend on char/agp/
-obj-$(CONFIG_FB_I810)           += video/fbdev/i810/
-obj-$(CONFIG_FB_INTEL)          += video/fbdev/intelfb/
-
 obj-$(CONFIG_PARPORT)      += parport/
 obj-$(CONFIG_NVM)      += lightnvm/
 obj-y              += base/ block/ misc/ mfd/ nfc/
@@ -80,6 +73,14 @@ obj-$(CONFIG_IDE)        += ide/
 obj-y              += scsi/
 obj-y              += nvme/
 obj-$(CONFIG_ATA)      += ata/
+
+# gpu/ comes after char for AGP vs DRM startup and after iommu
+obj-y              += gpu/
+
+# i810fb and intelfb depend on char/agp/
+obj-$(CONFIG_FB_I810)           += video/fbdev/i810/
+obj-$(CONFIG_FB_INTEL)          += video/fbdev/intelfb/
+
 obj-$(CONFIG_TARGET_CORE)  += target/
 obj-$(CONFIG_MTD)      += mtd/
 obj-$(CONFIG_SPI)      += spi/
-- 
https://clearlinux.org
#+end_src

***** export_kernel_fpu_functions_5_3.patch

#+call: hash("")

#+RESULTS:
: 243e368f70b55d126887480a4d4b6fb0

#+name: 243e368f70b55d126887480a4d4b6fb0
#+begin_src diff :tangle (jr/tangle-path)
From 1e010beda2896bdf3082fb37a3e49f8ce20e04d8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?J=C3=B6rg=20Thalheim?= <joerg@thalheim.io>
Date: Thu, 2 May 2019 05:28:08 +0100
Subject: [PATCH] x86/fpu: Export kernel_fpu_{begin,end}() with
 EXPORT_SYMBOL_GPL
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We need these symbols in zfs as the fpu implementation breaks userspace:

https://github.com/zfsonlinux/zfs/issues/9346
Signed-off-by: Jörg Thalheim <joerg@thalheim.io>
---
 arch/x86/kernel/fpu/core.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/arch/x86/kernel/fpu/core.c b/arch/x86/kernel/fpu/core.c
index 12c70840980e..352538b3bb5d 100644
--- a/arch/x86/kernel/fpu/core.c
+++ b/arch/x86/kernel/fpu/core.c
@@ -102,7 +102,7 @@ void kernel_fpu_begin(void)
    }
    __cpu_invalidate_fpregs_state();
 }
-EXPORT_SYMBOL_GPL(kernel_fpu_begin);
+EXPORT_SYMBOL(kernel_fpu_begin);
 
 void kernel_fpu_end(void)
 {
@@ -111,7 +111,7 @@ void kernel_fpu_end(void)
    this_cpu_write(in_kernel_fpu, false);
    preempt_enable();
 }
-EXPORT_SYMBOL_GPL(kernel_fpu_end);
+EXPORT_SYMBOL(kernel_fpu_end);
 
 /*
  * Save the FPU state (mark it for reload if necessary):
-- 
2.23.0
#+end_src

***** fetchpypi.patch

#+call: hash("")

#+RESULTS:
: a16b7e1d24613cbcab570cebb8c2d63d

#+name: a16b7e1d24613cbcab570cebb8c2d63d
#+begin_src diff :tangle (jr/tangle-path)
diff --git a/fetchpypi.nix b/fetchpypi.nix
index e60c9df..df50c0d 100644
--- a/fetchpypi.nix
+++ b/fetchpypi.nix
@@ -24,5 +24,5 @@ in makeOverridable( {format ? "setuptools", sha256 ? "", hash ? "", ... } @attrs
   let
     url = computeUrl (builtins.removeAttrs attrs ["sha256" "hash"]) ;
   in fetchurl {
-    inherit url sha256 hash;
+    inherit url sha256;
   })
#+end_src

***** fetchurl.patch

#+call: hash("")

#+RESULTS:
: e514edfc99898c7f058d2a7d93b94ea7

#+name: e514edfc99898c7f058d2a7d93b94ea7
#+begin_src diff :tangle (jr/tangle-path)
--- a/pkgs/build-support/fetchurl/boot.nix
+++ b/pkgs/build-support/fetchurl/boot.nix
@@ -6,7 +6,8 @@ let mirrors = import ./mirrors.nix; in
 , urls ? []
 , sha256
 , name ? baseNameOf (toString url)
-}:
+, ...
+} @ args:
 
 import <nix/fetchurl.nix> {
   inherit system sha256 name;
diff --git a/pkgs/build-support/fetchzip/default.nix b/pkgs/build-support/fetchzip/default.nix
index c61df8ceb00..d973837f0d3 100644
--- a/pkgs/build-support/fetchzip/default.nix
+++ b/pkgs/build-support/fetchzip/default.nix
@@ -14,7 +14,8 @@
 , name ? "source"
 , ... } @ args:
 
-(fetchurl ({
+let
+ x = (fetchurl ({
   inherit name;
 
   recursiveHash = true;
@@ -46,7 +47,11 @@
       mv "$unpackDir" "$out"
     '') #*/
     + extraPostFetch;
-} // removeAttrs args [ "stripRoot" "extraPostFetch" ])).overrideAttrs (x: {
+  } // removeAttrs args [ "stripRoot" "extraPostFetch" ]));
+
+in
+  x // {
+    # .overrideAttrs (x: {
   # Hackety-hack: we actually need unzip hooks, too
   nativeBuildInputs = x.nativeBuildInputs ++ [ unzip ];
-})
+}
#+end_src

***** grub_zfs.patch

#+call: hash("")

#+RESULTS:
: 86b1ce952cf7cacf52c28f5e903aa788

#+name: 86b1ce952cf7cacf52c28f5e903aa788
#+begin_src diff :tangle (jr/tangle-path)
--- a/grub-core/fs/zfs/zfs.c
+++ b/grub-core/fs/zfs/zfs.c
@@ -285,6 +285,7 @@ static const char *spa_feature_names[] = {
   "com.delphix:embedded_data",
   "com.delphix:extensible_dataset",
   "org.open-zfs:large_blocks",
+  "org.zfsonlinux:large_dnode",
   NULL
 };
#+end_src

***** set_power_mgmt.patch

#+call: hash("")

#+RESULTS:
: 4c357c0be0f342085007deacecff91c5

#+name: 4c357c0be0f342085007deacecff91c5
#+begin_src diff :tangle (jr/tangle-path)
--- a/net/wireless/nl80211.c    2019-07-08 00:41:56.000000000 +0200
+++ b/net/wireless/nl80211.c    2020-02-05 19:30:26.352718504 +0100
@@ -10517,10 +10520,7 @@
    if (!rdev->ops->set_power_mgmt)
        return -EOPNOTSUPP;
 
-   state = (ps_state == NL80211_PS_ENABLED) ? true : false;
-
-   if (state == wdev->ps)
-       return 0;
+   state = false;
 
    err = rdev_set_power_mgmt(rdev, dev, state, wdev->ps_timeout);
    if (!err)
#+end_src

* home
*** naked.el

#+call: hash("")

#+name: 
#+begin_src emacs-lisp :tangle (jr/tangle-path) :comments link
;;; naked.el --- Provide for naked key descriptions: no angle brackets.
;;
;; Filename: naked.el
;; Description: Provide for naked key descriptions: no angle brackets.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 2011-2020, Drew Adams, all rights reserved.
;; Created: Fri Oct  7 13:12:52 2011 (-0700)
;; Version: 0
;; Package-Requires: ()
;; Last-Updated: Wed Oct 14 08:46:05 2020 (-0700)
;;           By: dradams
;;     Update #: 206
;; URL: https://www.emacswiki.org/emacs/download/naked.el
;; Doc URL: https://www.emacswiki.org/emacs/NaKeD
;; Keywords: lisp, key, print, format, help
;; Compatibility: GNU Emacs 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   None
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;  Lets you use key-sequence descriptions that do not bother with
;;  angle brackets: `<' and `>'.
;;
;;  Prior to Emacs 21, vanilla GNU Emacs did not bother with angle
;;  brackets either, but someone around the turn of the century got
;;  the idea that Emacs could not do without them.  So instead of the
;;  `delete' key we now have the `<delete>' key.  And instead of`C-x
;;  M-delete' we now have `C-x M-<delete>'.  "On n'arrete pas le
;;  progres !"
;;
;;  Angle brackets are not needed - why?  Because we already use
;;  spaces to separate keys in a key-sequence description (we use
;;  `SPC' to indicate the SPACE key).
;;
;;  To be fair, it is true that sometimes people have taken the
;;  shortcut when writing about user input of writing, e.g., `M-x
;;  forward-char RET' instead of writing `M-x f o r w a r d - c h a
;;  r'. And if you write `forward' that way to stand for an input
;;  sequence of seven chars, then you cannot also expect `forward' to
;;  stand for a function key named `forward', can you?
;;
;;  Well, yes you can, if the context makes things clear enough.  And
;;  I for one find `C-M-<insert>' butt-ugly (likewise `<C-M-insert>')
;;  - and, more importantly, insulting to Occam and his razor.
;;
;;  So go ahead and go NaKeD - shed your angles.
;;
;;  Here's what you need.  It won't completely purge Emacs from
;;  insulting you with the occasional pair of angle brackets, but it
;;  at least lets you DTRT in code that you write:
;;
;;  * Use function `naked-key-description' instead of
;;    `key-description'.
;;
;;    The former outputs naked key descriptions: no angle brackets
;;    around function keys.  E.g., if KEY is the sequence of events
;;    produced by holding the Shift key while hitting the Insert key,
;;    then `(naked-key-description KEY)' returns "S-insert" (and not
;;    "S-<insert>").  (Internally, this sequence of events is the
;;    vector [S-insert].)
;;
;;  * Use function `naked' instead of `kbd' (which is a function
;;    starting with Emacs 24.3 and a macro before then).
;;
;;    The former allows its argument key-sequence description to use
;;    naked keys, not clothed in angle brackets.  E.g., (naked
;;    "C-M-delete") has the same effect as (kbd "C-M-<delete>").
;;
;;  * Use command `naked-read-kbd-macro' instead of `read-kbd-macro'.
;;
;;  * Use function `naked-edmacro-parse-keys' instead of
;;    `edmacro-parse-keys' (if you happen to use that lower-level
;;    function).
;;
;;  But you can also have it both ways if or when you might need to:
;;  All of these accept an optional argument ANGLES which, if
;;  non-`nil', returns the behavior to the vanilla one, expecting
;;  function keys to be fully clothed in angle brackets.  E.g.: (naked
;;  "C-M-<delete>" t).
;;
;;  In addition, even without an non-nil ANGLES argument, function
;;  `naked' does the right thing for keys expressed using angle
;;  brackets.  IOW, (naked "M-<foobar>") returns the same thing that
;;  (naked "M-foobar") does: [M-foobar].
;;
;;  Enjoy!
;;
;;
;;  Command defined here:
;;
;;    `naked-read-kbd-macro'.
;;
;;  Non-interactive functions defined here:
;;
;;    `naked', `naked-edmacro-parse-keys', `naked-key-description',
;;    `naked-read-kbd-macro', `naked-string-match-p'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2020/10/13 dadams
;;     Added: naked-string-match-p.
;;     naked-edmacro-parse-keys: Use naked-string-match-p when don't need to set match data.
;;     naked-read-kbd-macro: Fixed typo: \P -> \nP.
;; 2017/04/18 dadams
;;     Added forgotten compile-time require of cl.el, for macro loop.
;; 2013/02/26 dadams
;;     Added (put 'naked 'pure t)
;; 2012/12/01 dadams
;;     Change naked from a macro to a function (like Emacs 24.3).
;; 2012/09/28 dadams
;;     naked-edmacro-parse-keys:
;;       Better fix for M-TAB.  Do not assume that function keys are lowercase.
;;       Handle angle brackets even if ANGLES is nil.  But keep vanilla bug #12535 if non-nil.
;; 2012/09/27 dadams
;;     naked-edmacro-parse-keys: Fix handling of M-TAB.  Function keys are lowercase.
;;                               So M-TAB returns [134217737], but M-tab returns [M-tab].
;; 2011/10/07 dadams
;;     Created.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 3, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(eval-when-compile (require 'cl)) ;; loop

;;;;;;;;;;;;;;;;;;;;;;;;;

(if (fboundp 'string-match-p)
    (defalias 'naked-string-match-p 'string-match-p) ; Emacs 23+
  (defun naked-string-match-p (regexp string &optional start)
    "Like `string-match', but this saves and restores the match data."
    (save-match-data (string-match regexp string start))))

;; Same as `icicle-key-description' in `icicles-fn.el'.
(defun naked-key-description (keys &optional prefix angles)
  "Like `key-description', but does not use angle brackets, by default.
Non-nil optional arg ANGLES means use angle brackets."
  (let ((result  (if (< emacs-major-version 22)
                     (key-description keys)
                   (key-description keys prefix))))
    (unless angles                      ; Assume that spaces separate function keys.
      (setq result  (replace-regexp-in-string "<\\([^>]+\\)>" "\\1" result 'fixed-case)))
    result))

;; Same as `icicle-edmacro-parse-keys' in `icicles-mac.el'.
;; Based on `edmacro-parse-keys' in standard library `edmacro.el'
;; Differences are:
;;
;; 1. Addition of optional arg ANGLES.
;; 2. Ensure same behavior as `edmacro-parse-keys', if ANGLES is non-nil.
;; 2. Handle angle brackets, whether ANGLES is nil or non-nil.
;; 3. Handle `TAB' correctly, if ANGLES is nil.
;; 4. Handle names without angle brackets, if ANGLES is nil.
;; 5. Works for all Emacs versions.
;;
(defun naked-edmacro-parse-keys (string &optional need-vector angles)
  "Like `edmacro-parse-keys', but does not use angle brackets, by default.
Non-nil optional arg ANGLES means to use angle brackets, exactly like
`edmacro-parse-keys'.  See `naked-read-kbd-macro' for more about
ANGLES."
  (let ((case-fold-search  nil)
	(len               (length string)) ; We won't alter string in the loop below.
        (pos               0)
        (res               []))
    (while (and (< pos len)  (string-match "[^ \t\n\f]+" string pos))
      (let* ((word-beg  (match-beginning 0))
	     (word-end  (match-end 0))
	     (word      (substring string word-beg len))
	     (times     1)
             (key       nil))
	;; Try to catch events of the form "<as df>".
        (if (string-match "\\`<[^ <>\t\n\f][^>\t\n\f]*>" word)
            (setq word  (match-string 0 word)
                  pos   (+ word-beg (match-end 0)))
          (setq word  (substring string word-beg word-end)
                pos   word-end))
        (when (string-match "\\([0-9]+\\)\\*." word)
          (setq times  (string-to-number (substring word 0 (match-end 1)))
                word   (substring word (1+ (match-end 1)))))
        (cond ((naked-string-match-p "^<<.+>>$" word)
               (setq key  (vconcat (if (eq (key-binding [?\M-x]) 'execute-extended-command)
                                       [?\M-x]
                                     (or (car (where-is-internal 'execute-extended-command))  [?\M-x]))
                                   (substring word 2 -2) "\r")))

              ;; Must test this before [ACHMsS]- etc., to prevent match.
              ((or (equal word "REM")  (naked-string-match-p "^;;" word))
               (setq pos  (naked-string-match-p "$" string pos)))

              ;; Straight `edmacro-parse-keys' case - ensure same behavior.
              ;; Includes same bugged handling of `TAB'.  That is Emacs bug #12535.
              ;; The bug fix is to add `TAB' to the list in this clause.
	      ((and angles
                    (string-match "^\\(\\([ACHMsS]-\\)*\\)<\\(.+\\)>$" word)
		    (progn
		      (setq word  (concat (substring word (match-beginning 1) (match-end 1))
                                          (substring word (match-beginning 3) (match-end 3))))
		      (not (naked-string-match-p "\\<\\(NUL\\|RET\\|LFD\\|ESC\\|SPC\\|DEL\\)$" word))))
	       (setq key  (list (intern word))))

              ;; NaKeD handling of <...>.  Recognize it anyway, even without non-nil ANGLES.
              ;; But unlike `edmacro-parse-keys', include <TAB>, to handle it correctly.
              ((and (string-match "^\\(\\([ACHMsS]-\\)*\\)<\\(..+\\)>$" word)
                    (progn
                      (setq word  (concat (substring word (match-beginning 1) (match-end 1))
                                          (substring word (match-beginning 3) (match-end 3))))
                      (not (naked-string-match-p "\\<\\(NUL\\|RET\\|LFD\\|ESC\\|SPC\\|DEL\\|TAB\\)$" word))))
               (setq key  (list (intern word))))

              ;; NaKeD handling of names without <...>.
              ((and (not angles)
                    (string-match "^\\(\\([ACHMsS]-\\)*\\)\\([^ \t\f\n][^ \t\f\n]+\\)$" word)
                    ;; Do not count `C-' etc. when at end of string.
                    (not (naked-string-match-p "\\([ACHMsS]-.\\)+$" word))
                    (progn
                      (setq word  (concat (substring word (match-beginning 1) (match-end 1))
                                          (substring word (match-beginning 3) (match-end 3))))
                      (not (naked-string-match-p "\\<\\(NUL\\|RET\\|LFD\\|ESC\\|SPC\\|DEL\\|TAB\\)$" word))))
               (setq key  (list (intern word))))

              (t
               (let ((orig-word  word)
                     (prefix     0)
                     (bits       0))
                 (while (naked-string-match-p "^[ACHMsS]-." word)
                   (incf bits (cdr (assq (aref word 0) '((?A . ?\A-\^@) (?C . ?\C-\^@)
                                                         (?H . ?\H-\^@) (?M . ?\M-\^@)
                                                         (?s . ?\s-\^@) (?S . ?\S-\^@)))))
                   (incf prefix 2)
                   (callf substring word 2))
                 (when (naked-string-match-p "^\\^.$" word)
                   (incf bits ?\C-\^@)
                   (incf prefix)
                   (callf substring word 1))
                 (let ((found  (assoc word '(("NUL" . "\0") ("RET" . "\r") ("LFD" . "\n")
                                             ("ESC" . "\e") ("SPC" . " ") ("DEL" . "\177")
                                             ("TAB" . "\t")))))
                   (when found (setq word  (cdr found))))
                 (when (naked-string-match-p "^\\\\[0-7]+$" word)
                   (loop for ch across word
                         for n = 0 then (+ (* n 8) ch -48)
                         finally do (setq word  (vector n))))
                 (cond ((= bits 0) (setq key  word))
                       ((and (= bits ?\M-\^@)
                             (stringp word)
                             (naked-string-match-p "^-?[0-9]+$" word))
                        (setq key  (loop for x across word collect (+ x bits))))
                       ((/= (length word) 1)
                        (error "%s must prefix a single character, not %s"
                               (substring orig-word 0 prefix) word))
                       ((and (/= (logand bits ?\C-\^@) 0)
                             (stringp word)
                             ;; Used to accept `.' and `?' here, but `.' is simply wrong,
                             ;; and `C-?' is not used (so use `DEL' instead).
                             (naked-string-match-p "[@-_a-z]" word))
                        (setq key  (list (+ bits (- ?\C-\^@) (logand (aref word 0) 31)))))
                       (t
                        (setq key  (list (+ bits (aref word 0)))))))))
        (when key (loop repeat times do (callf vconcat res key)))))
    (when (and (>= (length res) 4)  (eq (aref res 0) ?\C-x)  (eq (aref res 1) ?\()
               (eq (aref res (- (length res) 2)) ?\C-x)  (eq (aref res (- (length res) 1)) ?\)))
      (setq res  (edmacro-subseq res 2 -2)))
    (if (and (not need-vector)
	     (loop for ch across res
		   always (and (if (fboundp 'characterp) (characterp ch) (char-valid-p ch))
			       (let ((ch2  (logand ch (lognot ?\M-\^@))))
				 (and (>= ch2 0)  (<= ch2 127))))))
	(concat (loop for ch across res collect (if (= (logand ch ?\M-\^@) 0)  ch  (+ ch 128))))
      res)))

;; Same as `icicle-read-kbd-macro' in `icicles-mac.el'.
;;;###autoload
(defun naked-read-kbd-macro (start &optional end angles)
  "Read the region as a keyboard macro definition.
Like `read-kbd-macro', but does not use angle brackets, by default.

With a prefix arg use angle brackets, exactly like `read-kbd-macro'.
That is, with non-nil arg ANGLES, expect key descriptions to use angle
brackets (<...>).  Otherwise, expect key descriptions not to use angle
brackets.  For example:

 (naked-read-kbd-macro  \"mode-line\"  t)   returns [mode-line]
 (naked-read-kbd-macro \"<mode-line>\" t t) returns [mode-line]"
  (interactive "r\nP")
  (if (stringp start)
      (naked-edmacro-parse-keys start end angles)
    (setq last-kbd-macro  (naked-edmacro-parse-keys (buffer-substring start end) nil angles))))

(put 'naked 'pure t)
;; Same as `icicle-kbd' in `icicles-opt.el'.
(defun naked (keys &optional angles)
  "Like `kbd', but does not use angle brackets, by default.
With non-nil optional arg ANGLES, expect key descriptions to use angle
brackets (<...>), exactly like `kbd'.  Otherwise, expect key
descriptions not to use angle brackets.  For example:

 (naked \"mode-line\")     returns [mode-line]
 (naked \"<mode-line>\" t) returns [mode-line]

The default behavior lets you use, e.g., \"C-x delete\" and \"C-delete\"
instead of \"C-x <delete>\" and \"C-<delete>\"."
  (naked-read-kbd-macro keys nil angles))

;;;;;;;;;;;;;;;;;

(provide 'naked)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; naked.el ends here
#+end_src

*** help+20.el

#+call: hash("")

#+RESULTS:
: 76562b6bc9a2d6ff3252277966805443

#+name: 76562b6bc9a2d6ff3252277966805443
#+begin_src emacs-lisp :tangle (jr/tangle-path) :comments link
;;; help+20.el --- Extensions to `help.el' for Emacs 20.
;;
;; Filename: help+20.el
;; Description: Extensions to `help.el' for Emacs 20.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 1999-2018, Drew Adams, all rights reserved.
;; Created: Tue Mar 16 14:18:11 1999
;; Version: 0
;; Package-Requires: ()
;; Last-Updated: Mon Jan  1 13:12:09 2018 (-0800)
;;           By: dradams
;;     Update #: 2219
;; URL: https://www.emacswiki.org/emacs/download/help%2b20.el
;; Doc URL: https://emacswiki.org/emacs/HelpPlus
;; Keywords: help
;; Compatibility: GNU Emacs 20.x
;;
;; Features that might be required by this library:
;;
;;   `avoid', `fit-frame', `frame-fns', `info', `info+20',
;;   `misc-fns', `naked', `strings', `thingatpt', `thingatpt+',
;;   `wid-edit', `wid-edit+', `widget'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Extensions to `help.el' for Emacs 20.
;;
;;  Commands defined here:
;;
;;    `describe-command', `describe-file', `describe-keymap',
;;    `describe-option', `describe-option-of-type',
;;    `help-on-click/key', `mouse-help-on-click',
;;    `mouse-help-on-mode-line-click', `pop-to-help-toggle',
;;    `view-emacs-lisp-news', `save-*Help*-buffer'.
;;
;;  Non-interactive functions defined here:
;;
;;    `help-custom-type', `help-on-click/key-lookup',
;;    `help-remove-duplicates', `help-value-satisfies-type-p',
;;    `help-var-inherits-type-p', `help-var-is-of-type-p',
;;    `help-var-matches-type-p', `help-var-val-satisfies-type-p',
;;    `remove-help-window'.
;;
;;  Internal variables defined here:
;;
;;    `help-origin-buffer'.
;;
;;
;;  ***** NOTE: The following functions defined in `help.el' have
;;              been REDEFINED HERE:
;;
;;  `describe-function', `describe-function-1', `describe-key',
;;  `describe-mode', `describe-project', `describe-variable',
;;  `help-mode', `help-with-tutorial', `locate-library',
;;  `view-emacs-FAQ', `view-emacs-news', `where-is'.
;;
;;
;;  ***** NOTE: The doc string for `help-for-help' has been
;;              REDEFINED HERE
;;              (see `make-help-screen help-for-help')
;;
;;  The following bindings are made here:
;;
;;    `q'          `View-quit' (in `help-mode')
;;    `C-h c'      `describe-command' (replaces `describe-key-briefly')
;;    `C-h o'      `describe-option'
;;    `C-h u'      `manual-entry'
;;    `C-h C-a'    `apropos'
;;    `C-h C-c'    `describe-key-briefly' (replaces `describe-copying')
;;    `C-h C-l'    `locate-library'
;;    `C-h C-n'    `view-emacs-lisp-news'
;;    `C-h C-o'    `describe-option-of-type'
;;    `C-h C-s'    `save-*Help*-buffer'
;;    `C-h RET'    `help-on-click/key'
;;    `C-h M-a'    `apropos-documentation'
;;    `C-h M-c'    `describe-copying' (replaces `C-h C-c')
;;    `C-h M-f'    `describe-file'
;;    `C-h M-k'    `describe-keymap'
;;    `C-h M-o'    `pop-to-help-toggle'
;;    `C-h M-C-a'  `tags-apropos'
;;    [mouse-1]    `mouse-help-on-click' (non-mode-line)
;;    [mouse-1]    `mouse-help-on-mode-line-click' (mode-line)
;;
;;  Suggested additional binding:
;;
;;   (global-set-key [f1] 'help-on-click/key)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2017/01/15 dadams
;;     Added redefinition of describe-function-1.  Handle Emacs bug from its own advice.
;; 2014/05/04 dadams
;;     Soft-require info+20.el (new) instead of info+.el.
;; 2012/09/24 dadams
;;     describe-file: Added optional arg NO-ERROR-P.
;; 2012/08/21 dadams
;;     Call tap-put-thing-at-point-props after load thingatpt+.el.
;; 2012/08/18 dadams
;;     Invoke tap-define-aliases-wo-prefix if thingatpt+.el is loaded.
;;     help-on-click/key: Use tap-symbol-at-point, not symbol-at-point, if defined.
;; 2012/01/11 dadams
;;     describe-variable: Remove * from beginning of doc string.
;; 2011/12/19 dadams
;;     help-with-tutorial, describe-variable: Use line-end-position, not end-of-line + point.
;;     describe-variable: if -> when.
;; 2011/10/07 dadams
;;     Added soft require of naked.el.
;;     describe-key, where-is, help-on-click/key-lookup: Use naked-key-description if available.
;; 2011/04/25 dadams
;;     describe-file: Incorporate autofile bookmark description.  Added optional arg.
;; 2011/03/31 dadams
;;     help-var-(matches|inherits)-type-p: Wrap string-match with save-match-data.
;; 2011/01/04 dadams
;;     Removed autoload cookies from non-interactive function and define-key.
;; 2009/08/30 dadams
;;     describe-keymap: Don't print nil if the map has no doc.
;; 2008/08/19 dadams
;;     describe-keymap: Use insert instead of princ for map part.  Thx to Chong Yidong.
;; 2008/05/20 dadams
;;     describe-function: Different prompt if prefix arg.
;; 2008/03/02 dadams
;;     Moved describe-file here from misc-cmds.el.  Bound to C-h M-f.
;; 2008/01/17 dadams
;;     Removed soft require of icicles.el
;; 2007/12/25 dadams
;;     help-var-inherits-type-p:
;;       Recheck var-type match after set var-type to its car.
;;       Handle string (regexp) TYPES elements.
;;     help-value-satisfies-type-p: Skip type check for string type (regexp).
;;     help-var-is-of-type-p: Doc string.  Use help-var-matches-type-p.
;;     Added: help-var-matches-type-p.
;; 2007/12/24 dadams
;;     help-var-inherits-type-p: Recheck type match after set var-type to its car.
;;     Added: help-custom-type.
;; 2007/12/23 dadams
;;     help-var-is-of-type-p:
;;       Added MODE arg.  Use help-var-inherits-type-p, help-var-val-satisfies-type-p.
;;       Redefined as MODE choice, not just a simple or.  Treat more cases.
;;     Added: help-var-inherits-type-p, help-var-val-satisfies-type-p,
;;            help-value-satisfies-type-p.
;;     describe-option-of-type: Prefix arg means use mode inherit-or-value.
;; 2007/12/22 dadams
;;     help-var-is-of-type-p:
;;       Check supertypes also.  Use both :validate and :match.
;;       Wrap type check in condition-case. Use widget-put instead of plist-put.
;;     Added soft require of wid-edit+.el.
;; 2007/12/21 dadams
;;     help-var-is-of-type-p: Use :validate, not :match, for the test.
;; 2007/12/20 dadams
;;     Swapped C-o and M-o bindings.
;; 2007/12/15 dadams
;;     Bound C-h c to describe-command and C-h C-c to describe-key-briefly.
;; 2007/12/14 dadams
;;     Renamed library from help+.el to help+20.el.  New help+.el is for Emacs 22+.
;;     Removed commented Emacs 19 stuff.
;;     view-emacs-lisp-news, describe-(key|function|variable):
;;       Removed emacs-major-version test.
;;     Added: Redefinition of help-mode.
;;     Bound q in help-mode to View-quit.
;;     Don't require cl.el if before Emacs 20.
;; 2007/12/13 dadams
;;     help-on-click/key: Removed extra arg in call to message.
;;     help-for-help: Reordered help string.
;; 2007/12/09 dadams
;;     (make-help-screen help-for-help...): Rewrote help text.
;; 2007/12/07 dadams
;;     describe-variable: if OPTIONP, then allow custom-variable-p as well as user-variable-p.
;;     describe-option-of-type: Use "nil" as default value.
;; 2007/12/06 dadams
;;     describe-option-of-type:
;;       If nil type, all defcustom vars are candidates.  Use custom-variable-p, if available.
;;       Specific error if no such custom type.
;;     describe-option: Use both custom-variable-p and user-variable-p.
;; 2007/12/04 dadams
;;     Added: describe-option-of-type, help-remove-duplicates, help-var-is-of-type-p.
;;     Bound o to describe-option (no longer edit-options), M-o to describe-option-of-type,
;;       C-c to describe-command, M-c to describe-copying.
;; 2007/11/28 dadams
;;     Renamed describe-bindings-in-map to describe-keymap.  Added keymap's doc string.
;; 2007/11/27 dadams
;;     locate-library: Use icicle-read-string-completing, if available.
;;     Soft require Icicles.
;; 2007/11/22 dadams
;;     Added: describe-bindings-in-map.  Bound to C-h M-k.
;; 2007/10/17 dadams
;;     describe-(function|variable): Prefix arg means describe only commands or user options.
;;     Added: describe-(command|option).
;; 2007/09/04 dadams
;;     remove-windows-on -> delete-windows-on.  Removed require of frame-cmds.el.
;; 2006/12/08 dadams
;;     describe-variable: Fixed interactive case when symbol-nearest-point is not defined.
;; 2006/07/11 dadams
;;     Added: help-origin-buffer, pop-to-help-toggle.  Bound latter to C-h C-o globally
;; 2005/10/31 dadams
;;     Use nil as init-value arg in calls to completing-read, everywhere.
;; 2001/01/10 dadams
;;     Protected remove-windows-on via fboundp.
;; 1999/08/12 dadams
;;     Added doc strings for help-on-click/key(-lookup) and updated header.
;; 1999/04/09 dadams
;;     help-on-click/key: Treat mouse click on symbol via apropos.
;; 1999/04/08 dadams
;;     help-on-click/key: 1. Treat mouse menus.
;;                        2. Corrected: flush extra mode-line mouse events.
;; 1999/04/08 dadams
;;     help-on-click/key: Bound temp-buffer-show-function so use other win.
;; 1999/04/08 dadams
;;     1. Added binding: help-on-click/key.
;;     2. Added: make-help-screen help-for-help.
;;     3. help-on-click/key-lookup: show-*Help*-buffer.
;;     4. help-on-click/key: Prompt.  Corrected: event->key, show-*Help*-buffer.
;; 1999/04/07 dadams
;;     1. Added: (replacement) describe-key.
;;     2. Added: help-on-click/key-lookup, help-on-click/key.
;; 1999/04/06 dadams
;;     Added binding for save-*Help*-buffer.
;; 1999/04/06 dadams
;;     1. Added some key bindings: o, u, C-l, C-a, M-a, C-M-a.
;;     2. Added: save-*Help*-buffer.
;; 1999/03/31 dadams
;;     Protected symbol-nearest-point with fboundp.
;; 1999/03/17 dadams
;;     1. Added: remove-help-window, help-with-tutorial, describe-project,
;;        view-emacs-FAQ, view-emacs-news, describe-function, describe-variable,
;;        where-is, locate-library, view-emacs-lisp-news.
;;     2. help-iso-prefix: Treat unbound iso-transl-char-map error.  Removed
;;        highlighting.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(require 'info nil t) ;; (no error if not found):
                      ;; Info-exit, Info-goto-node, Info-goto-emacs-key-command-node
(require 'info+20 nil t) ;; (no error if not found):
                         ;; Info-goto-emacs-key-command-node (returns found-p)
(require 'thingatpt nil t) ;; (no error if not found): symbol-at-point

(when (and (require 'thingatpt+ nil t);; (no error if not found)
           (fboundp 'tap-put-thing-at-point-props)) ; >= 2012-08-21
  (tap-define-aliases-wo-prefix)
  (tap-put-thing-at-point-props))
  ;;  symbol-nearest-point, tap-symbol-at-point

(require 'frame-fns nil t) ;; (no error if not found): 1-window-frames-on
(require 'wid-edit+ nil t) ;; (no error if not found):
                           ;; redefined color widget (for help-var-is-of-type-p)
(require 'naked nil t) ;; (no error if not found): naked-key-description

;; Get macro `make-help-screen' when this is compiled,
;; or run interpreted, but not when the compiled code is loaded.
(eval-when-compile
  (require 'help-macro nil t) ;; (no error if not found) make-help-screen
  (require 'help-macro+ nil t)) ;; (no error if not found): make-help-screen
;; (require 'icicles nil t) ;; (no error if not found): icicle-read-string-completing


;; Quiet the byte-compiler.
(defvar view-no-disable-on-exit)
(defvar view-exit-action)

;;;;;;;;;;;;;;;;;;;;

(defvar help-origin-buffer nil "Buffer that we left, to go to *Help*.")

(define-key help-map "c" 'describe-command)
(define-key help-map "o" 'describe-option)
(define-key help-map "u" 'manual-entry) ; in `man.el'
(define-key help-map "\C-a" 'apropos)
(define-key help-map "\C-c" 'describe-key-briefly)
(define-key help-map "\C-l" 'locate-library)
(define-key help-map [?\C-m] 'help-on-click/key) ; RET
(define-key help-map [?\C-n] 'view-emacs-lisp-news)
(define-key help-map "\C-o" 'describe-option-of-type)
(define-key help-map "\C-s" 'save-*Help*-buffer)
(define-key help-map "\M-a" 'apropos-documentation)
(define-key help-map "\M-c" 'describe-copying)
(define-key help-map "\M-f" 'describe-file)
(define-key help-map "\M-k" 'describe-keymap)
(define-key help-map "\M-o" 'pop-to-help-toggle)
(define-key help-map "\M-\C-a" 'tags-apropos)
(define-key help-map [down-mouse-1] 'mouse-help-on-click)
(define-key help-map [mode-line down-mouse-1] 'mouse-help-on-mode-line-click)

;; `help-mode' too needs a quit key.
(define-key help-mode-map "q" 'View-quit)


(defsubst remove-help-window ()
  "If called from `help-for-help', remove display of help window."
  (when (eq 'help-for-help this-command) (delete-windows-on "*Help*")))


;; REPLACES ORIGINAL in `help.el':
;; Deletes *Help* frame when done, if `one-window-p'.
;;
;;;###autoload
(defun help-mode ()
  "Major mode for viewing help text and navigating references in it.
Entry to this mode runs the normal hook `help-mode-hook'.
Commands:
\\{help-mode-map}"
  (interactive)
  (kill-all-local-variables)
  (use-local-map help-mode-map)
  (setq mode-name   "Help"
        major-mode  'help-mode)
  (make-local-variable 'font-lock-defaults)
  (setq font-lock-defaults  nil)        ; font-lock would defeat xref
  (view-mode)
  (make-local-variable 'view-no-disable-on-exit)
  (setq view-no-disable-on-exit  t
        view-exit-action         (lambda (buffer)
                                   (or (window-minibuffer-p (selected-window))
                                       (when (eq (window-buffer) (get-buffer "*Help*"))
                                         (if (one-window-p t)
                                             (delete-frame)
                                           (delete-window))))))
  ;; `help-make-xrefs' would be run here if not invoked from
  ;; `help-mode-maybe'.
  (run-hooks 'help-mode-hook))


;; REPLACES ORIGINAL in `help.el':
;; 1. Uses other window.
;; 2. Calls `remove-help-window'.
;; 3. Messages added.
;;;###autoload
(defun help-with-tutorial (&optional arg)
  "Select the Emacs learn-by-doing tutorial.
If there is a tutorial version written in the language
of the selected language environment, that version is used.
If there's no tutorial in that language, `TUTORIAL' is selected.
With prefix ARG, you are asked to choose which language."
  (interactive "P")
  (message "Looking for Emacs Tutorial file...")
  (let ((lang  (if arg
                   (read-language-name 'tutorial "Language: " "English")
                 (if (get-language-info current-language-environment 'tutorial)
                     current-language-environment
                   "English")))
        file filename)
    (setq filename  (get-language-info lang 'tutorial)
          file      (expand-file-name (concat "~/" filename)))
    (delete-other-windows)
    (if (get-file-buffer file)
        (switch-to-buffer-other-window (get-file-buffer file))
      (switch-to-buffer-other-window (create-file-buffer file))
      (setq buffer-file-name            file
            default-directory           (expand-file-name "~/")
            buffer-auto-save-file-name  nil)
      (insert-file-contents (expand-file-name filename data-directory))
      (goto-char (point-min))
      (search-forward "\n<<")
      (beginning-of-line)
      (delete-region (point) (line-end-position))
      (let ((n  (- (window-height (selected-window))
                   (count-lines (point-min) (point))
                   6)))
        (if (< n 12)
            (newline n)
          ;; Some people get confused by the large gap.
          (newline (/ n 2))
          (insert "[Middle of page left blank for didactic purposes.  "
                  "Text continues below]")
          (newline (- n (/ n 2)))))
      (goto-char (point-min))
      (set-buffer-modified-p nil)))
  (remove-help-window)
  (message "Looking for Emacs Tutorial file...done"))


;; REPLACES ORIGINAL in `help.el':
;; Return nil if KEY is undefined; else return t.
;;
;;;###autoload
(defun describe-key (key)
  "Describe the command that a keyboard/menu/mouse sequence invokes.
Argument KEY is a string.
Return nil if KEY is undefined; else return t."
  (interactive "kDescribe command bound to keyboard/menu/mouse sequence: ")
  (save-excursion
    (let ((modifiers  (event-modifiers (aref key 0)))
          window position)
      ;; For a mouse button event, go to the button it applies to
      ;; to get the right key bindings.  And go to the right place
      ;; in case the keymap depends on where you clicked.
      (if (or (memq 'click modifiers) (memq 'down modifiers)
              (memq 'drag modifiers))
          (setq window    (posn-window (event-start (aref key 0)))
                position  (posn-point (event-start (aref key 0)))))
      (if (windowp window)
          (progn
            (set-buffer (window-buffer window))
            (goto-char position)))
      (let ((defn  (key-binding key)))
        (cond ((or (null defn) (integerp defn))
               (message "`%s' is undefined." (if (fboundp 'naked-key-description)
                                                 (naked-key-description key)
                                               (key-description key)))
               nil)                     ; Return nil: undefined.
              (t
               (with-output-to-temp-buffer "*Help*"
                 (princ (if (fboundp 'naked-key-description)
                            (naked-key-description key)
                          (key-description key)))
                 (if (windowp window)
                     (princ " at that spot"))
                 (princ " runs the command ")
                 (prin1 defn)
                 (princ "\n   which is ")
                 (describe-function-1 defn nil (interactive-p))
                 (print-help-return-message))
               t))))))                  ; Return t: defined.


;; REPLACES ORIGINAL in `help.el':
;; 1. Uses other window.
;; 2. Calls `remove-help-window'.
;; 3. Messages.
;;
;;;###autoload
(defun describe-project ()
  "Display information on the GNU project."
  (interactive)
  (message "Looking for file describing GNU project...")
  (find-file-read-only-other-window (expand-file-name "GNU" data-directory))
  (remove-help-window)
  (message "Looking for file describing GNU project...done"))


;; REPLACES ORIGINAL in `help.el':
;; 1. Uses other window.
;; 2. Calls `remove-help-window'.
;; 3. Messages added.
;; 4. Turns off `auto-save-mode'.
;;
;;;###autoload
(defun view-emacs-news (&optional arg)
  "Display information on recent changes to Emacs.
With numeric prefix ARG, display correspondingly older changes."
  (interactive "P")
  (message "Looking for Emacs Changes file...")
  (let ((arg  (if arg (prefix-numeric-value arg) 0)))
    (find-file-read-only-other-window
     (expand-file-name (concat (make-string arg ?O) "NEWS")
                       data-directory)))
  (auto-save-mode nil)                  ; Turn it off.
  (remove-help-window)
  (message "Looking for Emacs Changes file...done"))


;; REPLACES ORIGINAL in `help.el':
;; 1. Uses other window.
;; 2. Calls `remove-help-window'.
;; 3. Turns off `auto-save-mode'.
;;
;;;###autoload
(defun view-emacs-FAQ ()
  "Display Frequently Asked Questions about Emacs (with answers)."
  (interactive)
  (message "Looking for Emacs FAQ file...")
  (find-file-read-only-other-window (expand-file-name "FAQ" data-directory))
  (auto-save-mode nil)                  ; Turn it off.
  (remove-help-window)
  (message "Looking for Emacs FAQ file...done"))


;; REPLACES ORIGINAL in `help.el':
;; Updated key bindings.
;;
(make-help-screen help-for-help
  "RET [abcCfFhiIklLmnopqstuvw] C-[\acdfiklnopsw] M-[acko] C-M-a (? for more help):"
  "This is the Emacs `help-command', accessible via `%THIS-KEY%'.
Type a Help option (below) now, for help on a particular topic.
Use \\<help-map>`\\[scroll-up]' or `\\[scroll-down]' to scroll this text.  \
Type `\\[help-quit]' to exit Help.
\(A \"command\" is any function that you can execute via `M-x'.)

LEARNING EMACS
--------------
\\[help-with-tutorial]:   Starts a tutorial for learning Emacs.
\\[view-emacs-FAQ]:   Explains frequently asked Emacs questions.

COMMONLY USED
-------------
\\[help-on-click/key]: Help about a key sequence or something you click with the mouse.
\\[apropos-command]:   Shows commands that match a regular expression (regexp).
\\[describe-bindings]:   Shows current key bindings: keyboard, menu bar, and mouse.
\\[describe-command]:   Shows the doc for an Emacs command.
\\[describe-function]:   Shows the doc for an Emacs function.
\\[info]:   Enters `Info', to browse manuals, including Emacs and Emacs Lisp.
\\[describe-key]:   Describes the command bound to keyboard/menu/mouse sequence.
\\[describe-mode]:   Describes the current major and minor modes.
\\[describe-option]:   Shows an Emacs user option's value and documentation.
\\[describe-variable]:   Shows an Emacs variable's value and documentation.
\\[Info-goto-emacs-command-node]: Opens the Emacs manual for an Emacs command.
\\[Info-goto-emacs-key-command-node]: Opens the Emacs manual for a keyboard/menu/mouse \
sequence.

MORE ADVANCED HELP
------------------
\\[view-lossage]:   Shows what you just typed (last 100 keystrokes & mouse actions).
\\[view-emacs-news]:   Describes what's new in this Emacs release.
\\[finder-by-keyword]:   Finds Emacs-Lisp libraries that match a topic.
\\[describe-syntax]:   Describes the current syntax table.
\\[manual-entry]:   Finds a topic in the Unix manual.
\\[where-is]:   Identifies a keyboard/menu/mouse sequence that invokes a command.
\\[apropos]: Shows Emacs functions and variables that match a regexp.
\\[describe-key-briefly]: Identifies the command bound to a keyboard/menu/mouse sequence.
\\[describe-distribution]: Shows Emacs ordering information.
\\[locate-library]: Shows the path name to an Emacs library.
\\[view-emacs-lisp-news]: Describes latest Emacs Lisp changes.
\\[describe-project]: Shows information about the GNU project.
\\[save-*Help*-buffer]: Renames buffer *Help* as buffer *Help*<N>.
\\[describe-no-warranty]: Shows information about the absence of a warranty.
\\[apropos-documentation]: Shows Emacs functions and variables whose doc matches a regexp.
\\[describe-copying]: Shows the GNU Emacs General Public License.
\\[pop-to-help-toggle]: Pops to Help buffer or back to the buffer that sent you to Help.
\\[tags-apropos]: Shows the tags matched by a given string.

INTERNATIONAL
-------------
\\[describe-coding-system]:   Describes a coding system.
h    Displays the HELLO file, which illustrates scripts and languages.
\\[describe-input-method]:   Describes an input method.
\\[describe-language-environment]:   Describes a language environment.
\\[info-lookup-symbol]: Finds a symbol in the manual for the current buffer's language.
"
  help-map)


(or (fboundp 'old-describe-mode)
    (fset 'old-describe-mode (symbol-function 'describe-mode)))


;; REPLACES ORIGINAL in `help.el':
;; 1. Provides message telling how to change pages in *Help* buffer.
;; 2. Doc string also explains this.
;;    Really, the text at the beginning of *Help* should explain this - TO BE DONE.
;;
;;;###autoload
(defun describe-mode ()
  "Display documentation of current major mode and minor modes.
Each mode (minor or major) is displayed on a different \"page\" in the
*Help* buffer (the pages are separated by `^L' characters).
You can change pages with `\\[forward-page]' and `\\[backward-page]'.

Note: For a minor mode to be described correctly here, the mode's
indicator variable (listed in `minor-mode-alist') must also be a
function whose documentation describes the minor mode."
  (interactive)
  (let ((font-lock-verbose  nil))       ; This should inhibit msgs, but doesn't!
    (old-describe-mode)
    (message (substitute-command-keys
              "You can use `\\[forward-page]' and `\\[backward-page]' \
in *Help* buffer to change pages."))))


;; REPLACES ORIGINAL in `help.el':
;; Preferred candidate is `symbol-nearest-point'.
;; With a prefix argument, candidates are commands only.
;;
;;;###autoload
(defun describe-function (function &optional commandp)
  "Display the full documentation of FUNCTION (a symbol).
FUNCTION names an Emacs Lisp function, possibly a user command.
With a prefix argument, candidates are commands (interactive) only.
Default candidate is: preferably the `symbol-nearest-point', or else
the innermost function call surrounding point
\(`function-called-at-point').
Return the description that was displayed, as a string."
  (interactive
   (let ((fn                            (or (and (fboundp 'symbol-nearest-point)
                                                 (symbol-nearest-point))
                                            (function-called-at-point)))
         (enable-recursive-minibuffers  t))
     (list (intern (completing-read
                    (if current-prefix-arg "Describe command: " "Describe function: ")
                    obarray (if current-prefix-arg 'commandp 'fboundp) t nil nil
                    (and fn (symbol-name fn)) t))
           current-prefix-arg)))
  (unless (or (not commandp) (commandp function))
    (error "Not a defined Emacs command (interactive function): `%s'" function))
  (unless (fboundp function)
    (error "Not a defined Emacs function: `%s'" function))
  (with-output-to-temp-buffer "*Help*"
    (prin1 function)
    ;; Use " is " instead of a colon so that
    ;; it is easier to get out the function name using forward-sexp.
    (princ " is ")
    (describe-function-1 function nil (interactive-p))
    (print-help-return-message)
    (save-excursion
      (set-buffer standard-output)
      ;; Return the text we displayed.
      (buffer-string))))


;; REPLACES ORIGINAL in `help.el':
;;
;; Ignore symbols that produce errors.  Example: In Emacs 20, `any', which is defalias'd
;; to `icicle-anything', raises this error: "Symbol's function definition is void: any".
;; This is caused by the `after' advice `ad-advised-docstring' that is defined by Emacs
;; itself for function `documentation'.  It is not a problem for Emacs 22+.
;;
;;;###autoload
(defun describe-function-1 (function parens interactive-p)
  (let* ((def (if (symbolp function)
          (symbol-function function)
        function))
     file-name string need-close
     (beg (if (commandp def) "an interactive " "a ")))
    (setq string
      (cond ((or (stringp def)
             (vectorp def))
         "a keyboard macro")
        ((subrp def)
         (concat beg "built-in function"))
        ((byte-code-function-p def)
         (concat beg "compiled Lisp function"))
        ((symbolp def)
         (while (symbolp (symbol-function def))
           (setq def (symbol-function def)))
         (format "an alias for `%s'" def))
        ((eq (car-safe def) 'lambda)
         (concat beg "Lisp function"))
        ((eq (car-safe def) 'macro)
         "a Lisp macro")
        ((eq (car-safe def) 'mocklisp)
         "a mocklisp function")
        ((eq (car-safe def) 'autoload)
         (setq file-name (nth 1 def))
         (format "%s autoloaded %s"
             (if (commandp def) "an interactive" "an")
             (if (eq (nth 4 def) 'keymap) "keymap"
               (if (nth 4 def) "Lisp macro" "Lisp function"))
             ))
        (t "")))
    (when (and parens (not (equal string "")))
      (setq need-close t)
      (princ "("))
    (princ string)
    (with-current-buffer "*Help*"
      (save-excursion
    (save-match-data
      (if (re-search-backward "alias for `\\([^`']+\\)'" nil t)
          (help-xref-button 1 #'describe-function def)))))
    (or file-name
    (setq file-name (symbol-file function)))
    (if file-name
    (progn
      (princ " in `")
      ;; We used to add .el to the file name,
      ;; but that's completely wrong when the user used load-file.
      (princ file-name)
      (princ "'")
      ;; Make a hyperlink to the library.
      (with-current-buffer "*Help*"
        (save-excursion
          (re-search-backward "`\\([^`']+\\)'" nil t)
          (help-xref-button 1 #'(lambda (arg)
                      (let ((location
                         (find-function-noselect arg)))
                    (pop-to-buffer (car location))
                    (goto-char (cdr location))))
                function)))))
    (if need-close (princ ")"))
    (princ ".")
    (terpri)
    ;; Handle symbols aliased to other symbols.
    (setq def (indirect-function def))
    ;; If definition is a macro, find the function inside it.
    (if (eq (car-safe def) 'macro)
    (setq def (cdr def)))
    (let ((arglist (cond ((byte-code-function-p def)
              (car (append def nil)))
             ((eq (car-safe def) 'lambda)
              (nth 1 def))
             (t t))))
      (if (listp arglist)
      (progn
        (princ (cons (if (symbolp function) function "anonymous")
             (mapcar (lambda (arg)
                   (if (memq arg '(&optional &rest))
                       arg
                     (intern (upcase (symbol-name arg)))))
                 arglist)))
        (terpri))))
    (let ((doc (condition-case nil (documentation function) (error nil))))
      (if doc
      (progn (terpri)
         (princ doc)
         (help-setup-xref (list #'describe-function function) interactive-p))
    (princ "not documented")))))

;;;###autoload
(defun describe-command (function)
  "Describe an Emacs command (interactive function).
Same as using a prefix arg with `describe-function'."
  (interactive
   (let ((fn                            (or (and (fboundp 'symbol-nearest-point)
                                                 (symbol-nearest-point))
                                            (function-called-at-point)))
         (enable-recursive-minibuffers  t))
     (list (intern (completing-read "Describe command: " obarray 'commandp
                                    t nil nil (and fn (symbol-name fn)) t)))))
  (describe-function function t))


;; REPLACES ORIGINAL in `help.el':
;;
;; 1. Preferred candidate is `symbol-nearest-point'.
;; 2. Use `substitute-command-keys' on doc string.
;; 3. Remove initial `*' from doc string (indicates it is a user variable).
;; 4. With a prefix argument, candidates are user variables (options) only.
;;
;;;###autoload
(defun describe-variable (variable &optional optionp)
  "Display the full documentation of VARIABLE (a symbol).
VARIABLE names an Emacs Lisp variable, possibly a user option.
With a prefix argument, candidates are user variables (options) only.
Default candidate is the `symbol-nearest-point'.
Return the documentation, as a string."
  (interactive
   (let ((symb                          (or (and (fboundp 'symbol-nearest-point)
                                                 (symbol-nearest-point))
                                            (and (symbolp (variable-at-point))
                                                 (variable-at-point))))
         (enable-recursive-minibuffers  t))
     (list (intern (completing-read "Describe variable: " obarray
                                    (if current-prefix-arg 'user-variable-p 'boundp)
                                    t nil nil (and symb (symbol-name symb)) t))
           current-prefix-arg)))
  (unless (or (not optionp) (or (user-variable-p variable) (custom-variable-p variable)))
    (error "Not a defined Emacs user option: `%s'" variable))
  (unless (boundp variable) (error "Not a defined Emacs variable: `%s'" variable))
  (let (valvoid)
    (with-output-to-temp-buffer "*Help*"
      (prin1 variable)
      (if (not (boundp variable))       ; This will never happen.
          (progn (princ " is void") (terpri) (setq valvoid  t))
        (princ "'s value is ")
        (terpri)
        (pp (symbol-value variable))
        (terpri))
      (when (local-variable-p variable)
        (princ (format "Local in buffer %s; " (buffer-name)))
        (if (not (default-boundp variable))
            (princ "globally void")
          (princ "global value is ")
          (terpri)
          (pp (default-value variable)))
        (terpri))
      (terpri)
      (save-current-buffer
        (set-buffer standard-output)
        (when (> (count-lines (point-min) (point-max)) 10)
          (goto-char (point-min))
          (if valvoid
              (forward-line 1)
            (forward-sexp 1)
            (delete-region (point) (line-end-position))
            (insert "'s value is shown below.\n\n")
            (save-excursion (insert "\n\nValue:")))))
      (princ "Documentation:")
      (terpri)
      (let ((doc  (documentation-property variable 'variable-documentation)))
        (if (or (null doc)  (string= "" doc))
            (princ "Not documented as a variable.")
          (when (and (> (length doc) 1)  (eq ?* (elt doc 0)))
            (setq doc  (substring doc 1))) ; Remove any user-variable prefix `*'.
          (princ (substitute-command-keys doc))))
      (help-setup-xref (list #'describe-variable variable) (interactive-p))
      ;; Make a link to customize if this variable can be customized.
      ;; Note, it is not reliable to test only for a custom-type property
      ;; because those are only present after the var's definition
      ;; has been loaded.
      (when (or (get variable 'custom-type) ; after defcustom
                (get variable 'custom-loads) ; from loaddefs.el
                (get variable 'standard-value)) ; from cus-start.el
        (let ((customize-label  "customize"))
          (terpri)
          (terpri)
          (princ (concat "You can " customize-label " this variable."))
          (with-current-buffer "*Help*"
            (save-excursion  (re-search-backward
                              (concat "\\(" customize-label "\\)") nil t)
                             (help-xref-button 1 #'(lambda (v)
                                                     (customize-variable v)) variable)))))
      ;; Make a hyperlink to the library if appropriate.  (Don't
      ;; change the format of the buffer's initial line in case
      ;; anything expects the current format.)
      (when (string< "20.5" emacs-version)
        (let ((file-name  (symbol-file variable)))
          (when file-name
            (princ "\n\nDefined in `")
            (princ file-name)
            (princ "'.")
            (with-current-buffer "*Help*"
              (save-excursion
                (re-search-backward "`\\([^`']+\\)'" nil t)
                (help-xref-button 1 (lambda (arg)
                                      (let ((location  (find-variable-noselect arg)))
                                        (pop-to-buffer (car location))
                                        (goto-char (cdr location))))
                                  variable))))))

      (print-help-return-message)
      (save-excursion (set-buffer standard-output)
                      (buffer-string))))) ; Return the text we displayed.

;;;###autoload
(defun describe-option (variable)
  "Describe an Emacs user variable (option).
Same as using a prefix arg with `describe-variable'."
  (interactive
   (let ((symb                          (or (and (fboundp 'symbol-nearest-point)
                                                 (symbol-nearest-point))
                                            (and (symbolp (variable-at-point))
                                                 (variable-at-point))))
         (enable-recursive-minibuffers  t))
     (list (intern (completing-read "Describe user option: " obarray
                                    ;; Emacs 20 `user-variable-p' does not include defcustoms.
                                    (lambda (c) (or (custom-variable-p c) (user-variable-p c)))
                                    t nil nil (and symb (symbol-name symb)) t)))))
  (describe-variable variable t))

;;;###autoload
(defun describe-option-of-type (type option)
  "Describe an Emacs user OPTION (variable) of a given `defcustom' TYPE.
A prefix argument determines the type-checking behavior:
 - None:         OPTION is defined with TYPE or a subtype of TYPE.
 - Plain `C-u':  OPTION is defined with TYPE or a subtype of TYPE,
                 or its current value is compatible with TYPE.
 - Negative:     OPTION is defined with TYPE (exact match).
 - Non-negative: OPTION is defined with TYPE (exact match),
                 or its current value is compatible with TYPE.

If TYPE is nil (default value) then *all* `defcustom' variables are
potential candidates.  That is different from using `describe-option',
because `describe-option' includes user-variable candidates not
defined with `defcustom' (with `*'-prefixed doc strings)."
  (interactive
   (let* ((symb      (or (and (fboundp 'symbol-nearest-point) (symbol-nearest-point))
                         (and (symbolp (variable-at-point)) (variable-at-point))))
          (typ       (car (condition-case err
                              (read-from-string
                               (let ((types  ()))
                                 (mapatoms
                                  (lambda (cand)
                                    (when (if (fboundp 'custom-variable-p) ; Not in Emacs 20.
                                              (custom-variable-p cand)
                                            (user-variable-p cand))
                                      (push (list
                                             (format "%s" (format "%S" (get cand 'custom-type))))
                                            types))))
                                 (completing-read "Describe option of type: "
                                                  (help-remove-duplicates types)
                                                  nil nil nil nil "nil")))
                            (end-of-file (error "No such custom type")))))
          (pref-arg  current-prefix-arg))
     (list typ (intern (completing-read
                        "Option: " obarray
                        (lambda (v)
                          (and (if (fboundp 'custom-variable-p) ; Not in vanilla Emacs 20.
                                   (custom-variable-p v)
                                 (user-variable-p v))
                               (or (not typ) ; Allow all vars if requested type = nil.
                                   (help-var-is-of-type-p
                                    v (list typ)
                                    (cond ((not pref-arg) 'inherit)
                                          ((consp pref-arg) 'inherit-or-value)
                                          ((wholenump (prefix-numeric-value pref-arg))
                                           'direct-or-value)
                                          (t 'direct))))))
                        t nil nil (and symb (symbol-name symb)) t)))))
  (describe-variable option t))

(defun help-var-is-of-type-p (variable types &optional mode)
  "Return non-nil if VARIABLE satisfies one of the custom types in TYPES.
TYPES is a list of `defcustom' type sexps or a list of regexp strings.
TYPES are matched, in order, against VARIABLE's type definition or
VARIABLE's current value, until one is satisfied or all are tried.

If TYPES is a list of regexps, then each is regexp-matched against
VARIABLE's custom type.

Otherwise, TYPES is a list of type sexps, each of which is a
definition acceptable for `defcustom' :type or the first symbol of
such a definition (e.g. `choice').  In this case, two kinds of type
comparison are possible:

1. VARIABLE's custom type, or its first symbol, is matched using
  `equal' against each type in TYPES.

2. VARIABLE's current value is checked against each type in TYPES to
   see if it satisfies one of them.  In this case, VARIABLE's own type
   is not used; VARIABLE might not even be typed - it could be a
   variable not defined using `defcustom'.

For any of the comparisons against VARIABLE's type, either that type
can be checked directly or its supertypes (inherited types) can also
be checked.

These different type-checking possibilities depend on the value of
argument MODE, as follows, and they determine the meaning of the
returned value:

`direct':   VARIABLE's type matches a member of list TYPES
`inherit':  VARIABLE's type matches or is a subtype of a TYPES member
`value':    VARIABLE is bound, and its value satisfies a type in TYPES
`inherit-or-value': `inherit' or `value', tested in that order
`direct-or-value':  `direct' or `value', tested in that order
anything else (default): `inherit'

VARIABLE's current value cannot satisfy a regexp type: it is
impossible to know which concrete types a value must match."
  (case mode
    ((nil inherit)     (help-var-inherits-type-p variable types))
    (inherit-or-value  (or (help-var-inherits-type-p variable types)
                           (help-var-val-satisfies-type-p variable types)))
    (value             (help-var-val-satisfies-type-p variable types))
    (direct            (help-var-matches-type-p variable types))
    (direct-or-value   (or (member (get variable 'custom-type) types)
                           (help-var-val-satisfies-type-p variable types)))
    (otherwise         (help-var-inherits-type-p variable types))))

(defun help-var-matches-type-p (variable types)
  "VARIABLE's type matches a member of TYPES."
  (catch 'help-type-matches
    (let ((var-type  (get variable 'custom-type)))
      (dolist (type  types)
        (when (if (stringp type)
                  (save-match-data (string-match type (format "%s" (format "%S" var-type))))
                (equal var-type type))
          (throw 'help-type-matches t))))
    nil))

(defun help-var-inherits-type-p (variable types)
  "VARIABLE's type matches or is a subtype of a member of list TYPES."
  (catch 'help-type-inherits
    (let ((var-type  (get variable 'custom-type)))
      (dolist (type  types)
        (while var-type
          (when (or (and (stringp type)
                         (save-match-data
                           (string-match type (format "%s" (format "%S" var-type)))))
                    (equal type var-type))
            (throw 'help-type-inherits t))
          (when (consp var-type) (setq var-type  (car var-type)))
          (when (or (and (stringp type)
                         (save-match-data
                           (string-match type (format "%s" (format "%S" var-type)))))
                    (equal type var-type))
            (throw 'help-type-inherits t))
          (setq var-type  (car (get var-type 'widget-type))))
        (setq var-type  (get variable 'custom-type))))
    nil))

(defun help-var-val-satisfies-type-p (variable types)
  "VARIABLE is bound, and its value satisfies a type in the list TYPES."
  (and (boundp variable)
       (let ((val  (symbol-value variable)))
         (and (widget-convert (get variable 'custom-type))
              (help-value-satisfies-type-p val types)))))

(defun help-value-satisfies-type-p (value types)
  "Return non-nil if VALUE satisfies a type in the list TYPES."
  (catch 'help-type-value-satisfies
    (dolist (type  types)
      (unless (stringp type)            ; Skip, for regexp type.
        (setq type  (widget-convert type))
        ;; Satisfies if either :match or :validate.
        (when (condition-case nil
                  (progn (when (and (widget-get type :match)
                                    (widget-apply type :match value))
                           (throw 'help-type-value-satisfies t))
                         (when (and (widget-get type :validate)
                                    (progn (widget-put type :value value)
                                           (not (widget-apply type :validate))))
                           (throw 'help-type-value-satisfies t)))
                (error nil))
          (throw 'help-type-value-satisfies t))))
    nil))

(defun help-custom-type (variable)
  "Returns the `defcustom' type of VARIABLE.
Returns nil if VARIABLE is not a user option.

Note: If the library that defines VARIABLE has not yet been loaded,
then `help-custom-type' loads it.  Be sure you want to do that
before you call this function."
  (and (custom-variable-p variable)
       (or (get variable 'custom-type) (progn (custom-load-symbol variable)
                                              (get variable 'custom-type)))))

;; Borrowed from `ps-print.el'
(defun help-remove-duplicates (list)
  "Copy of LIST with duplicate elements removed.  Tested with `equal'."
  (let ((tail  list)
        new)
    (while tail
      (unless (member (car tail) new) (push (car tail) new))
      (pop tail))
    (nreverse new)))

;;;###autoload
(defun describe-file (filename &optional internal-form-p no-error-p)
  "Describe the file named FILENAME.
If FILENAME is nil, describe current directory (`default-directory').
If FILENAME is the name of an autofile bookmark and you use library
`Bookmark+', then show also the bookmark information (tags etc.).  In
this case, a prefix arg shows the internal form of the bookmark.

In Lisp code:

Non-nil optional arg INTERNAL-FORM-P shows the internal form.
Non-nil optional arg NO-ERROR-P prints an error message but does not
 raise an error."
  (interactive "FDescribe file: \nP")
  (unless filename (setq filename default-directory))
  (help-setup-xref `(describe-file ,filename ,internal-form-p ,no-error-p) (interactive-p))
  (let ((attrs  (file-attributes filename))
        ;; Functions `bmkp-*' are defined in `bookmark+.el'.
        (bmk   (and (fboundp 'bmkp-get-autofile-bookmark)  (bmkp-get-autofile-bookmark filename))))
    (if (not attrs)
        (if no-error-p
            (message "Cannot open file `%s'" filename)
          (error "Cannot open file `%s'" filename))
      (let* ((type             (nth 0 attrs))
             (numlinks         (nth 1 attrs))
             (uid              (nth 2 attrs))
             (gid              (nth 3 attrs))
             (last-access      (nth 4 attrs))
             (last-mod         (nth 5 attrs))
             (last-status-chg  (nth 6 attrs))
             (size             (nth 7 attrs))
             (permissions      (nth 8 attrs))
             ;; Skip 9: t iff file's gid would change if file were deleted and recreated.
             (inode            (nth 10 attrs))
             (device           (nth 11 attrs))
             (help-text
              (concat
               (format "`%s'\n%s\n\n" filename (make-string (+ 2 (length filename)) ?-))
               (format "File Type:                       %s\n"
                       (cond ((eq t type) "Directory")
                             ((stringp type) (format "Symbolic link to `%s'" type))
                             (t "Normal file")))
               (format "Permissions:                %s\n" permissions)
               (and (not (eq t type)) (format "Size in bytes:              %g\n" size))
               (format-time-string
                "Time of last access:        %a %b %e %T %Y (%Z)\n" last-access)
               (format-time-string
                "Time of last modification:  %a %b %e %T %Y (%Z)\n" last-mod)
               (format-time-string
                "Time of last status change: %a %b %e %T %Y (%Z)\n" last-status-chg)
               (format "Number of links:            %d\n" numlinks)
               (format "User ID (UID):              %s\n" uid)
               (format "Group ID (GID):             %s\n" gid)
               (format "Inode:                      %S\n" inode)
               (format "Device number:              %s\n" device))))
        (with-output-to-temp-buffer "*Help*"
          (when bmk
            (if internal-form-p
                (let* ((bname     (bookmark-name-from-full-record bmk))
                       (bmk-defn  (format "Bookmark `%s'\n%s\n\n%s"
                                          bname   (make-string (+ 11 (length bname)) ?-)
                                          (pp-to-string bmk))))
                  (princ bmk-defn) (terpri) (terpri))
              (princ (bmkp-bookmark-description bmk 'NO-IMAGE)) (terpri) (terpri)))
          (princ help-text))
        help-text))))                   ; Return displayed text.

;;;###autoload
(defun describe-keymap (keymap)
  "Describe bindings in KEYMAP, a variable whose value is a keymap.
Completion is available for the keymap name."
  (interactive
   (list (intern
          (completing-read
           "Keymap: " obarray
           (lambda (m) (and (boundp m) (keymapp (symbol-value m))))
           t nil 'variable-name-history))))
  (unless (and (symbolp keymap) (boundp keymap) (keymapp (symbol-value keymap)))
    (error "`%S' is not a keymapp" keymap))
  (let ((name  (symbol-name keymap))
        (doc   (documentation-property keymap 'variable-documentation)))
    (help-setup-xref (list #'describe-keymap keymap) (interactive-p))
    (with-output-to-temp-buffer "*Help*"
      (princ name) (terpri)
      (princ (make-string (length name) ?-)) (terpri) (terpri)
      (when doc (princ doc) (terpri) (terpri))
      ;; Use `insert' instead of `princ', so control chars (e.g. \377) insert correctly.
      (with-current-buffer "*Help*"
        (insert (substitute-command-keys (concat "\\{" name "}")))))))


;; REPLACES ORIGINAL in `help.el':
;; 1. Preferred candidate is `symbol-nearest-point'.
;; 2. Must be a command, not just a function.
;; 3. Calls `remove-help-window'.
;;
;;;###autoload
(defun where-is (definition &optional insert)
  "Give keyboard/menu/mouse sequences that invoke specified command.
Argument DEFINITION is a command definition, usually a symbol with a
function definition.  Default candidate is: preferably the
`symbol-nearest-point', or else the innermost function call
surrounding point (`function-called-at-point').
Non-nil prefix arg INSERT means insert the message in the buffer."
  (interactive
   (let ((fn                            (or (and (fboundp 'symbol-nearest-point)
                                                 (symbol-nearest-point))
                                            (function-called-at-point)))
         (enable-recursive-minibuffers  t))
     (list (intern (completing-read "Where is command: " obarray 'commandp t
                                    nil nil (and fn (symbol-name fn)) t)))))
  (remove-help-window)
  (let* ((keys             (where-is-internal definition overriding-local-map nil nil))
         (keys1            (mapconcat (if (fboundp 'naked-key-description)
                                          #'naked-key-description
                                        #'key-description)
                                      keys ", "))
         (standard-output  (if insert (current-buffer) t)))
    (if insert
        (if (> (length keys1) 0)
            (princ (format "%s (%s)" keys1 definition))
          (princ (format "M-x %s RET" definition)))
      (if (> (length keys1) 0)
          (princ (format "`%s' is on `%s'" definition keys1))
        (princ (format "`%s' is not on any key" definition)))))
  nil)


;; REPLACES ORIGINAL in `help.el':
;; Lets you complete the library name against string variables.
;; Calls `remove-help-window'.
;;
;;;###autoload
(defun locate-library (library &optional nosuffix path interactive-call)
  "Show the full path name of Emacs library LIBRARY.
This command searches the directories in your `load-path' like
`M-x load-library' to find the file that would be loaded by
`M-x load-library RET LIBRARY RET'.

Optional second arg NOSUFFIX non-nil means don't add suffixes `.elc'
or `.el' to the specified name LIBRARY (like calling `load' instead of
`load-library').

If the optional third arg PATH is specified, that list of directories
is used instead of `load-path'.

When called from a program, the file name is normally returned as a
string.  When run interactively, the argument INTERACTIVE-CALL is t,
and the file name is displayed in the echo area."
  (interactive (list (if (fboundp 'icicle-read-string-completing)
                         (icicle-read-string-completing "Locate library: ")
                       (read-string "Locate library: "))
                     nil nil t))
  (let (result)
    (catch 'answer
      (mapcar
       (lambda (dir)
         (mapcar (lambda (suf)
                   (let ((try  (expand-file-name (concat library suf) dir)))
                     (when (and (file-readable-p try)
                                (null (file-directory-p try)))
                       (setq result  try)
                       (message "Library is file `%s'." try)
                       (throw 'answer try))))

                 (if nosuffix
                     '("")
                   '(".elc" ".el" "")
;;; load doesn't handle this yet.
;;;         (let ((basic  '(".elc" ".el" ""))
;;;               (compressed '(".Z" ".gz" "")))
;;;           ;; If autocompression mode is on,
;;;           ;; consider all combinations of library suffixes
;;;           ;; and compression suffixes.
;;;           (if (rassq 'jka-compr-handler file-name-handler-alist)
;;;               (apply 'nconc
;;;                      (mapcar (lambda (compelt)
;;;                                (mapcar (lambda (baselt)
;;;                                          (concat baselt compelt))
;;;                                        basic))
;;;                              compressed))
;;;             basic))
                   )))
       (or path load-path)))
    (and interactive-call
         (if result
             (message "Library is file `%s'" result)
           (message "No library `%s' in search path." library)))
    (remove-help-window)
    result))

;;;###autoload
(defun view-emacs-lisp-news ()
  "Display information on recent changes to Emacs Lisp."
  (interactive)
  (message "Looking for Emacs Lisp Changes file...")
  (find-file-read-only-other-window (expand-file-name "LNEWS" data-directory))
  (auto-save-mode nil)                  ; Turn it off.
  (remove-help-window)
  (message "Looking for Emacs Lisp Changes file...done"))

;;;###autoload
(defun save-*Help*-buffer ()
  "Rename *Help* buffer as new buffer *Help*<N>, N=2,3...."
  (interactive)
  (let ((notifying-user-of-mode  nil)    ; No msg on mode (in `misc-fns.el').
        (saved-help              (buffer-name (generate-new-buffer "*Help*"))))
    (save-excursion
      (set-buffer "*Help*")
      (copy-to-buffer saved-help (point-min) (point-max))
      (when (interactive-p)
        (message "Saved contents of *Help* buffer to buffer %s."
                 saved-help)))))

(defun help-on-click/key-lookup (key &optional pp-key where)
  "Look up information on KEY via `describe-key' and `info'.
Optional args PP-KEY and WHERE are strings naming KEY and its type.
Their defaults are KEY's `key-description' and \"Key sequence\".
Function `Info-goto-emacs-key-command-node' is used to look up KEY."
  (sit-for 0 200);; HACK to fix bug if click on scroll bar in `help-on-click/key'.
  (setq where   (or where "Key sequence ")
        pp-key  (or pp-key (if (fboundp 'naked-key-description)
                               (naked-key-description key)
                             (key-description key))))
  (let* ((described-p  (if (fboundp 'naked-key-description)
                           (naked-key-description key)
                         (key-description key)))
         ;; The version of `Info-goto-emacs-key-command-node' defined in `info+20.el' returns
         ;; non-nil if Info doc is found.  The standard version defined `info.el' will not.
         (documented-p (Info-goto-emacs-key-command-node key))) ; nil if have only std version
    (when (and (not documented-p)(get-buffer-window "*info*" 'visible)) (Info-exit))
    (cond ((and described-p documented-p)
           (when (fboundp 'show-*Help*-buffer) (show-*Help*-buffer))
           (message "%s`%s': summary in *Help* buffer; doc in *info* buffer."
                    where pp-key))
          (described-p
           (when (fboundp 'show-*Help*-buffer) (show-*Help*-buffer))
           (message "%s`%s': summary in *Help* buffer." where pp-key))
          (documented-p
           (message "%s`%s': doc in *info* buffer." where pp-key))
          (t
           (message "%s`%s' is undefined." where pp-key)))))

;;;###autoload
(defun help-on-click/key (key)
  "Give help on a key/menu sequence or object clicked with the mouse.
The object can be any part of an Emacs window or a name appearing in a
buffer.  You can do any of the following:

    type a key sequence (e.g. `C-M-s')
    choose a menu item (e.g. [menu-bar files open-file])
    click on a scroll bar
    click on the mode line
    click in the minibuffer
    click on an Emacs-related name in a buffer: apropos is called
    click anywhere else in a buffer: its modes are described

Help is generally provided using `describe-key' and the Emacs online
manual (via `Info-goto-emacs-key-command-node').  If no entry is found
in the index of the Emacs manual, then the manual is searched from the
beginning for literal occurrences of KEY.

For example, the KEY `C-g' is not in the index (for some reason), so
the manual is searched.  (Once an occurrence is found, you can
repeatedly type `s' in *Info* to search for additional occurrences.)

If you click on a name in a buffer, then `apropos-documentation' and
`apropos' are used to find information on the name.  These functions
are not used when you do something besides click on a name.

If you click elsewhere in a buffer other than the minibuffer, then
`describe-mode' is used to describe the buffer's current mode(s)."
  (interactive "kClick mouse on something or type a key sequence.")
  (let ((temp-buffer-show-function  'switch-to-buffer-other-window)
        (font-lock-verbose          nil)
        (global-font-lock-mode      nil))
    ;; DEBUG (message "KEY: `%s'" key)(sit-for 4) ; DEBUG
    (cond ((stringp key)
           (help-on-click/key-lookup key))
          (t                            ; Vector.
           (let ((type  (aref key 0)))
             (cond ((or (symbolp type)(integerp type))
                    (cond ((eq 'mode-line type) ; Click on the mode line.
                           (Info-goto-node "(emacs)Mode Line")
                           (message "Mode line: decribed in *info* buffer."))
                          (t            ; Normal key sequence.
                           (help-on-click/key-lookup key))))
                   ((eq 'menu-bar (car type))

                    (help-on-click/key-lookup key (aref key (1- (length key))) "Menu item "))
                   ((not (eq 'down (car (event-modifiers (car type))))) ; e.g. mouse menus
                    (help-on-click/key-lookup key))
                   (t                   ; Mouse click.
                    (setq key  type)
                    (cond ((window-minibuffer-p ; Click in minibuffer.
                            (posn-window (event-start key)))
                           (Info-goto-node "(emacs)Minibuffer")
                           (message "Minibuffer: decribed in *info* buffer."))
                          (t
                           (let ((symb            (save-excursion
                                                    (mouse-set-point key)
                                                    (if (fboundp 'tap-symbol-at-point)
                                                        (tap-symbol-at-point)
                                                      (symbol-at-point))))
                                 (apropos-do-all  t)
                                 (found-doc       nil)
                                 (found           nil)
                                 (symb-regexp     nil))
                             (cond (symb
                                    (message "Looking for info apropos `%s'..." symb)
                                    (when (get-buffer "*Apropos Doc*")
                                      (kill-buffer (get-buffer "*Apropos Doc*")))
                                    (setq found-doc  (apropos-documentation
                                                      (setq symb-regexp
                                                            (regexp-quote
                                                             (setq symb  (format "%s" symb))))))
                                    (when found-doc
                                      (save-excursion
                                        (set-buffer (get-buffer "*Apropos*"))
                                        (rename-buffer "*Apropos Doc*"))
                                      (when (fboundp '1-window-frames-on) ; In `frame-fns.el'.
                                        (let ((frames  (1-window-frames-on "*Apropos Doc*")))
                                          (while frames
                                            (save-window-excursion
                                              (select-frame (car frames))
                                              (rename-frame nil "*Apropos Doc*")
                                              (pop frames))))))
                                    (setq found  (apropos symb-regexp))
                                    ;; Remove empty stuff.
                                    (setq found  (and (consp found) (or (cdr found) (cadr found))))
                                    ;; Remove *Apropos* window that was displayed needlessly.
                                    (unless found (delete-windows-on "*Apropos*"))
                                    (cond
                                      ((and found-doc found)
                                       (message
                                        "See *Apropos* and *Apropos Doc* buffers."))
                                      (found
                                       (message
                                        "See information on `%s' in the *Apropos* buffer."
                                        symb))
                                      (found-doc
                                       (message
                                        "See information on `%s' in the *Apropos Doc* buffer."
                                        symb))
                                      (t
                                       (message
                                        "No information found regarding `%s'."
                                        symb))))
                                   (t   ; User clicked in buffer, but not on a symbol.
                                    (let ((bufname  (buffer-name (current-buffer))))
                                      (describe-mode)
                                      (when (fboundp 'show-*Help*-buffer) (show-*Help*-buffer))
                                      (message
                                       "Mode(s) of buffer `%s' are described in *Help* buffer."
                                       bufname))))))))))))))

;;;###autoload
(defun mouse-help-on-click (event)
  "Give help on an object clicked with the mouse."
  (interactive "e")
  (help-on-click/key (vector event)))

;;;###autoload
(defun mouse-help-on-mode-line-click (event)
  "Give help on the mode line."
  (interactive "e")
  (help-on-click/key (vector 'mode-line event)))

;;;###autoload
(defun pop-to-help-toggle ()
  "Pop to buffer *Help* or back to the buffer that sent you to *Help*."
  (interactive)
  (let ((orig-buf                   (and (buffer-live-p help-origin-buffer)
                                         (get-buffer help-origin-buffer)))
        (w32-grab-focus-on-raise    t)
        (win32-grab-focus-on-raise  t)) ; Older name.
    (if (string-match "*Help*" (buffer-name))
        (cond ((not orig-buf)
               (error "No buffer to return to"))
              ((string-match "Minibuf" (buffer-name orig-buf)) ; No `minibufferp' in Emacs 20.
               (select-frame-set-input-focus
                (window-frame (select-window (minibuffer-window)))))
              (t
               (pop-to-buffer orig-buf)))
      (setq help-origin-buffer  (current-buffer))
      (pop-to-buffer "*Help*"))))

;;;;;;;;;;;;;;;;;;;;;;;

(provide 'help+20)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; help+20.el ends here
#+end_src

*** escreen.el

#+call: hash("")

#+RESULTS:
: 3457efc690700fd2400f9b5425d30336

#+name: 3457efc690700fd2400f9b5425d30336
#+begin_src emacs-lisp :tangle (jr/tangle-path) :comments link
;;; escreen.el --- emacs window session manager

;; Author: Noah Friedman <friedman@splode.com>
;; Created: 1992-03-23
;; Public domain

;;; $Id: escreen.el,v 1.20 2017/06/05 18:13:00 friedman Exp $

;;; Commentary:

;; To install, put this file in your load-path, byte-compile it, and add
;; the following to your .emacs:
;;
;;   (load "escreen")
;;   (escreen-install)

;; Inspired by:
;;   * wicos.el, written by Heikki Suopanki <suopanki@phoenix.oulu.fi>
;;   * `screen', written by Oliver Laumann, Juergen Weigert,
;;     and Michael Schroeder.

;; Todo:
;;   * make escreen-menu display list of screens for all frames
;;   * ability to lock window configurations against change or deletion
;;   * ability to renumber screens
;;   * symbolic names for screens (a la wicos.el); partly started
;;   * switching active screen from pull-down menu from menubar
;;   * switching active screen from escreen menu
;;   * persistance of screens across instances of emacs
;;     [look at johnw's work on this; depends on additional non-standard
;;     packages but perhaps those parts can be reimplemented inline.]

;;; Code:

;; Variable declarations -- can be set by user

(defgroup escreen nil
  "Window configuration management"
  :group 'escreen
  :group 'extensions)

(defcustom escreen-max-screens 10
  "*Maximum number of screens that may be created."
  :type 'integer
  :group 'escreen)

(defcustom escreen-new-screen-default-buffer "*scratch*"
  "*Default buffer to display in newly-created screens."
  :type 'string
  :group 'escreen)

(defcustom escreen-restore-killed-buffers nil
  "*If non-nil, automatically revisit files if they have been killed.
That is, if a buffer was killed while in another screen session,
recreate them, visiting whatever file they were visiting."
  :type 'boolean
  :group 'escreen)

(defcustom escreen-preserve-buffer-list-order t
  "*If non-nil, preserve buffer list for each screen when switching.
When returning to a previously-saved screen, the buffer list order is
restored.  Buffers which have been created since the saved screen was last
visited, are put at the end of the list but the relative order is preserved.

This buffer list order is returned by the function `buffer-list' and
affects the behavior of `other-buffer', etc.

In Emacs 20 and later, each frame has its own ordered buffer list.
Switching screen sessions affects the selected frame's buffer list only."
  :type 'boolean
  :group 'escreen)

(defcustom escreen-number-mode t
  "*If non-nil, display current escreen number in mode line."
  :type 'boolean
  :group 'escreen)

(defcustom escreen-install-number-mode-format t
  "*If non-nil, install `escreen-mode-line-format' on `global-mode-string'.
This is performed by `escreen-install'."
  :type 'boolean
  :group 'escreen)

(defcustom escreen-goto-screen-before-hook nil
  "*Hook to run in `escreen-goto-screen' before anything else."
  :type 'hook
  :group 'escreen)

(defcustom escreen-goto-screen-hook nil
  "*Hook to run after `escreen-goto-screen' completes.
An example function that can make use of this hook is
`escreen-enable-number-mode-if-more-than-one-screen'."
  :type 'hook
  :group 'escreen)

(defcustom escreen-menu-mode-hook nil
  "*Hook to run by `escreen-menu' after everything else."
  :type 'hook
  :group 'escreen)


;; Keybindings

(defcustom escreen-prefix-char "\C-\\"
  "*Character prefixing escreen commands.
If you wish to change this, you must also do

   (global-set-key escreen-prefix-char 'escreen-prefix)

to update the prefix in the global keymap."
  :type 'string
  :group 'escreen)

(defvar escreen-map nil
  "*Keymap for escreen commands.")
(cond
 ((null escreen-map)
  (setq escreen-map (make-sparse-keymap))
  (define-key escreen-map escreen-prefix-char 'escreen-goto-last-screen)
  (define-key escreen-map "0"    'escreen-goto-screen-0)
  (define-key escreen-map "1"    'escreen-goto-screen-1)
  (define-key escreen-map "2"    'escreen-goto-screen-2)
  (define-key escreen-map "3"    'escreen-goto-screen-3)
  (define-key escreen-map "4"    'escreen-goto-screen-4)
  (define-key escreen-map "5"    'escreen-goto-screen-5)
  (define-key escreen-map "6"    'escreen-goto-screen-6)
  (define-key escreen-map "7"    'escreen-goto-screen-7)
  (define-key escreen-map "8"    'escreen-goto-screen-8)
  (define-key escreen-map "9"    'escreen-goto-screen-9)
  (define-key escreen-map "?"    'escreen-help)
  (define-key escreen-map "\C-b" 'escreen-menu)
  (define-key escreen-map "a"    'escreen-get-active-screen-numbers)
  (define-key escreen-map "b"    'escreen-get-current-screen-number)
  (define-key escreen-map "c"    'escreen-create-screen)
  (define-key escreen-map "g"    'escreen-goto-screen)
  (define-key escreen-map "k"    'escreen-kill-screen)
  (define-key escreen-map "n"    'escreen-goto-next-screen)
  (define-key escreen-map "p"    'escreen-goto-prev-screen)))

(defalias 'escreen-prefix escreen-map)


;;; Internal variables.  Do not set these yourself.

;; This should not be modified by the user.  The information it provides is
;; critical and the calling conventions are different than for
;; escreen-map-data-format.  The order here is important too.
;; Do not change this data structure without also changing the
;; escreen-configuration-data-map-critical-* accessors.
(defvar escreen-map-critical-data-format
  (list 'current-buffer
        (lambda () (buffer-name))
        'buffer-file-name))

;; If you want to add or change this list, it's best to set
;; escreen-configuration-alist to nil and run escreen-install afterward.
;; Otherwise, the new table will be used with old data and may cause errors.
;;
;; Note that resetting escreen in this way loses all but the current
;; window configuration.
(defvar escreen-map-data-format
  '((escreen-map-save-window-start    . escreen-map-restore-window-start)
    (mark-marker                      . escreen-map-restore-mark-marker)
    (escreen-map-save-point           . escreen-map-restore-point)
    (escreen-map-save-narrowed-region . escreen-map-restore-narrowed-region)
    (escreen-map-save-truncate-lines  . escreen-map-restore-truncate-lines)
    (escreen-map-save-mode-line-face  . escreen-map-restore-mode-line-face)
    (escreen-map-save-menu-bar-mode   . escreen-map-restore-menu-bar-mode)
    (buffer-list                      . escreen-map-restore-buffer-list)))

;; It's ok to change this, but it makes use of internal variables
(defconst escreen-mode-line-format
  '(:eval (if (escreen-one-screen-p)
              ""
            (format "S%d " (escreen-current-screen-number)))))
;; This property required or redisplay won't evaluate this variable.
(put 'escreen-mode-line-format 'risky-local-variable t)

(eval-and-compile


;; Starting with Emacs 22, frame-local variables are deprecated and their
;; functionality has been progressively reduced with every major release.
;; As of Emacs 26, they are gone completely.  You can still create new
;; elements in the frame's parameter list, but you have to modify and
;; retrieve them explicitly using normal lisp calls.
;;
;; It's still useful to keep frame-specific values in the parameter alist
;; rather than maintaining a separate alist because this way they will
;; automatically be garbage collected when a frame is deleted.

;; Frame-specific parameters:
;;
;; * escreen-configuration-alist
;;   Keeps track of escreen state (window config, buffers, etc.)
;;   The structure of each elt is
;;
;;    (screen-number screen-name
;;                   #<window-configuration>
;;                   (((critical-data-buffer-1) user-data-buffer-1 ...)
;;                    ((critical-data-buffer-2) user-data-buffer-2 ...)
;;                    ...)
;;                   selected-window-number)
;;
;; * escreen-current-screen-number
;;   Current screen number on this frame.
;;   Smallest possible screen number is 0.
;;
;; * escreen-last-screen-number
;;   Last-visited screen number.
;;
;; * escreen-highest-screen-number-used
;;   Highest screen number currently in use on this frame.
;;
;; * escreen-one-screen-p
;;   `t' or nil depending on if there is more than one screen on this frame.
;;   This defaults to t since initially there is only one screen on a frame.
(defconst escreen-frame-default-values
  '((escreen-configuration-alist        . nil)
    (escreen-current-screen-number      . 0)
    (escreen-last-screen-number         . 0)
    (escreen-highest-screen-number-used . 0)
    (escreen-one-screen-p               . t)))

(defsubst escreen-get (var &optional frame)
  (let ((elt (assq var (frame-parameters frame))))
    (if elt
        (cdr elt)
      (cdr (assq var escreen-frame-default-values)))))

(defsubst escreen-set (var value &optional frame)
  (modify-frame-parameters frame (list (cons var value))))

;; Define getters and setters for each symbol that looks up or modifies
;; their frame-specific value.
(defmacro escreen-make-frame-specific-accessors (syms)
  (let ((fns nil)
        g s)
    (mapc (lambda (sym)
            (setq g `(defalias ',sym (lambda (&optional frame) (escreen-get ',sym frame)))
                  s `(defalias ',(intern (format "set-%s" sym))
                       (lambda (val &optional frame) (escreen-set ',sym val frame)))
                  fns (cons g (cons s fns))))
      (eval syms))
    (cons 'progn fns)))

(escreen-make-frame-specific-accessors (mapcar 'car escreen-frame-default-values))

) ;;eval-and-compile


(defmacro escreen-save-current-frame (&rest body)
  "Execute BODY, saving and restoring the selected frame."
  (declare (indent 0))
  (let ((orig-frame (make-symbol "orig-frame")))
    `(let ((,orig-frame (selected-frame)))
       (unwind-protect
           (progn ,@body)
         (when (frame-live-p ,orig-frame)
           (select-frame ,orig-frame))))))

;; Older versions of Emacs did not have window-pixel-edges
;; Older versions of XEmacs did not have window-edges
(defalias 'escreen-window-edges
  (if (fboundp 'window-edges) 'window-edges 'window-pixel-edges))


(defun escreen-install ()
  (interactive)
  (global-set-key escreen-prefix-char 'escreen-prefix)

  ;; Install screen number on global-mode-string
  (and escreen-install-number-mode-format
       (let ((elt '("" escreen-mode-line-format)))
         (or (member elt global-mode-string)
             (setq global-mode-string
                   (cons elt global-mode-string)))))

  (if escreen-number-mode
      (escreen-number-mode 1))

  (add-hook 'after-make-frame-functions 'escreen-initialize-frame-variables)
  (mapc 'escreen-initialize-frame-variables (frame-list)))

(defun escreen-number-mode (&optional prefix)
  "*Toggle escreen-number-mode (see variable docstring).
If called with a positive prefix argument, always enable.
If called with a negative prefix argument, always disable.
If called with no prefix argument, toggle current state."
  (interactive "P")
  (setq escreen-number-mode
        (cond ((null prefix)
               (not escreen-number-mode))
              (t
               (>= (prefix-numeric-value prefix) 0)))))


(defun escreen-create-screen ()
  "Create a new screen and switch to it.
New screen will display one window with the buffer specified by
`escreen-new-screen-default-buffer'."
  (interactive)
  (let ((new-screen-number (escreen-first-unused-screen-number)))
    (or new-screen-number
        (error "escreen: No more screens (see \"escreen-max-screens\")"))

    ;; Save window configuration before switching to a new one.
    (escreen-save-current-screen-configuration)
    (and (> new-screen-number (escreen-highest-screen-number-used))
         (set-escreen-highest-screen-number-used new-screen-number))
    (set-escreen-last-screen-number (escreen-current-screen-number))
    (set-escreen-current-screen-number new-screen-number)

    ;; Don't reuse any of the previous screen's window objects; settings
    ;; like window-dedicated-p, window display tables, etc. will just cause
    ;; grief.
    ;;
    ;; Modify the frame so there is only one window; this insures that we
    ;; have room to split to a second window.  Select new window, then
    ;; delete the previous one.  We now start the new screen with a totally
    ;; new window (the previous window is still saved in the window
    ;; configuration, so its settings are not lost).
    (delete-other-windows)
    (select-window (split-window))
    (delete-other-windows)

    ;; create a new window and switch to that, then delete the other window.
    ;; this is just
    (switch-to-buffer escreen-new-screen-default-buffer)
    ;; Save new window configuration so that it's in the alist.
    (escreen-save-current-screen-configuration))
  ;; We run this hook because, in a sense, we have gone to a new
  ;; screen. but we don't actually call escreen-goto-screen because of the
  ;; extra setup work here.
  (run-hooks 'escreen-goto-screen-hook))

(defun escreen-kill-screen (&optional number)
  "Kill current screen, or screen given by optional argument NUMBER.
No error occurs if the specified screen number doesn't exist.
You cannot kill the last existing screen.
Switch to previous screen if killing active one."
  (interactive)
  (let* ((screen-number (or number (escreen-current-screen-number)))
         (killing-current-screen-p (eq (escreen-current-screen-number)
                                       screen-number))
         (screen-data (escreen-configuration-escreen screen-number))
         previous-screen)
    (cond (screen-data
           (and killing-current-screen-p
                (escreen-configuration-one-screen-p)
                (error "escreen: only one screen, can't kill."))
           ;; Don't bother looking for previous screen number unless killing
           ;; current screen, because only then do we need to switch screens.
           (and killing-current-screen-p
                (setq previous-screen (escreen-get-prev-screen-number)))
           (escreen-configuration-escreen-delete screen-data)
           (and (eq screen-number (escreen-highest-screen-number-used))
                ;; We're killing the screen with the highest number.
                ;; Look for the next highest number.
                (set-escreen-highest-screen-number-used
                 (car (sort (escreen-configuration-screen-numbers) '>))))
           (and killing-current-screen-p
                (escreen-goto-screen previous-screen 'dont-update-current))))))

(defun escreen-initialize-frame-variables (&optional frame)
  (escreen-save-current-frame
    (select-frame frame)
    (set-escreen-configuration-alist nil)
    (escreen-save-current-screen-configuration)))


(defun escreen-goto-screen (number &optional dont-update-current)
  "Switch to screen number N.
Optional arg DONT-UPDATE-CURRENT means don't save the current screen
configuration, though this isn't intended to be used interactively."
  (interactive "NGo to escreen number: ")
  (run-hooks 'escreen-goto-screen-before-hook)
  (let ((screen-data (escreen-configuration-escreen number)))
    (or screen-data
        (error "escreen: %d: invalid screen number." number))
    (or dont-update-current
        (escreen-save-current-screen-configuration))
    (escreen-restore-screen-map screen-data)
    (or dont-update-current
        (set-escreen-last-screen-number (escreen-current-screen-number)))
    (set-escreen-current-screen-number number))
  (run-hooks 'escreen-goto-screen-hook))

(defun escreen-goto-last-screen ()
  "Switch to the last visited screen."
  (interactive)
  (let ((n (if (= (escreen-last-screen-number) (escreen-current-screen-number))
               (escreen-get-next-screen-number (escreen-last-screen-number))
             (escreen-last-screen-number))))
    (set-escreen-last-screen-number (escreen-current-screen-number))
    (escreen-goto-screen n)))

(defun escreen-goto-prev-screen (&optional n)
  "Switch to the previous screen.
This is the nearest lower-numbered existing screen from the current one,
wrapping around list of screens if necessary.
If prefix arg N given, jump to the Nth previous screen."
  (interactive "p")
  (if (< n 0)
      (escreen-goto-prev-or-next-screen-internal (- n) 'next)
    (escreen-goto-prev-or-next-screen-internal n 'prev)))

(defun escreen-goto-next-screen (&optional n)
  "Switch to the next screen.
This is the nearest greater-numbered existing screen from the current one,
wrapping around list of screens if necessary.
If prefix arg N given, jump to the Nth next screen."
  (interactive "p")
  (if (< n 0)
      (escreen-goto-prev-or-next-screen-internal (- n) 'prev)
    (escreen-goto-prev-or-next-screen-internal n 'next)))

(defun escreen-goto-prev-or-next-screen-internal (n prev-or-next)
  (let ((total (length (escreen-get-active-screen-numbers)))
        (func (if (eq prev-or-next 'next)
                  'escreen-get-next-screen-number
                'escreen-get-prev-screen-number))
        (i 0)
        (screen-number (escreen-current-screen-number)))
    (and (> n total)
         ;; Trim off excess amount so we do fewer iterations, since
         ;; wrapping over the total number of screens even once is
         ;; wasteful and slow.
         (setq n (- n (* (/ n total) total))))
    (while (< i n)
      (setq screen-number (funcall func screen-number)
            i (1+ i)))
    (escreen-goto-screen screen-number)))

(defun escreen-goto-screen-0 () (interactive) (escreen-goto-screen 0))
(defun escreen-goto-screen-1 () (interactive) (escreen-goto-screen 1))
(defun escreen-goto-screen-2 () (interactive) (escreen-goto-screen 2))
(defun escreen-goto-screen-3 () (interactive) (escreen-goto-screen 3))
(defun escreen-goto-screen-4 () (interactive) (escreen-goto-screen 4))
(defun escreen-goto-screen-5 () (interactive) (escreen-goto-screen 5))
(defun escreen-goto-screen-6 () (interactive) (escreen-goto-screen 6))
(defun escreen-goto-screen-7 () (interactive) (escreen-goto-screen 7))
(defun escreen-goto-screen-8 () (interactive) (escreen-goto-screen 8))
(defun escreen-goto-screen-9 () (interactive) (escreen-goto-screen 9))


(defun escreen-get-current-screen-number ()
  "Returns the currently selected screen number.
If called interactively, also print this result in the minibuffer."
  (interactive)
  (if (interactive-p)
      (message "escreen: current screen is number %d"
               (escreen-current-screen-number))
    (escreen-current-screen-number)))

(defun escreen-get-active-screen-numbers ()
  "Print a list of the active screen numbers in the echo area.
Returns a list of numbers which represent screen numbers presently in use."
  (interactive)
  (let ((screen-list (sort (escreen-configuration-screen-numbers) '<)))
    (if (interactive-p)
        (message "escreen: active screens: %s"
                 (mapconcat 'number-to-string screen-list " ")))
    screen-list))

(defun escreen-help ()
  "Display a short summary of escreen commands."
  (interactive)
  (if (string-lessp emacs-version "19")
      ;; emacs 18 couldn't list only bindings with a common prefix.
      (describe-bindings)
    ;; Emacs 19 can handle escreen-prefix-char (as a string) directly, but
    ;; for XEmacs, it must be converted to a vector.
    (describe-bindings (escreen-string-to-vector escreen-prefix-char))))

(defun escreen-string-to-vector (s)
  (let* ((l (length s))
         (v (make-vector l nil))
         (i 0))
    (while (< i l)
      (aset v i (aref s i))
      (setq i (1+ i)))
    v))


;; Return the first unused number available for designation as a screen
;; number, or nil if  escreen-max-screens  screens are already in use.
(defun escreen-first-unused-screen-number ()
  (let ((number 0))
    (while (and (< number escreen-max-screens)
                (escreen-configuration-escreen number))
      (setq number (1+ number)))
    (and (< number escreen-max-screens) number)))

;; Save window configuration, buffer configuration, and current marks and
;; point for each displayed buffer for the current screen.
(defun escreen-save-current-screen-configuration ()
  (let ((screen-data (escreen-screen-defined))
        (new-alist-member nil))
    (if screen-data
        (setcdr (cdr screen-data) (escreen-save-screen-map))
      (setq new-alist-member (cons (escreen-current-screen-number)
                                   (cons nil (escreen-save-screen-map))))
      (set-escreen-configuration-alist
       (cons new-alist-member (escreen-configuration-alist))))))

;; Return attributes for screen N, or nil if it doesn't exist.
(defun escreen-screen-defined (&optional n)
  (escreen-configuration-escreen (or n (escreen-current-screen-number))))

;; Return nearest number less than current screen number that is
;; an active screen, wrapping around end of screen list if necessary.
(defun escreen-get-prev-screen-number (&optional current-screen-number)
  (or current-screen-number
      (setq current-screen-number (escreen-current-screen-number)))
  (if (eq 0 (escreen-highest-screen-number-used))
      0
    ;; Decrement/wrap current screen number
    (setq current-screen-number (1- current-screen-number))
    (and (< current-screen-number 0)
         (setq current-screen-number (escreen-highest-screen-number-used)))
    (while (not (assq current-screen-number (escreen-configuration-alist)))
      ;; Decrement/wrap current screen number
      (setq current-screen-number (1- current-screen-number))
      (and (< current-screen-number 0)
           (setq current-screen-number (escreen-highest-screen-number-used))))
    current-screen-number))

;; Return nearest number greater than current screen number that is
;; an active screen, wrapping around end of screen list if necessary.
(defun escreen-get-next-screen-number (&optional current-screen-number)
  (or current-screen-number
      (setq current-screen-number (escreen-current-screen-number)))
  (let ((highest (escreen-highest-screen-number-used))
        (config-alist (escreen-configuration-alist)))
    (if (eq 0 highest)
        0
      ;; Increment/wrap current screen number
      (setq current-screen-number (1+ current-screen-number))
      (if (> current-screen-number highest)
          (setq current-screen-number 0))
      (while (not (assq current-screen-number config-alist))
        ;; Increment/wrap current screen number
        (setq current-screen-number (1+ current-screen-number))
        (if (> current-screen-number highest)
            (setq current-screen-number 0)))
      current-screen-number)))


;;; Primitive accessors for escreen-configuration-alist
;;;
;;; These could be made into macros or defsubsts, but it would make
;;; debugging more difficult and they are not critical for speed.

(defun escreen-configuration-escreen (number)
  (assq number (escreen-configuration-alist)))

(defun escreen-configuration-escreen-delete (data)
  (set-escreen-configuration-alist
   (delq (if (numberp data)
             (escreen-configuration-escreen data)
           data)
         (escreen-configuration-alist))))

(defun escreen-configuration-screen-numbers ()
  (mapcar 'car (escreen-configuration-alist)))

(defun escreen-configuration-one-screen-p ()
  (>= 1 (length (escreen-configuration-alist))))

;; Sort the alist so that they are in order numerically.
(defun escreen-configuration-alist-sort-by-number ()
  (set-escreen-configuration-alist
   (sort (escreen-configuration-alist)
         (lambda (a b)
           (< (car a) (car b))))))

;;; map-data sub-accessors

(defun escreen-configuration-screen-number (l)
  (nth 0 l))

(defun escreen-configuration-screen-name (l)
  (nth 1 l))

(defun escreen-configuration-window-data-configuration (l)
  (nth 2 l))

(defun escreen-configuration-data-map (l)
  (nth 3 l))

(defun escreen-configuration-selected-window-count (l)
  (nth 4 l))

;;; screen map data accessors

(defun escreen-configuration-data-map-critical (data)
  (car data))

(defun escreen-configuration-data-map-user (data)
  (cdr data))

;;; critical map data accessors

(defun escreen-configuration-data-map-critical-buffer (crit-map)
  (nth 0 crit-map))

(defun escreen-configuration-data-map-critical-buffer-name (crit-map)
  (nth 1 crit-map))

(defun escreen-configuration-data-map-critical-buffer-file-name (crit-map)
  (nth 2 crit-map))


(defun escreen-save-screen-map ()
  (let ((config (current-window-configuration))
        (win-data nil)
        (sel-win-count 0)
        (sel-window (selected-window))
        (first-window (escreen-first-window))
        (window nil))
    (save-excursion
      (save-window-excursion
        (select-window first-window)
        (while (not (eq window first-window))
          (cond ((null sel-window))
                ((eq (selected-window) sel-window)
                 (setq sel-window nil))
                (t
                 (setq sel-win-count (1+ sel-win-count))))
          (setq win-data
                (cons (cons (escreen-save-critical-data)
                            (escreen-save-user-data))
                      win-data))
          (setq window (select-window (next-window)))
          (set-buffer (window-buffer (selected-window))))))
    (list config (nreverse win-data) sel-win-count)))

(defun escreen-restore-screen-map (map)
  (let ((config (escreen-configuration-window-data-configuration map))
        (map (escreen-configuration-data-map map))
        (sel-win-number (escreen-configuration-selected-window-count map))
        (win-count 0)
        (sel-win nil))
    (set-window-configuration config)
    (select-window (escreen-first-window))
    (while map
      (and (= win-count sel-win-number)
           (setq sel-win (selected-window)))
      (setq win-count (1+ win-count))

      (escreen-restore-critical-data
       (escreen-configuration-data-map-critical (car map)))
      (widen)
      (escreen-restore-user-data
       (escreen-configuration-data-map-user (car map)))
      (select-window (next-window))
      (setq map (cdr map)))
    (select-window (or sel-win (escreen-first-window)))))

(defun escreen-save-critical-data ()
  (mapcar 'funcall escreen-map-critical-data-format))

(defun escreen-restore-critical-data (data)
  (let ((buffer (escreen-configuration-data-map-critical-buffer data))
        (buffer-name
         (escreen-configuration-data-map-critical-buffer-name data))
        (buf-file-name
         (escreen-configuration-data-map-critical-buffer-file-name data)))
    (cond ((escreen-killed-buffer-p buffer)
           (cond ((null escreen-restore-killed-buffers)
                  (set-window-buffer (selected-window)
                                     (get-buffer-create
                                      escreen-new-screen-default-buffer)))
                 ((stringp buf-file-name)
                  (setq buffer (find-file-noselect buf-file-name))
                  (set-window-buffer (selected-window) buffer)
                  (or (get-buffer buffer-name)
                      (rename-buffer buffer-name)))
                 (t
                  (set-window-buffer (selected-window)
                                     (get-buffer-create
                                      escreen-new-screen-default-buffer)))))
          (t
           (set-window-buffer (selected-window) buffer)))))

(defun escreen-save-user-data ()
  (mapcar (lambda (pair) (funcall (car pair)))
          escreen-map-data-format))

(defun escreen-restore-user-data (data)
  (let ((funlist escreen-map-data-format))
    (while (and data funlist)
      (funcall (cdr (car funlist)) (car data))
      (setq funlist (cdr funlist))
      (setq data (cdr data)))))


;; Functions used to save and restore screen configuration state.
;; These are mapped over via presence in escreen-map-data-format.

(defun escreen-map-save-window-start ()
  (escreen-make-marker (window-start)))

(defun escreen-map-restore-window-start (p)
  (and (escreen-position-valid-p p)
       (set-window-start (selected-window) p t)))

(defun escreen-map-restore-mark-marker (mark)
  (cond ((escreen-position-valid-p mark)
         (set-marker (or (mark-marker)
                         ;; when XEmacs zmacs-regions are set, mark-marker
                         ;; can return nil unless optional arg forcep is
                         ;; non-nil.
                         ;; In Emacs transient-mark-mode, mark-marker will
                         ;; still return a marker, so no magic needed.
                         (mark-marker t))
                     (marker-position mark)
                     (marker-buffer mark)))))

(defun escreen-map-save-point ()
  ;; If there is a process mark in the current buffer and point is at it,
  ;; then return the process mark also.  That way, when we return to this
  ;; screen, point will be at the end of the process output even if that
  ;; has advanced since then.  Otherwise, just use a before-insertion
  ;; marker (if supported).
  (let* ((point-mark (escreen-make-marker (point-marker) nil t))
         (proc (get-buffer-process (current-buffer)))
         (proc-mark (and proc (process-mark proc))))
    (if (and (escreen-position-valid-p proc-mark)
             (= proc-mark (point)))
        (cons proc-mark point-mark)
      point-mark)))

(defun escreen-map-restore-point (pos)
  (cond ((consp pos)
         (cond ((escreen-position-valid-p (car pos))
                (goto-char (car pos)))
               ((escreen-position-valid-p (cdr pos))
                (goto-char (cdr pos)))))
        (t
         (and (escreen-position-valid-p pos)
              (goto-char pos)))))

(defun escreen-map-save-narrowed-region ()
  (cons (and (> (point-min) 1)
             (escreen-make-marker (point-min)))
        (and (<= (point-max) (buffer-size))
             (escreen-make-marker (point-max) nil t))))

(defun escreen-map-restore-narrowed-region (reg)
  (let ((size (1+ (buffer-size)))
        (beg (or (car reg) (point-min)))
        (end (or (cdr reg) (point-max))))
    (and (escreen-position-valid-p beg)
         (escreen-position-valid-p end)
         (<= beg size)
         (<= end size)
         (narrow-to-region beg end))))

(defun escreen-map-save-truncate-lines ()
  truncate-lines)

(defun escreen-map-restore-truncate-lines (v)
  (setq truncate-lines v))

(defun escreen-map-save-mode-line-face ()
  (cond ((fboundp 'face-reverse-p)
         ;; XEmacs mode line face properties
         (list (face-reverse-p 'modeline)
               (face-background 'modeline)
               (face-foreground 'modeline)))
        ((boundp 'mode-line-inverse-video)
         mode-line-inverse-video)))

(defun escreen-map-restore-mode-line-face (v)
  (cond ((fboundp 'face-reverse-p)
         (set-face-reverse-p 'modeline (nth 0 v))
         (set-face-background 'modeline (nth 1 v))
         (set-face-foreground 'modeline (nth 2 v)))
        ((boundp 'mode-line-inverse-video)
         (setq mode-line-inverse-video v))))

;; Emacs 19.30 and beyond supports menu bars on ascii terminals, but beware
;; of turning them off or on once escreen is loaded; if a stored window
;; configuration was for a frame with a menu bar, but there is no menu bar
;; presently, that will crash emacs.  This fatal bug is present in all
;; versions of Emacs prior to 21.0.
(defun escreen-map-save-menu-bar-mode ()
  (and (boundp 'menu-bar-mode)
       menu-bar-mode))

(defun escreen-map-restore-menu-bar-mode (v)
  (cond ((fboundp 'menu-bar-mode)
         (if v
             (menu-bar-mode 1)
           (menu-bar-mode -1)))))

(defun escreen-map-restore-buffer-list (olist)
  (and escreen-preserve-buffer-list-order
       (escreen-set-buffer-list-order olist)))


(defun escreen-killed-buffer-p (buffer)
  (not (if (fboundp 'buffer-live-p)
           (buffer-live-p buffer)
         ;; Emacs 18 doesn't have buffer-live-p.
         ;; Killed buffers have no names.
         (buffer-name buffer))))

(defun escreen-position-valid-p (pos)
  (cond ((numberp pos)
         (<= pos (1+ (buffer-size))))
        ((markerp pos)
         (and (eq (marker-buffer pos) (current-buffer))
              (numberp (marker-position pos))
              (<= pos (1+ (buffer-size)))))
        (t nil)))

(defun escreen-set-buffer-list-order (olist)
  (let (firstbuf buf)
    (while olist
      (setq buf (car olist))
      (and (stringp buf)
           (setq buf (get-buffer buf)))
      (cond ((escreen-killed-buffer-p buf))
            (t
             (bury-buffer buf)
             (or firstbuf
                 (setq firstbuf buf))))
      (setq olist (cdr olist)))
    (setq olist (buffer-list))
    (while (not (eq (car olist) firstbuf))
      (bury-buffer (car olist))
      (setq olist (cdr olist)))))

;; Copy existing marker, or make a new one from point.
;; Emacs 19.30 and later can create markers which are advanced if text is
;; inserted before them, without needing to call insert-before-markers
;; explicitly.  This is useful for storing point, mark, etc. since the
;; buffer may be edited while we are in other escreens.
(defun escreen-make-marker (pos &optional buffer insertion-type)
  (let ((new-marker nil))
    (cond ((markerp pos)
           (setq new-marker (copy-marker pos))
           (and buffer
                (set-marker new-marker (marker-position pos) buffer)))
          (t
           (setq new-marker (make-marker))
           (set-marker new-marker pos buffer)))
    (and (fboundp 'set-marker-insertion-type)
         (set-marker-insertion-type new-marker insertion-type))
    new-marker))

(defun escreen-first-window ()
  (cond ((fboundp 'frame-highest-window)
         (funcall 'frame-highest-window))
        ((fboundp 'frame-first-window)
         (funcall 'frame-first-window))
        ((one-window-p)
         (selected-window))
        (t
         (let ((win (selected-window)))
           (while (not (escreen-first-window-p win))
             (setq win (next-window win)))
           win))))

(defun escreen-first-window-p (win)
  (let ((edges (escreen-window-edges win)))
    (and (= (nth 0 edges) 0)
         (= (nth 1 edges) 0))))


(defun escreen-menu ()
  (interactive)
  (escreen-configuration-alist-sort-by-number)
  (let ((escreen-menu-buffer (get-buffer-create "*Escreen List*"))
        alist data-map screen-number)
    ;; Display buffer now so update of screen cofiguration will be correct.
    (display-buffer escreen-menu-buffer)
    ;; Update escreen-configuration-alist to contain up-to-date information
    ;; on current screen, since we'll be displaying data about it.
    (escreen-save-current-screen-configuration)
    (setq alist (escreen-configuration-alist))
    (save-excursion
      (set-buffer escreen-menu-buffer)
      (setq buffer-read-only nil)
      (erase-buffer)
      (insert " Screen Buffers\n ------ -------\n")
      (while alist
        (setq screen-data (car alist))
        (setq alist (cdr alist))

        (setq screen-number (escreen-configuration-screen-number screen-data))
        (setq data-map (escreen-configuration-data-map screen-data))

        (if (= screen-number (escreen-current-screen-number))
            (insert (format "*%-6d " screen-number))
          (insert (format " %-6d " screen-number)))
        (while data-map
          (insert (if (> (current-column) 0) "" "        ")
                  (escreen-configuration-data-map-critical-buffer-name
                   (escreen-configuration-data-map-critical (car data-map)))
                  "\n")
          (setq data-map (cdr data-map)))
        (insert "\n"))
      (escreen-menu-mode))))

(defun escreen-menu-mode ()
  (fundamental-mode)
  (kill-all-local-variables)
  (setq buffer-undo-list t)
  (setq truncate-lines t)
  (setq buffer-read-only t)
  (setq major-mode 'escreen-menu-mode)
  (setq mode-name "Escreen Menu")
  (run-hooks 'escreen-menu-mode-hook))


;; Install this by doing
;;
;;    (add-hook 'escreen-goto-screen-hook
;;              'escreen-enable-number-mode-if-more-than-one-screen)
;;
;; By doing so, escreen-number-mode is disabled whenever only a single
;; escreen is in use.  The only reason for doing this, however, is to save
;; valuable mode line real estate.
(defun escreen-enable-number-mode-if-more-than-one-screen ()
  (set-escreen-one-screen-p
   (null (cdr (escreen-get-active-screen-numbers))))
  (force-mode-line-update t))

(provide 'escreen)

;;; escreen.el ends here
#+end_src
