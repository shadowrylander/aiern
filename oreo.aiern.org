#+setupfile: ./README.org
#+include: ./README.org

This can be used with =GNU Stow= as well! :D

The tangle functions are adapted from [[https://emacs.stackexchange.com/a/29884/31428][this answer on the emacs Stack Exchange]],
which was written by [[https://emacs.stackexchange.com/users/2710/andrew-swann][Andrew Swann]].

* .config
*** yadm
**** bootstrap

#+call: hash("resources")

#+RESULTS:
: 676db0abb976db0a506bad2b0e523575

#+name: 676db0abb976db0a506bad2b0e523575
#+begin_src python
resources = f"{os.environ["HOME"]}/system/etc/nixos/resources"
#+end_src

#+call: hash("while-setup")

#+RESULTS:
: a847be184b015d06a2e776f51f25971a

#+name: a847be184b015d06a2e776f51f25971a
#+begin_src python
while true:
    pool_name = raw_input("What's the pool name?\n\t")
    if pool_name == "":
        print("Wait a minute... That's not a valid pool name! Try again, please!\n")
    elif pool_name == "quit bootstrap":
        print("Catch ya' later!")
        exit(0)
    else:
        print("Alright; let's get crackin'!\n\n")
        encrypted = raw_input('''
            Is this pool [to be] encrypted?
                y | n\n\t
        ''') == "y"
        break
#+end_src

# Rewrite this for python 3.9

#+call: hash("")

#+RESULTS:
: 5918a1d90f5b7e61007371faf087dff7

#+name: 5918a1d90f5b7e61007371faf087dff7
#+begin_src python :tangle (jr/tangle-oreo) :shebang "#!/usr/bin/env xonsh"
import json os
from sys import exit

<<676db0abb976db0a506bad2b0e523575>>

<<b42270f71a0086b3d3e42a785d8b5bb0>>

<<be9a81e82f7c0ddadaf4c4cbada241b5>>

def xrun(command):
    @(command.split())

xrun("nix-env -i sd rsync")

try:

    <<a847be184b015d06a2e776f51f25971a>>

    while true:
        input = input or raw_input("Pick an option, any option! :D\n\t")
        saved_input = [c for c in input]
        input = ""
        for c in saved_input:
            if c == "c":
                if raw_input('THIS WILL DELETE ALL DATA ON THE SELECTED DEVICE / PARTITION! TO CONTINUE, TYPE IN "ZFS CREATE"!\n\t') == "ZFS CREATE":

                    <<82fa6951dc98acdbbce8fce980732d4a>>

                else:
                    print("Sorry; not continuing!\n\n")
            elif c == "m":

                <<3836516e33beb8c8a336b3ac75d26e05>>

            elif c == "u":
                while true:
                    input2 = raw_input('''
                        Would you like to update the resource files, or the pool?
                            f | p | [g]o back\n\t
                    ''')
                    for cc in input2:
                        if cc == "f":

                            <<aa6815ffe0495e012a80a5e3ddb4b0bd>>

                        elif cc == "p":

                            <<03fc24d52cd1b15f6c3a2cb83ccaf5d2>>

                        elif cc == "g":
                            print("Goin' back!\n\n")
                            break
                        else:
                            print("Wait a minute... That's not a valid option! Try again, please!\n\n")
            elif c == "g":
                if raw_input('''
                    Would you like to generate a nixos "[hardware-]configuration.nix" file?
                        y | n\n\t
                ''') == "y":
                    xrun("nixos-generate-config")

            # TODO
            elif c == "b":
                if raw_input('''
                    Would you like to include the bootstrap file in the nixos "configuration.nix" file?
                        y | n\n\t
                ''') == "y":
                    xrun('sd "./hardware-configuration.nix" "./bootstrap.nix" /mnt/etc/nixos/configuration.nix')

            # TODO: Also include a one-stop-install, mounting, generating, copying, etc. all in one go
            elif c == "a":
                input = ""
                break

            elif c == "r":
                if raw_input('''
                    Would you like to rsync over the bootstrap files to "/mnt"?
                        y | n\n\t
                ''') == "y":
                    xrun("rsync -avvczz ../../ /mnt/")
            elif c == "i":
                if raw_input('''
                    Would you like to begin the NixOS bootstrap installation?
                        y | n\n\t
                ''') == "y":
                    xrun("nixos-install --show-trace")
            elif c == "h":

                <<be9a81e82f7c0ddadaf4c4cbada241b5>>

            elif c == "s":

                <<a847be184b015d06a2e776f51f25971a>>

            elif c == "H":

                

            elif c == "q":
                print("Catch ya' later!")
                break
            else:
                print(f'Wait a minute... The value "{c}" is not a valid option! Try again, please!\n\n')
                break

finally:
    xrun(f"zpool export {pool_name} &> /dev/null")
    exit(0)
#+end_src

***** tab completion for =raw_input=

Lifted From [[https://stackoverflow.com/a/5638688/10827766][this answer]] on Stack Overflow,
by [[https://stackoverflow.com/users/538718/samplebias][samplebias]]:

#+call: hash("")

#+RESULTS:
: b42270f71a0086b3d3e42a785d8b5bb0

#+name: b42270f71a0086b3d3e42a785d8b5bb0
#+begin_src python
import os
import re
import readline

COMMANDS = ['extra', 'extension', 'stuff', 'errors',
            'email', 'foobar', 'foo']
RE_SPACE = re.compile('.*\s+$', re.M)

class Completer(object):

    def _listdir(self, root):
        "List directory 'root' appending the path separator to subdirs."
        res = []
        for name in os.listdir(root):
            path = os.path.join(root, name)
            if os.path.isdir(path):
                name += os.sep
            res.append(name)
        return res

    def _complete_path(self, path=None):
        "Perform completion of filesystem path."
        if not path:
            return self._listdir('.')
        dirname, rest = os.path.split(path)
        tmp = dirname if dirname else '.'
        res = [os.path.join(dirname, p)
                for p in self._listdir(tmp) if p.startswith(rest)]
        # more than one match, or single match which does not exist (typo)
        if len(res) > 1 or not os.path.exists(path):
            return res
        # resolved to a single directory, so return list of files below it
        if os.path.isdir(path):
            return [os.path.join(path, p) for p in self._listdir(path)]
        # exact file match terminates this completion
        return [path + ' ']

    def complete_extra(self, args):
        "Completions for the 'extra' command."
        if not args:
            return self._complete_path('.')
        # treat the last arg as a path and complete it
        return self._complete_path(args[-1])

    def complete(self, text, state):
        "Generic readline completion entry point."
        buffer = readline.get_line_buffer()
        line = readline.get_line_buffer().split()
        # show all commands
        if not line:
            return [c + ' ' for c in COMMANDS][state]
        # account for last argument ending in a space
        if RE_SPACE.match(buffer):
            line.append('')
        # resolve command to the implementation function
        cmd = line[0].strip()
        if cmd in COMMANDS:
            impl = getattr(self, 'complete_%s' % cmd)
            args = line[1:]
            if args:
                return (impl(args) + [None])[state]
            return [cmd + ' '][state]
        results = [c + ' ' for c in COMMANDS if c.startswith(cmd)] + [None]
        return results[state]

comp = Completer()
# we want to treat '/' as part of a word, so override the delimiters
readline.set_completer_delims(' \t\n;')
readline.parse_and_bind("tab: complete")
readline.set_completer(comp.complete)
#+end_src

***** show help text

#+call: hash("")

#+RESULTS:
: be9a81e82f7c0ddadaf4c4cbada241b5

#+name: be9a81e82f7c0ddadaf4c4cbada241b5
#+begin_src python
print('''
    Create a new ZFS device:         c
    Mount a ZFS device:              m
    Update:                          u
            Files:                           f
            Pool:                            p
            Go back:                         g
    Generate nixos config:           g
    Include boostrap config:         b
    One-Stop Install:                a
    Rsync over bootstrap config:     r
    Begin install:                   i
    Show this help text:             h
    Setup:                           s
    Quit:                            q
    Install and Set Up Home-Manager: H
    \n\n
''')
#+end_src

***** create

#+call: hash("")

#+RESULTS:
: 82fa6951dc98acdbbce8fce980732d4a

#+name: create
#+begin_src python
options = {
    "xattr": "sa",
    "acltype": "posixacl",
    "mountpoint": "none",
    "compression": "zstd-19",
    "checksum": "edonr",
    "atime": "off",
    "relatime": "off",
}

if encrypted:
    options["encryption"] = "aes-256-gcm"
    options["keyformat"] = "passphrase"
if (dedup := (raw_input('''
    Should this pool be deduplicated?
        y | n\n\t
''') == "y")):
    options["dedup"] = "edonr,verify"

for dataset in $(zfs list -rH).split("\n"):
    if pool_name in dataset:
        xrun(f"zpool export {pool_name}")
        break

command = f"zpool create -fo autotrim=on -o altroot=/mnt"

for key, value in options.items():
    command += f" -O {key}={value}"

zfs_device = raw_input("Please enter the device to be initialized:\n\t")

xrun(f"{command} {pool_name} {zfs_device}")

<<03fc24d52cd1b15f6c3a2cb83ccaf5d2>>

#+end_src

****** open =f{resources}/users.json=

#+call: hash("")

#+RESULTS:
: d61c11eac203bfa4ee2cb42f93e5c959

#+name: d61c11eac203bfa4ee2cb42f93e5c959
#+begin_src python
users = json.loads('''
    <<4b4166b2bebff5d6dc0a9118372f6e36>>
'''.strip())

for user in users.values():
    dsd["home"][d][user] = dd
    datasets["virt"][d]["podman"][d][user] = dd
    for dataset in (persist := dsd["persist"][d]).keys():
        persist[dataset][d][user] = dd
#+end_src

****** open =f{resources}/datasets.nix=
******* before opening =f{resources}/datasets.nix=

#+call: hash("")

#+RESULTS:
: 9b6d5ff07d5ba4ca0e95609407d6f5e4

#+name: 9b6d5ff07d5ba4ca0e95609407d6f5e4
#+begin_src python
with open(f"{resources}/datasets.nix", "w+") as dnix:

    dnix.write("host: {\n")

    def recurse(ddict, dname, droot, mountpoint = ""):

        _dataset = f"{droot}/{dname}"

        # cc: clone or create
        # son: snapshot or none
        if (dname != "base") and (encrypted and dedup):
            cc = "clone"
            son = f"{pool_name}/base@root"
        else:
            cc = "create"
            son = ""

        _doptions = ddict.get("options", [])
        if _dataset not in ( f"{pool_name}/{dataset}" for dataset in (
            "system",
            "system/root",
            "swap",
            "base",
            "hold",
            "omniverse",
            "reserved",
        )):
            pn1 = pool_name
            pn2 = f"{pn1}/{pn1}"

            # TODO: Make this such that the current dataset directory
            #       is placed under the parent directory's mountpoint
            if (mountpoint := (_mountpoint := ddict.get("mountpoint", ""))) == "":
                if mountpoint = "":
                    _mountpoint = _dataset.replace(
                        pn2 if pn2 in _dataset else pn1
                        "${host}",
                        1
                    )
                else:
                    mountpoint = _mountpoint = f"{mountpoint}/{dname}"

            dnix.write(f'\t"{_dataset}" = "{_mountpoint}";\n')
        doptions = " -o ".join(_doptions)
#+end_src

******* after opening =f{resources}/datasets.nix=

#+call: hash("")

#+RESULTS:
: 9bde4e3ed9b0f8a5edd7ce3e86bbcdeb

#+name: 9bde4e3ed9b0f8a5edd7ce3e86bbcdeb
#+begin_src python
        for dataset in (ddictd := ddict.get(
            d,
            dd
        )):
            recurse(ddictd[dataset], dataset, _dataset, mountpoint)

    for dataset in datasets:
        recurse(datasets[dataset], dataset, pool_name)

    dnix.write("}")
#+end_src

****** open =datasets.json=

#+call: hash("datasets-json")

#+RESULTS:
: d13f2d313813c806f6f6bd1040516bd9

#+name: d13f2d313813c806f6f6bd1040516bd9
#+begin_src json
{
    "base": {  },
    "hold": {  },
    "omniverse": {  },
    "reserved": {  },
    "system": {
        "datasets": {
            "home": { "datasets": { "root": { "mountpoint": "/root" }}},
            "nix": {  },
            "persist": {
                "datasets": {
                    "cache": {
                        "datasets": { "root": {  }},
                        "options": [ "sync=disabled" ]
                    },
                    "home": { "datasets": { "root": {  }}}
                }
            },
            "root": {  },
            "tmp": { "options": [ "sync=disabled" ] }
        },
        "options": [ "mountpoint=legacy" ]
    },
    "virt": {
        "datasets": {
            "docker": {  },
            "kvm": {  },
            "podman": { "datasets": {  }},
            "qemu": {  },
            "vagrant": {  },
            "xen": {  }
        },
        "options": [ "mountpoint=legacy", "refreservation=none" ],
        "mountpoint": "/var/lib"
    }
}
#+end_src

#+call: hash("")

#+RESULTS:
: cb652aaddb0e92c44ba367a0ea174f81

#+name: cb652aaddb0e92c44ba367a0ea174f81
#+begin_src python
datasets = json.loads('''
    <<d13f2d313813c806f6f6bd1040516bd9>>
'''.strip())

dsd = datasets[s][d]

datasets[args.pool_name] = {
    "datasets": {
        "b": {
            "datasets": {
                "a": dd,
                "cc": { "options": snapDir },
                "cl": dd,
                "cj": { "datasets": {
                    "cc": { "options": extraCopies },
                    "m": { "options": snapDir }
                }},
                "eb": { "options": extraCopies },
                "oreo": { "option": snapDir },
                "p": { "options": snapDir }
            },
        },
        "borg": { "datasets": { "cache": { "options": cache }}},
        "jails": { "datasets": { "base": dd}},
        "las": {
            "datasets": {
                "dreadnought": ddd,
                "redstone": ddd,
                "sinnoh": ddd
            }
        },
        "y": dd,
        "z": dd
    },
    "options": [ ml ]
}

<<d61c11eac203bfa4ee2cb42f93e5c959>>

for backup in (las := datasets[pool_name][d]["las"][d]).keys():
    for zz in [ "zpax", "zsyncs" ]:
        las[backup][d][zz] = dd

<<9b6d5ff07d5ba4ca0e95609407d6f5e4>>

#+end_src

***** mount

#+call: hash("")

#+RESULTS:
: 3836516e33beb8c8a336b3ac75d26e05

#+name: 3836516e33beb8c8a336b3ac75d26e05
#+begin_src python
from collections import namedtuple
from functools import partial
from os import path as osPath
from subprocess import DEVNULL

for dataset in $(zfs list).split("\n"):
    if pool_name in dataset:
        break
else:
    xrun(f"zpool import -f {pool_name}")

if encrypted:
    xrun(f"zfs load-key {pool_name}")

if osPath.isdir("/mnt"):
    xrun("umount -R /mnt")
else:
    xrun("mkdir /mnt")

xrun(f"mount -t zfs {pool_name}/system/root /mnt")

with open(f"{resources}/datasets.nix") as datasets:
    for dataset in datasets.readlines()[1:-1]:
        dataset = dataset.strip().strip('"')

        r = f"{pool_name}/"
        sr = r + "system/"
        _mount = dataset.replace(
            sr if sr in dataset else r,
            '',
            1
        )

        if not osPath.isdir(mount := f"/mnt/{_mount}"):
            xrun(f"mkdir -p {mount}")
        xrun(f"mount -t zfs {dataset} {mount}")

if not osPath.isdir(boot := "/mnt/boot/efi"):
    xrun(f"mkdir -p {boot}")

boot_device = raw_input("Please enter the boot device:\n\t")
xrun(f"mount {boot_device} {boot}")

if (swap := (raw_input('''
    Does this pool use SWAP?
        y | n\n\t
''') == "y")):
    xrun(f"swapon /dev/zvol/{pool_name}/swap")
#+end_src

***** update
****** before updating

#+call: hash("")

#+RESULTS:
: cde010f5bc96de0ae2d7961aa9a71dc4

#+name: cde010f5bc96de0ae2d7961aa9a71dc4
#+begin_src python
snapDir = [ "snapdir=visible" ]
extraCopies = snapDir + [ f"copies={2 if encrypted else 3}" ]
cache = [ "sync=disabled" ]
ml = "mountpoint=legacy"
dd = {  }
ddd = { "datasets": {  }}
d = "datasets"
s = "system"

<<cb652aaddb0e92c44ba367a0ea174f81>>

#+end_src

****** after updating the pool

#+call: hash("")

#+RESULTS:
: b09868eb4eaf5d508a70a487a8f2a5dc

#+name: b09868eb4eaf5d508a70a487a8f2a5dc
#+begin_src python
pool_size_plus_metric = $(zpool get -H size @(pool_name)).split()[2]
pool_size = round(float(pool_size_plus_metric[:-1]), 2)
pool_metric = pool_size_plus_metric[-1]

def pool_percentage_value(percentage):
    return (
        str(
            round(
                (
                    (float(percentage) / 100)
                    * pool_size
                ),
                2,
            )
        )
        + pool_metric
    )

# Apparently, if python internal keywords exist in the argument, such as "set", etc.
# the command errors out; perhaps something to raise an issue of.
# This seems to work as an alternative.
xrun(f"zfs set refreservation={pool_percentage_value(15)} {pool_name}/reserved")

if (swap := (raw_input('''
    Will this pool use SWAP?
        y | n\n\t
''') == "y")):
    _swoptions = [
        "com.sun:auto-snapshot=false",
        "compression=zle",
        "logbias=throughput",
        "primarycache=metadata",
        "secondarycache=none"
        "sync=standard",
    ]
    swoptions = " -o ".join(_swoptions)

    ps = $(getconf PAGESIZE)
    swap_size = int(raw_input("Please enter the (integer) SWAP size in GiB:\n\t"))
    xrun(f"zfs create -V {2**swap_size}G -b {ps} -o {swoptions} {pool_name}/swap")

    xrun(f"mkswap -f /dev/zvol/{pool_name}/swap")
#+end_src

****** if updating the pool

#+call: hash("")

#+RESULTS:
: 89b42fd94e35a06e40a08750404e994a

#+name: 89b42fd94e35a06e40a08750404e994a
#+begin_src python
        xrun(f"zfs {cc} {'-o ' if _doptions else ''} {doptions} {son} {_dataset}")
        xrun(f"zfs snapshot -r {_dataset}@root")
#+end_src

****** files

#+call: hash("")

#+RESULTS:
: aa6815ffe0495e012a80a5e3ddb4b0bd

#+name: aa6815ffe0495e012a80a5e3ddb4b0bd
#+begin_src python
<<cde010f5bc96de0ae2d7961aa9a71dc4>>

<<9bde4e3ed9b0f8a5edd7ce3e86bbcdeb>>

#+end_src

****** pool

#+call: hash("")

#+RESULTS:
: 03fc24d52cd1b15f6c3a2cb83ccaf5d2

#+name: 03fc24d52cd1b15f6c3a2cb83ccaf5d2
#+begin_src python
<<cde010f5bc96de0ae2d7961aa9a71dc4>>

<<89b42fd94e35a06e40a08750404e994a>>

<<9bde4e3ed9b0f8a5edd7ce3e86bbcdeb>>

<<b09868eb4eaf5d508a70a487a8f2a5dc>>

#+end_src

* system
** etc
*** nixos
**** configs

#+call: hash("pre")

#+RESULTS:
: 4c712913b902da3ab3e4d6a6c4b61f4e

#+name: 4c712913b902da3ab3e4d6a6c4b61f4e
#+begin_src nix
{ config, lib, ... }: with lib; with j; {
    imports = flatten [
        (imprelib.list { dir = ./.; })
        (imprelib.list { dir = ../../config; })
    ];
#+end_src

#+name: hostId
#+begin_src emacs-lisp
(concat
    "\""
    (string-trim (shell-command-to-string "head -c4 /dev/urandom | od -A none -t x4"))
    "\"")
#+end_src

***** doppel
****** default.nix

#+call: hash("")

#+RESULTS:
: 29a9e8bb050717f9b80f1642ae7a4ec6

#+name: 29a9e8bb050717f9b80f1642ae7a4ec6
#+begin_src nix :tangle (jr/tangle-oreo)
<<4c712913b902da3ab3e4d6a6c4b61f4e>>
    config.networking.hostId = <<hostId()>>;
}
#+end_src

***** sandshrew
****** default.nix

#+call: hash("")

#+RESULTS:
: be5dee49c9f1a4329ab24cbd0e992e52

#+name: be5dee49c9f1a4329ab24cbd0e992e52
#+begin_src nix :tangle (jr/tangle-oreo)
<<4c712913b902da3ab3e4d6a6c4b61f4e>>
    config.networking.hostId = <<hostId()>>;
}
#+end_src

**** configuration.nix

#+call: hash("")

#+RESULTS:
: 85c71d57cb6422039ae10ee7e4a830ed

#+name: 85c71d57cb6422039ae10ee7e4a830ed
#+begin_src nix :tangle (jr/tangle-oreo)
inputs@{ config, pkgs, ... } : with builtins; let
    source = fetchGit {
        url = "https://github.com/shadowrylander/shadowrylander";
        ref = "master";
    };

    flake = let
        flakePath = "${source}/system/etc/nixos";
        lock = builtins.fromJSON (builtins.readFile "${flakePath}/flake.lock");
    in (import (
        fetchTarball {
            url = "https://github.com/edolstra/flake-compat/archive/${lock.nodes.flake-compat.locked.rev}.tar.gz";
            sha256 = lock.nodes.flake-compat.locked.narHash; }
        ) { src =  flakePath; }).defaultNix;

    inherit (flake) lib;
    inherit (flake.legacyPackages) sources;

    stc = lib.j.attrs.default-stc // {
        device = "";
        host = "";
        type = "";
    };
    stc-home = stc // {
        nixos = 1;
        zfs = null;
    };

    integer-default-truths = lib.mapAttrs (
        n: v: v == 1
    ) (lib.filterAttrs (n: v: isInt v) stc-home);

    home-manager' = fetchGit {
        url = "https://github.com/nix-community/home-manager";
        ref = "master";
    };
    impermanence = fetchGit {
        url = "https://github.com/nix-community/impermanence";
        ref = "master";
    };
    hash = user: lib.j.hostName { stc = stc-home // { inherit user; }; };
    customInputs = inputs // { inherit stc lib sources; };
in
with lib;
with j;
with stc;
with integer-default-truths;
if (
    device == "" || host == "" || type == "" || zfs == null
) then (abort "Sorry! The device, host, type, and zfs status must be set!") else {
    <<e76b4601025ef4ed0071b29a0161182f>>
    imports = [
        (import (./. + "/configs/${stc.host}") customInputs)
        (import ./modules/variables.nix customInputs)
        (import ./modules/users.nix customInputs)
        (import "${home-manager'}/nixos")
        (import "${impermanence}/nixos.nix")
        (myIf.set (type == "pinebook") (
            "${fetchGit {
                url = "https://github.com/shadowrylander/wip-pinebook-pro";
                ref = "master";
            }}/configuration.nix"
        ))
        (myIf.shell (type == "rpi") (import ./devices/rpi (inputs // stc)))
    ];
    config = {

        # No need to merge "v" here, as that is taken care of by the module system
        users.users = mapAttrs (n: v: { packages = mkForce []; }) attrs.allUsers;

        home-manager = {
            useUserPackages = true;
            useGlobalPkgs = true;
            backupFileExtension = "bak";
            verbose = true;

            # TODO
            sharedModules = [
                {  }
            ];

            extraSpecialArgs = flake.legacyPackages.make.specialArgs { inherit stc; };

            users = listToAttrs (map (user: nameValuePair user (let
                homeDirectory = attrs.allHomes.${user};
            in {
                imports = [ (import "${impermanence}/home-manager.nix") ];
                programs.home-manager = {
                    enable = true;
                    path = home-manager';
                };
                home = {
                    file = mkMerge [{
                            "${attrs.users.primary}".source = source;
                            <<43603ebd7da002155f7108935561456a>>
                        }
                        (myIf.set (user == "root") (attrs.link "/" "${source}/system"))
                        (attrs.link homeDirectory "${source}/home")
                    ];
                    ${myIf.knull (nixos && zfs) "persistence"} = attrs.persistence.home {  };
                };
            })) attrs.allUsers);
        };
        environment = {
            ${myIf.knull zfs "persistence"} = attrs.persistence.system {  };
            etc."nix/nix.conf".text = attrs.configs.nix;
        };
        nixpkgs = {
            overlays = import ./overlays { inherit stc; };
            config = {
                <<ee56d4a974b19cdf64e1e8f02e47ccaa>>
            };
        };
        boot.loader = {
            systemd-boot.enable = mkForce config.vars.bootPart;
            efi.efiSysMountPoint = "/boot/efi";
            efi.canTouchEfiVariables = mkForce true;
            grub.efiInstallAsRemovable = mkForce false;
            grub.enable = mkForce false;
            grub.efiSupport = mkForce true;
            grub.device = mkForce "nodev";
            grub.version = mkForce 1;
            grub.copyKernels = mkForce true;
            grub.forceInstall = mkForce true;
            grub.zfsSupport = mkForce false;

            # Used for Bedrock Linux
            initScript.enable = mkForce true;
        };
        nix = {
            package = pkgs.nixUnstable;
            extraOptions = '' experimental-features = nix-command flakes '';
        };
        environment.systemPackages = with pkgs; [ vim git rsync tmux byobu xonsh yadm
            # python39
        ];
    }
}
#+end_src

**** devices
***** hyper-v
****** boot.nix

Taken from [[https://github.com/NixOS/nixos-hardware/tree/master/microsoft/hyper-v][here]]:

#+call: hash("")

#+RESULTS:
: 30fdd17346f1ba60dd27355abe17b217

#+name: 30fdd17346f1ba60dd27355abe17b217
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    boot = {
        # REQUIRED - see: https://github.com/nixos/nixpkgs/issues/9899

        kernelModules = [ "hv_vmbus" "hv_storvsc" ];
        initrd = {
            kernelModules = [ "hv_vmbus" "hv_storvsc" ];
            availableKernelModules = [ "hv_vmbus" "hv_storvsc" ];

            # UNKNOWN - not sure if below are needed; were suggested for VirtualBox and I used them
            checkJournalingFS = false;

        };
        extraModulePackages = with pkgs.linuxPackages_latest; [ hyperv-daemons ];

        # RECOMMENDED
        # - use 800x600 resolution for text console, to make it easy to fit on screen
        kernelParams = ["video=hyperv_fb:800x600"];  # https://askubuntu.com/a/399960
        # - avoid a problem with `nix-env -i` running out of memory
        # kernel.sysctl."vm.overcommit_memory" = "1"; # https://github.com/NixOS/nix/issues/421
    };
}
#+end_src

****** default.nix

#+call: hash("")

#+RESULTS:
: 67725f65856c58234fc34b9275c4da43

#+name: 67725f65856c58234fc34b9275c4da43
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = imprelib.list { dir = ./.; };
    config = {
        vars.noSwap = true;
        networking = {
            wireless.enable = false;
            interfaces.eth0.useDHCP = true;
        };
        virtualisation.hypervGuest.enable = true;
    };
}
#+end_src

***** linode
****** default.nix

#+call: hash("")

#+RESULTS:
: c8c26a3e2ac4a096597804d50e69fca2

#+name: c8c26a3e2ac4a096597804d50e69fca2
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = imprelib.list { dir = ./.; };
    config = {
        vars.terminal = true;
        boot = {
            kernelParams = [ "console=ttyS0,19200n8" ];
            loader.grub.extraConfig = ''
                serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1;
                terminal_input serial;
                terminal_output serial;
            '';
        };
        networking = {
            usePredictableInterfaceNames = false;
            interfaces.eth0.useDHCP = true;
        };
    };
}
#+end_src

***** rpi
****** 3b.nix

#+call: hash("")

#+RESULTS:
: 210b033fdaac881a3a29e9cb4224e623

#+name: 210b033fdaac881a3a29e9cb4224e623
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, pkgs, type, ... }: with builtins; with lib; with j; mkIf (type == "3b") {
    vars.terminal = true;
    boot = {
        kernelParams = ["cma=256M"];
        loader = {
            raspberryPi = {
                enable = true;
                version = 3;
                uboot.enable = mkForce true;
                firmwareConfig = '' gpu_mem=256 '';
            };
        };
    };
    environment.systemPackages = with pkgs; [ raspberrypi-tools ];
}
#+end_src

****** 4b.nix

# TODO

#+call: hash("")

#+RESULTS:
: cca75de16da0c6105a43698cfaa4062d

#+name: cca75de16da0c6105a43698cfaa4062d
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, pkgs, type, ... }: with builtins; with lib; with j; mkIf (type == "4b") {
    vars.terminal = true;
    boot = {
        kernelParams = ["cma=256M"];
        loader = {
            raspberryPi = {
                enable = true;
                version = 4;
                uboot.enable = true;
                firmwareConfig = '' gpu_mem=256 '';
            };
        };
    };
    environment.systemPackages = with pkgs; [ raspberrypi-tools ];
}
#+end_src

****** default.nix

#+call: hash("")

#+RESULTS:
: de4cfea4004dafc40636fe57881e6b9d

#+name: de4cfea4004dafc40636fe57881e6b9d
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = imprelib.list { dir = ./.; };
}
#+end_src

***** surface
****** specialisation.nix

#+call: hash("")

#+RESULTS:
: ea28ac80f3af59ac23ca4fbb069d6c65

#+name: ea28ac80f3af59ac23ca4fbb069d6c65
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    specialisation = let
        specialisation_base =
            <<bcfc9f879ab6b1c92ceecdb3462cc32d>>;
        inherit (specialisation_base) patches base;
    in {
        clear = base.settings // {
            configuration = {
                config.nixpkgs.overlays = [(self: super: {
                    surface_kernel_latest = super.linuxPackages_latest.extend( self: (ksuper: {
                        kernel = ksuper.kernel.override (base.kernel // {
                            kernelPatches = base.patches ++ base.iabg ++ patches.get patches.dir."58";
                        });
                    }));
                })];
            };
        };
        clear_xen = base.settings // {
            configuration = {
                config.nixpkgs.overlays = [(self: super: {
                    surface_kernel_latest = super.linuxPackages_latest_xen_dom0.extend( self: (ksuper: {
                        kernel = ksuper.kernel.override (base.kernel // {
                            kernelPatches = base.patches ++ base.iabg ++ patches.get patches.dir."57";
                        });
                    }));
                })];
            };
        };
        zen = base.settings // {
            configuration = {
                config.nixpkgs.overlays = [(self: super: {
                    surface_kernel_latest = super.linuxPackages_zen.extend( self: (ksuper: {
                        kernel = ksuper.kernel.override (base.kernel // {
                            kernelPatches = base.patches ++ patches.get patches.dir."58" ++ [
                                { patch = /. + "${patches.dir.base._}/BACKPORT-Linux-5.8-compat-__vmalloc.patch"; name = "BACKPORT-Linux-5.8-compat-__vmalloc"; }
                            ];
                        });
                    }));
                })];
            };
        };
        bcachefs = base.settings // {
            configuration = {
                config = {
                    nixpkgs.overlays = [(self: super: {
                        surface_kernel_latest = super.linuxPackages_zen.extend( self: (ksuper: {
                        kernel = ksuper.kernel.override (base.kernel // {
                                kernelPatches = base.patches ++ base.iabg ++ patches.get patches.dir."58";
                            });
                        }));
                    })];
                    boot = {
                        kernelModules = [ "bcachefs" ];
                        initrd = {
                            kernelModules = [ "bcachefs" ];
                            availableKernelModules = [ "bcachefs" ];
                            supportedFilesystems = [ "bcachefs" ];
                        };
                        supportedFilesystems = [ "bcachefs" ];
                    };
                };
            };
        };
    };
}
#+end_src

****** nixpkgs.nix

#+call: hash("")

#+RESULTS:
: eee0f35786c35108f7d2dadbf8184200

#+name: eee0f35786c35108f7d2dadbf8184200
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    nixpkgs.overlays = let
        specialisation_base =
            <<bcfc9f879ab6b1c92ceecdb3462cc32d>>;
        inherit (specialisation_base) patches base;
    in [
        (self: super: { surface_kernel_latest = super.linuxPackages_zen.extend (
            self: (ksuper: { kernel = ksuper.kernel.override (
                base.kernel // { kernelPatches = base.patches ++ patches.get patches.dir."58" ++ [
                    {
                        patch = /. + "${patches.dir.base._}/BACKPORT-Linux-5.8-compat-__vmalloc.patch";
                        name = "BACKPORT-Linux-5.8-compat-__vmalloc";
                    }
                ];}
            );})
        );})
    ];
}
#+end_src

****** b2.nix

#+call: hash("")

#+RESULTS:
: 8d6dfe74baf8060aa28a2739c067d0ef

#+name: 8d6dfe74baf8060aa28a2739c067d0ef
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, device, ... }: with builtins; with lib; with j; mkIf (device == "b2") {
    boot.extraModprobeConfig = mkAfter '' options ipts singletouch=y '';
    powerManagement.resumeCommands = mkAfter '' modprobe ipts_surface singletouch=y '';
    services.surface-dtx-daemon.detach = mkForce ''
        #!/usr/bin/env xonsh
        for usb in $(ls /dev/disk/by-id).split("\n"):
        if usb and usb[:4] == "usb-":
            for mnt in $(mount).split("\n"):
                if mnt and usb in mnt:
                    umount @(mnt.split()[2])
    '';
}
#+end_src

****** default.nix

#+call: hash("")

#+RESULTS:
: 39c1556081e175b60672d04d9b7323c4

#+name: 39c1556081e175b60672d04d9b7323c4
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = imprelib.list { dir = ./.; };
    config = {
        boot.kernelPackages = pkgs.surface_kernel_latest;
        networking.networkmanager.extraConfig = ''
            [connection]
            wifi.powersave = 2

            [device]
            wifi.scan-rand-mac-address=false
        '';
    };
}
#+end_src

***** pinebook
****** import.nix

#+call: hash("")

#+RESULTS:
: e0a851a952ea6c27e7ad3ec227fd2a0d

#+name: e0a851a952ea6c27e7ad3ec227fd2a0d
#+begin_src nix :tangle (jr/tangle-oreo)
{ sources, ... }: { imports = [ "${sources.wip-pinebook-pro}/configuration.nix" ]; }
#+end_src

****** default.nix

#+call: hash("")

#+RESULTS:
: 0237cb109adc9f4a9631623c0b89fd0b

#+name: 0237cb109adc9f4a9631623c0b89fd0b
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = imprelib.list { dir = ./.; };
}
#+end_src

***** android
****** default.nix

#+call: hash("")

#+RESULTS:
: 55b5d44226e5746225157e35195ad435

#+name: 55b5d44226e5746225157e35195ad435
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = imprelib.list { dir = ./.; };
    config.vars = { terminal = true; minimal = true; };
}
#+end_src

**** flake.nix

#+call: hash("")

#+RESULTS:
: 7b32bbc9949ccb99f79e4c691b878b5a

#+name: 7b32bbc9949ccb99f79e4c691b878b5a
#+begin_src nix :tangle (jr/tangle-oreo)
{
    description = "Wheee!";

    inputs = rec {
        <<da5fe3496669eea2dcae419277ad3927>>
    };

    outputs = inputs@{ self, nixpkgs, flake-utils, flake-compat, ... }: with builtins; with nixpkgs.lib; with flake-utils.lib; let

        mkOverlay = import ./overlays;

        prepkgs = import nixpkgs {
            overlays = mkOverlay {};
            config = {
                system = currentSystem;
                <<ee56d4a974b19cdf64e1e8f02e47ccaa>>
            };
        };

        sources = inputs // prepkgs.j.sources;
        inherit (sources) nix;
        lib = nixpkgs.lib.extend (final: prev: {
            j = import ./lib {
                inherit sources;
                pkgs = prepkgs;
                lib = final;
            };
            h = sources.hlissner.lib;
        });

        inherit (lib) j;
        inherit (lib.j) attrs;
        fas = j.forAllSystems;
        make = {
            overlay = mkOverlay;
            pkgs = { stc, ... }: import prepkgs.j.nixpkgset.${stc.channel} {
                overlays = j.get { inherit stc; set = all.overlays; };
                config =  j.get { inherit stc; set = all.config; };
            };
            specialArgs = { stc, ... }: let
                config =  j.get (configBase // { set = all.config; });
                overlays =  j.get (configBase // { set = all.overlays; });
            in stc // {
                inherit sources inputs make all stc overlays lib;
                config' = config;
                hostName =  j.get { inherit stc; set = all.hostName; };
                stdenv =  j.get (configBase // { set = all.stdenv; });
                nixpkgs =  j.get (configBase // { set = all.nixpkgs; });
                nixpkgset = {
                    inherit (stc) system;
                    inherit overlays config;
                };
            };
            nixosConfiguration = { stc, ... }: let
                configBase = { inherit stc; ignoredAttrs = [ "host" ]; };
            in lib.nixosSystem {
                inherit (stc) system;
                pkgs =  j.get (configBase // { set = all.pkgs; });
                specialArgs = make.specialArgs { inherit stc; };
                modules = flatten [
                    (j.imprelib.list { dir = ./modules; })
                    (with stc; [
                        (./. + "/configs/${host}")
                        (if (device == "def") then {} else (./. + "/devices/${device}"))
                        (let path = ./. + "/platforms/${system}"; in
                            if (pathExists path) then path else {})
                    ])
                    (with sources; [
                        home-manager-flake.nixosModules.home-manager
                        agenix.nixosModules.age
                        impermanence-flake.nixosModules.impermanence
                    ])
                ];
            };
        };
        all' = {
            inherit sources make;
            type = attrs.types;
            device = attrs.devices;
            nixpkgs = prepkgs.j.nixpkgset;
            channel = prepkgs.j.channels;
            host = attrs.hosts;
            # system = allSystems;
            system = [ "aarch64-linux" "x86_64-linux" ];
            # system = defaultSystems;
        } // (genAttrs (attrNames attrs.integer-defaults) (attr: range 0 1));
        all = let
            sc = {
                all = all';
                inheritance.pkgs = import nixpkgs {};
            };
        in {
            config = fas (recursiveUpdate sc {
                func = j.config;
                inheritance.stdenvs = all.stdenv;
            });
            hostName = fas {
                all = all';
                func = j.hostName;
                attrList = attrs.stc ++ (toList "host");
            };
            overlays = fas {
                all = all';
                func = make.overlay;
            };
            pkgs = fas {
                all = all';
                func = make.pkgs;
            };
            stdenv = fas (recursiveUpdate sc { func = j.stdenv; });
            hmConfigs = fas {
                all = all';
                func = j.hostName;
                inherit (all.vars) extraListSets;
            };
            vars = {
                extraListSets = {
                    user = attrs.allUsers;
                } // (genAttrs attrs.home-manager-integer-defaults (attr: range 0 1));
            };
        } // all';

        overlays =  j.get { stc = attrs.default-stc; set = all.overlays; };

    in with lib; with j; {

        inherit overlays lib;

        legacyPackages = all;

        nixosConfigurations = forAllSystems' {
            inherit all;
            func = make.nixosConfiguration;
        };

        # From: https://nixos.wiki/wiki/Flakes#Getting_Instant_System_Flakes_Repl
        nix.nixPath = let path = toString ./.; in [ "repl=${path}/repl.nix" "nixpkgs=${sources.nixpkgs}" ];

    } // (eachSystem all.system (system: {  }));

}
#+end_src

***** inputs

#+name: ff
#+begin_src emacs-lisp :var name="" :var ur=""
(format-spec "%n = {
    url = \"github:%u\";
    flake = false;
};" `((?n . ,name) (?u . ,ur)))
#+end_src

#+call: hash("")

#+RESULTS:
: da5fe3496669eea2dcae419277ad3927

#+name: da5fe3496669eea2dcae419277ad3927
#+begin_src nix :exports none
<<1ec89530455a22dd615fef7bcc833129>>
<<c5166e5f5e4c4cc5aa86a74ab5790120>>
<<7838098bf5241e080fc8c4f9bbe060f5>>
<<7461570ae52d935de8ba8b2f3c302192>>
<<90806cf21053b8c9c0b3da27fd374329>>
<<afedeb2f54e96f9a6beedcf19ece0d42>>
<<d51a5c8bfac4ed3d6a289147d52ec8e1>>
#+end_src

****** base

#+call: hash("")

#+RESULTS:
: 1ec89530455a22dd615fef7bcc833129

#+name: 1ec89530455a22dd615fef7bcc833129
#+begin_src nix
home-manager-flake = {
    url = "github:nix-community/home-manager/master";
    inputs.nixpkgs.follows = "nixpkgs";
};

impermanence-flake = {
    url = "github:nix-community/impermanence/master";
    inputs.nixpkgs.follows = "nixpkgs";
};

agenix = {
    url = "github:ryantm/agenix/master";
    inputs.nixpkgs.follows = "nixpkgs";
};

flake-utils = {
    url = "github:numtide/flake-utils/master";
    inputs.nixpkgs.follows = "nixpkgs";
};

hlissner = {
    url = "github:hlissner/dotfiles/master";
    inputs.nixpkgs.follows = "nixpkgs";
};

<<ff(name="flake-compat", ur="edolstra/flake-compat")>>

nixpkgs.url = "github:NixOS/nixpkgs/master";
#+end_src

****** tmux

#+call: hash("")

#+RESULTS:
: c5166e5f5e4c4cc5aa86a74ab5790120

#+name: c5166e5f5e4c4cc5aa86a74ab5790120
#+begin_src nix
<<ff(name="aleclearmind", ur="aleclearmind/nested-tmux")>>
<<ff(name="oh-my-tmux", ur="gpakosz/.tmux")>>
<<ff(name="powerline", ur="powerline/powerline")>>
<<ff(name="tpm", ur="tmux-plugins/tpm")>>
#+end_src

****** editors

#+call: hash("")

#+RESULTS:
: 7838098bf5241e080fc8c4f9bbe060f5

#+name: 7838098bf5241e080fc8c4f9bbe060f5
#+begin_src nix
<<ff(name="doom-emacs", ur="hlissner/doom-emacs")>>
<<ff(name="spacevim", ur="spacevim/spacevim")>>
#+end_src

****** shell

#+call: hash("")

#+RESULTS:
: 7461570ae52d935de8ba8b2f3c302192

#+name: 7461570ae52d935de8ba8b2f3c302192
#+begin_src nix
<<ff(name="bashCompletions", ur="scop/bash-completion")>>
<<ff(name="grml", ur="grml/grml-etc-core")>>
#+end_src

****** terminal

#+call: hash("")

#+RESULTS:
: 90806cf21053b8c9c0b3da27fd374329

#+name: 90806cf21053b8c9c0b3da27fd374329
#+begin_src nix
<<ff(name="kittyThemes", ur="dexpota/kitty-themes")>>
<<ff(name="xeroFigletFonts", ur="xero/figlet-fonts")>>
#+end_src

****** nixos

#+call: hash("")

#+RESULTS:
: afedeb2f54e96f9a6beedcf19ece0d42

#+name: afedeb2f54e96f9a6beedcf19ece0d42
#+begin_src nix
<<ff(name="extraContainer", ur="erikarvstedt/extra-container")>>
<<ff(name="nixos-surface", ur="anthe/nixos-surface")>>
#+end_src

****** kernels

#+call: hash("")

#+RESULTS:
: d51a5c8bfac4ed3d6a289147d52ec8e1

#+name: d51a5c8bfac4ed3d6a289147d52ec8e1
#+begin_src nix
xanmodV5104Cacule = {
    url = "github:xanmod/linux/5.10.4-xanmod1-cacule";
    flake = false;
};
xanmodV5914Cacule = {
    url = "github:xanmod/linux/5.9.14-xanmod1-cacule";
    flake = false;
};
#+end_src

**** lib

#+call: hash("")

#+RESULTS:
: ee56d4a974b19cdf64e1e8f02e47ccaa

#+name: ee56d4a974b19cdf64e1e8f02e47ccaa
#+begin_src nix
allowUnfree = true;
allowBroken = true;
allowUnsupportedSystem = true;
# preBuild = ''
#     makeFlagsArray+=(CFLAGS="-w")
#     buildFlagsArray+=(CC=cc)
# '';
permittedInsecurePackages = [
    "python2.7-cryptography-2.9.2"
];
#+end_src

***** default.nix

With help from [[Henrik Lissner / hlissner][https://github.com/hlissner/dotfiles]]:

#+call: hash("")

#+RESULTS:
: 7415044e41c4923b87ec041b1f78173b

#+name: 7415044e41c4923b87ec041b1f78173b
#+begin_src nix :tangle (jr/tangle-oreo)
inputs@{
    sources ? ({
        nixpkgs = <nixpkgs>;
    }),
    pkgs ? (import sources.nixpkgs {}),
    lib ? pkgs.lib,
    preattrs ? (import ./_preattrs.nix lib),
    prelib ? (import ./_prelib.nix preattrs lib),
    primprelib ? (import ./_primprelib.nix preattrs prelib lib),
    ...
}: with builtins; with lib; let
    templib = self: prelib
        // (with prelib; {
            attrs = preattrs // (import ./_attrs.nix (inputs // { inherit preattrs primprelib; }));
            imprelib = primprelib // (import ./_imprelib.nix (inputs // { inherit primprelib; }));
        })
        // (listToAttrs (map (file: nameValuePair
            file
            (import (./. + "/${file}.nix") inputs)
        ) (primprelib.listNames { dir = ./.; })));

    __ = makeExtensible templib;
in __.extend (final: prev: prelib.foldToSet (attrValues prev))
#+end_src

***** _preattrs.nix

#+call: hash("")

#+RESULTS:
: 218fdf4ae891826e566d02e51d8f323b

#+name: 218fdf4ae891826e566d02e51d8f323b
#+begin_src nix :tangle (jr/tangle-oreo)
lib: with builtins; with lib; rec {
    integer-defaults = {
        minimal = 0;
        musl = 1;
        noSwap = 0;
        terminal = 0;
        zfs = 1;
    };
    default-stc = integer-defaults // {
        system = currentSystem;
        type = "def";
        device = "def";
        channel = "pkgs";
    };
    stc = attrNames default-stc;
    home-manager-integer-defaults = { nixos = 1; };
    home-manager-default-stc = default-stc
        // home-manager-integer-defaults
        // { user = "root"; };
    home-manager-stc = attrNames home-manager-default-stc;
}
#+end_src

***** _prelib.nix

#+call: hash("")

#+RESULTS:
: 67c8aa904c9f23a0cd84d5743c7af83b

#+name: 67c8aa904c9f23a0cd84d5743c7af83b
#+begin_src nix :tangle (jr/tangle-oreo)
preattrs: lib:
with builtins;
with preattrs;
with lib;
rec {

    get = {
        stc ? preattrs.default-stc,
        set,
        ignoredAttrs ? []
    } : getAttrFromPath (
        map toString (attrValues (removeAttrs stc ignoredAttrs))
    ) set;

    hostName = { stc, ... }: substring 0 61 (hashString "sha512" (concatStrings (
        map toString (attrValues stc)
    )));

    forAllSystems' = {
        func,
        all,
        extraListSets ? {},
        attrList ? preattrs.stc,
        inheritance ? {}
    } : let
        all' = (filterAttrs (n: v: elem n (flatten [
            attrList
            [ "host" ]
        ])) all) // extraListSets;
        product = cartesianProductOfSets all';
    in listToAttrs (map (
        stc: nameValuePair (hostName { inherit stc; }) (func ({ inherit stc; } // inheritance))
    ) product);

    forAllSystems = {
        func,
        all,
        extraListSets ? {},
        attrList ? preattrs.stc,
        inheritance ? {}
    } : let
        all' = (filterAttrs (n: v: elem n attrList) all) // extraListSets;
        product = cartesianProductOfSets all';
    in foldToSet (map (
        # !!! There is no need to alphabetically sort the output of attrValues! !!!
        stc: setAttrByPath
            (map toString (attrValues stc))
            (func ({ inherit stc; } // inheritance))
    ) product);

    # TODO: Why is the filter necessary?
    foldToSet = list: foldr (new: old: recursiveUpdate new old) {} (filter (item: isAttrs item) list);

    myIf = {
        list = condition: value: optionals condition value;
        singleton = condition: value: optional condition value;
        set = condition: value: if condition then value else {};
        num = condition: value: if condition then value else 0;
        knull = condition: value: if condition then value else null;
        empty = condition: value: if condition then value else "";
        drv = condition: evalue: value: if condition then value else evalue;
    };

    zipToSet = names: values: listToAttrs (
        map (nv: nameValuePair nv.fst nv.snd) (let hasAttrs = any isAttrs values; in zipLists (
            if hasAttrs then names else (sort lessThan names)
        ) (
            if hasAttrs then values else (sort lessThan values)
        ))
    );

    stdenv = {
        pkgs,
        stc ? ({ system = currentSystem; musl = 1; }),
        ...
    }: with stc; let
        musl = stc.musl == 1;
        arm = {
            systems = [
                "armv7l-linux"
                "aarch64-linux"
            ];
            enable = elem system arm.systems;
            stdenv = {
                package = pkgs.clang10.stdenv;
                targetPlatform = if "armv7l-linux" then systems.examples.armv7l-hf-multiplatform
                    else systems.examples.aarch64-multiplatform;
            };
        };
        musl' = {
            enable = musl && (elem system ([
                "x86_64-linux"
            ] ++ arm.systems));
            stdenv = {
                package = pkgs.musl.stdenv;
                targetPlatform = systems.examples.musl64;
            };
        };
    in foldToSet [
        {
            inherit system;
            hostPlatform = currentSystem;
            buidPlatform = currentSystem;
        }
        (with arm; myIf.set enable stdenv)
        (with musl'; myIf.set enable stdenv)
    ];

    config = {
        pkgs,
        stc ? ({ system = currentSystem; musl = 1; }),
        buildEnvOvr ? true,
        stdenvs ? {},
        stdenv ? (attrByPath (attrValues stc) (stdenv { inherit pkgs stc; }) stdenvs),
        ...
    } : with stc; {
        inherit system;
        <<ee56d4a974b19cdf64e1e8f02e47ccaa>>
        ${if buildEnvOvr then null else "buildEnv"} = {
            override = { inherit stdenv; };
        };
    };

    toCapital = string: concatImapStrings (
        i: v: if (i == 0) then (toUpper v) else v
    ) (stringToCharacters string);

    generatePersistentFD = filtered: persistentDirectory: let
        _ = type: filter (n: !elem n filtered) (
            mapAttrsToList (n: v: removePrefix persistentDirectory n)
        (filterAttrs (n: v: v == type) (readDir persistentDirectory)));
    in { directories = _ "directories"; files = _ "regular"; };

    sequence = list: end: foldr (a: b: deepSeq a b) end list;
}
#+end_src

***** _primprelib.nix

#+call: hash("")

#+RESULTS:
: dee6dcfbb1931e148059399abb661232

#+name: dee6dcfbb1931e148059399abb661232
#+begin_src nix :tangle (jr/tangle-oreo)
preattrs: prelib: lib:
with builtins;
with preattrs;
with prelib;
with lib;
rec {
    args = {
        suffix = "";
        ignores = [];
    };

    name = {
        suffix ? args.suffix,
        noSuffix ? suffix == "",
        file
    }: removeSuffix (if noSuffix then ".nix" else suffix) (baseNameOf (toString file));

    # !!! This returns a function
    filterFunc = {
        suffix ? args.suffix,
        noSuffix ? suffix == "",
        ignores ? args.ignores,
        dir,
    }: let
        _ignores = flatten [
            ignores
            (let
                _ignores' = (/. + "/${unsafeDiscardStringContext dir}/_ignores.nix");
            in if (pathExists _ignores') then (import _ignores') else [])
            [ "default" "deprecated" ]
        ];
    in file: value:
        (if noSuffix then (
            (hasSuffix ".nix" file) || (value == "directory")
        ) else (hasSuffix suffix file)) &&
        (!hasPrefix "_" file) &&
        (!elem (name { inherit suffix file noSuffix; }) _ignores);

    contents = _args@{
        suffix ? args.suffix,
        ignores ? args.ignores,
        dir,
    }: filterAttrs (filterFunc _args) (readDir dir);

    list = _args@{
        suffix ? args.suffix,
        ignores ? args.ignores,
        dir,

        # !!! This cannot be integrated into the "args" set above, due to "dir" then being permanently set !!!
        func ? (n: v: dir + "/${n}"),

    }: let
        __args = removeAttrs _args [ "func" ];
    in mapAttrsToList func (contents __args);

    listNames = {
        suffix ? args.suffix,
        ignores ? args.ignores,
        dir
    }: list {
        inherit suffix ignores dir;
        func = (n: v: name { inherit suffix; file = n; });
    };
}
#+end_src

***** _attrs.nix

#+call: hash("prenix")

#+RESULTS:
: 4f8559fab44b31eee3bd94b54447bea2

#+name: 4f8559fab44b31eee3bd94b54447bea2
#+begin_src conf
keep-derivations = true
keep-outputs = true
experimental-features = nix-command flakes
allow-unsafe-native-code-during-evaluation = true
#+end_src

#+call: hash("")

#+RESULTS:
: fae48c3c1376c250513d68afedbb6450

#+name: fae48c3c1376c250513d68afedbb6450
#+begin_src nix :tangle (jr/tangle-oreo)
{ lib, preattrs, primprelib, ... }:
with builtins;
with preattrs;
with primprelib;
with lib;
rec {
    persistent = {
        files = {
            system = flatten [[ "/etc/host" ]];
            home = flatten [[
                ".emacs-profile"
                ".gitignore"
                ".nix-channels"
                ".python-history"
                ".viminfo"
                ".zsh-history"
                "README.org"
                "LICENSE"
            ]];
            cache = flatten [[  ]];
        };
        directories = {
            system = flatten [[
                "/etc/containers"
                "/etc/NetworkManager/system-connections"
                "/etc/nix"
                "/etc/nixos"
                "/etc/nixos/config"
                "/etc/ssh"
                "/etc/wireguard"
                "/var/lib/acme"
                "/var/lib/bluetooth"
            ]];
            home = flatten [[
                ".atom"
                ".bash-history"
                ".byobu"
                ".config"
                ".linuxbrew"
                ".local"
                ".mozilla"
                ".peru"
                ".pki"
                ".vim_runtime"
                ".virtualenvs"
                ".vscode-oss"
                ".vscode"
                ".yubico"
                "Documents"
                "Downloads"
                "etc"
                "inca"
                "keybase"
                "Music"
                "nix-plugins"
                "Pictures"
                "Public"
                "Templates"
                "Videos"
                users.primary
            ]];
            cache = flatten [(map (dir: ".cache/${dir}") [
                "flatpak"
                "gnome-software"
                "google-chrome-beta"
                "google-chrome-dev"
                "google-chrome"
                "Homebrew"
                "keybase"
                "mozilla"
                "nix"
                "pip"
                "pypoetry"
                "qtile"
                "starship"
                "vivaldi"
            ])];
        };
    };

    persistence = {
        system = extraFD: let persistent-directory = "/persist"; in {
            "${persistent-directory}" = mkMerge [
                ({
                    directories = persistent.directories.system;
                    files = persistent.files.system;
                })
                (generatePersistentFD [ "home" "cache" ] persistent-directory)
                extraFD
            ];
        };
        home = { user ? "root", extraCache ? {}, extraFD ? {}}: let
            phu = "/persist/home/${user}";
        in mapAttrs (n: v: v // { allowOther = true; }) {
            "/persist/cache/${user}" = foldToSet [
                ({
                    directories = persistent.directories.cache;
                    files = persistent.files.cache;
                })
                extraCache
            ];
            "${phu}" = foldToSet [
                ({
                    directories = persistent.directories.home;
                    files = persistent.files.home;
                })
                (generatePersistentFD [""] phu)
                extraFD
            ];
        };
    };

    link = root: source: listToAttrs (map (
        fd: nameValuePair "${root}/${fd}" {
            source = "${source}/${fd}";
            recursive = true;
        }
    ) (attrNames (readDir source)));

    # Device Types
    types = flatten [
        (listNames { dir = ../devices; })
        [ "def" ]
    ];

    devices = [
        "4b"
        "3b"
        "pro"
        "b2"
        "def"
    ];

    hosts = listNames { dir = ../configs; };

    # hosts = listToAttrs (flatten [
    #     (map (host: nameValuePair host {}) [
    #         # "bastion"
    #         "chimchar"
    #         # "fell"
    #         # "flipper"
    #         # "infernape"
    #         # "monferno"
    #         # "murasame"
    #         # "p20"
    #         # "p5"
    #         # "piplup"
    #         # "sandshrew"
    #         "sandslash"
    #         # "siluam"
    #         # "silvester"
    #     ])
    # ]);

    configs = rec {
        prenix = ''
            <<4f8559fab44b31eee3bd94b54447bea2>>
        '';
        nix = let
            MG = size: let
                mg = stringToCharacters size;
            in toString ((toInt (elemAt mg 0)) * (
                if (elemAt mg 1 == "M") then 1 else 1024
            ) * 1024 * 1024);
        in prenix + ''
            min-free = ${MG "250M"}
            max-free = ${MG "1G"}
        '';
    };
    services = {
        base = {
            enable = true;
            serviceConfig = {
                Restart = "on-failure";
                User = "shadowrylander";
            };
            wantedBy = [ "multi-user.target" ];
        };
        mkdir = path: "mkdir -p /persist/${path} &> /dev/null";
    };
    users = fromJSON (readFile ../resources/users.json);
    excludedUsers = [ "root" ];
    mainUsers = attrValues users;
    allUsers = mainUsers ++ excludedUsers;
    homes = listToAttrs (map (
        user: nameValuePair user "/home/${user}"
    ) mainUsers);
    allHomes = homes // { root = "/root"; };
    commands = {
        rebuild = "nixos-rebuild --impure";
        install = "nixos-install --impure --show-trace";
    };
    fileSystems = {
        base = {
            fsType = "zfs";
            options = [ "defaults" "x-systemd.device-timeout=5" "nofail" ];
        };
        supported = [ "zfs" "xfs" "btrfs" "ext4" "fat" "vfat"  ];
    };
    versions = {
        python = "39";
        emacs = "26";
    };
    ssh.keys = {
        master = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDlwBJ7E2qeqw9kMW19indbeLdnEKs/Yrhn9HE0c/gZDzvXYBPQYyf5xr9I9kYxWcHlqp7XEI0LVT4DCA/mgemQtM8ulc1mxwekKtk64uWRi5wLi1E17NWKJfXWRn8XZejwi0iJa0twwVE8m8G2AuFOCSa86sYD3x5X5W+7spAuNET7kl0DLueUHu1u31c7HE1ciV2tIn/f60/bbgEJm9MPcRVZkRxkp+bouaZ1cjWRYDhvyJS30DRhBYtIIort2XVAshQs2Y58oKeCDnjt0gxotfqqWlt4nTQzKtbSN2M6/M+clFQBdT1oUJqpTUJbVxK8+xSEOJcBubupTj0USpmftDf/3WMoMwq+hNEc9C0EN1BYtKk68QWhAz8NROvnx7h6y3UKejhQOg0ueNZggmeNJLbebEs46QmA92khO8zc2pfBRsEa5yP0IgdvWpruTZ1QwjqhGQqGnCw3Oli1PK+5zgT2vXy5yHl3f3duPq8h+LOc+lSBbi2jjkC0gwTQDDDNyzFZ+U9xF7fCmL3V8DCEeO/4HqVxmLJir2TVEDo/3Ug/Q22Yp7P2EZrI2pikZIyBJc5aZJO3d7nGoDB/1BJp9Qm82wvyEpjiOnxHsL4osUqrf401XbiwNqpFkVUoRZkwGraJnrlsYkdHS2Mrrny9sr+PtgZhTjqIuW8z6iVIfQ== titaniumfiles@outlook.com";
    };
    platforms = {
        arm = [ "aarch64-linux" "armv7l-linux" "armv6l-linux" ];
        imd = [ "i686-linux" "x86_64-linux" ];
    };
}
#+end_src

***** paths.nix

#+call: hash("")

#+RESULTS:
: f91c0d27c14d4f8930db2234747ec9dc

#+name: f91c0d27c14d4f8930db2234747ec9dc
#+begin_src nix :tangle (jr/tangle-oreo)
{ sources, ... }: with builtins; rec {
    nixos = toString (./. + "/..");
    lib = "${nixos}/lib";
    extras = "${nixos}/extras";
    configs = "${nixos}/configs";
    modules.flakes = "${nixos}/flake_modules";
    global = "${nixos}/global";
    patches = {
        _  = "${nixos}/patches";
        surface = "${sources.nixos-surface}/linux-surface/patches";
    };
}
#+end_src

***** _imprelib.nix

#+call: hash("")

#+RESULTS:
: 445fa1f5b80d0f6437d4b366f304bc6f

#+name: 445fa1f5b80d0f6437d4b366f304bc6f
#+begin_src nix :tangle (jr/tangle-oreo)
{ lib, primprelib, ... }:
with builtins;
with primprelib;
with lib;
rec {
    set = _args@{
        suffix ? args.suffix,
        ignores ? args.ignores,
        dir,
        modules ? {},

        # !!! This cannot be integrated into the "args" set above, due to "dir" then being permanently set !!!
        func ? (n: v: dir + "/" + n),

    }: let
        files = list (filterAttrs (arg: v: !elem arg [ "modules" "self" ]) _args);
    in zipToSet
        (map (file: name { inherit suffix file; }) files)
        (map (file: import file (foldToSet [ modules inputs ])) files);
}
#+end_src

**** modules
***** bcachefs.nix

#+call: hash("")

#+RESULTS:
: a796b1296ba0c7f4a66ce7467b7afe59

#+name: a796b1296ba0c7f4a66ce7467b7afe59
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, pkgs, lib, ... }: with builtins; with lib; with j; let b = "bcachefs"; in {
    boot = {
        kernelPackages = mkForce pkgs."linuxPackages_testing_${b}";
        kernelModules = [ b ];
        initrd = {
            kernelModules = [ b ];
            availableKernelModules = [ b ];
        };
        supportedFilesystems = [ "bcachefs" ];
    };
}
#+end_src

***** boot.nix

#+call: hash("loader")

#+RESULTS:
: c0328b5b40730a0936ba5b5b494421a9

#+name: c0328b5b40730a0936ba5b5b494421a9
#+begin_src nix
loader = {
    systemd-boot = {
        enable = mkForce config.vars.bootPart;
        configurationLimit = 25;
        editor = false;
    };
    grub = {
        enable = mkForce false;
        efiSupport = true;
        devices = [ "nodev" ];
        version = 2;

        # TODO: Get more options
        extraEntries = ''
            menuentry "Reboot" { reboot }
            menuentry "Poweroff" { halt }
        '';

    };
    efi = {
        canTouchEfiVariables = mkForce true;
        efiSysMountPoint = "/boot/efi";
    };
    timeout = 10;

    # Used for Bedrock Linux
    initScript.enable = mkFroce true;
};
#+end_src

#+call: hash("")

#+RESULTS:
: a741daba47568ef930a9860652930bed

#+name: a741daba47568ef930a9860652930bed
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    boot = let
        p = attrs.users.primary;
        pHome = config.users.users.${p}.home;
    in mkMerge [{
            <<c0328b5b40730a0936ba5b5b494421a9>>
            supportedFilesystems = attrs.fileSystems.supported;
            initrd = {
                inherit (config.boot) supportedFilesystems;
                compressor = "${lib.getBin pkgs.zstd}/bin/zstd";
            };
            postBootCommands = let
                chowned = concatStringsSep "\n" (
                    map (user:
                        "sudo -u ${user} chown -R ${user}:${user} /persist/${attrs.allHomes.${user}} /persist/cache/${user}")
                    attrs.allUsers);
            in mkAfter (''
                mkdir -p /mnt
                sudo -u ${p} chown -R ${p}:${p} /${host}
            '' + chowned);
        }
        (mkIf (!config.vars.minimal) {
            extraModprobeConfig = '' options kvm_intel_nested=1 '';
        })
    ];
}
#+end_src

***** console.nix

#+call: hash("")

#+RESULTS:
: 92ac647bd78a14f38ebb0cd944903507

#+name: 92ac647bd78a14f38ebb0cd944903507
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; {
    console = {
        # Select internationalisation properties.
        # font = lib.mkDefault "${terminus_font}/share/consolefonts/ter-u28n.psf.gz";
        font = "Cartograph CF Light Italic";
        keyMap = "us";
    };
}
#+end_src

***** etc.nix

#+call: hash("")

#+RESULTS:
: 0fa3e0c1eb2ddb98d1de605ae7d805dc

#+name: 0fa3e0c1eb2ddb98d1de605ae7d805dc
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    environment.etc = let
        kata-containers = {
            default-runtime = "kata-runtime";
            # runtimes.kata-runtime.path = "${getBin pkgs.kata-containers}/bin/kata-runtime";
            runtimes.kata-runtime.path = "${getBin pkgs.kata-containers.runtime}/bin/kata-runtime";
        };
        kc = toJSON kata-containers;
    in {
        "nix/nix.conf".text = attrs.configs.nix;
        "containers/storage.conf".text = kc + ''
            [storage]
            driver = "zfs"
            rootless_storage_path = "/var/lib/podman/$USER"

            [storage.options]
            additionalimagestores = [
                "/var/lib/docker",
            ]

            # [storage.options.zfs]
        '';
        "containers/libpod.conf".text = kc;
        "docker/daemon.json".text = kc;
    };
}
#+end_src

***** filesystems.nix

#+call: hash("")

#+RESULTS:
: f75c7aea962922162380ecc15061163b

#+name: f75c7aea962922162380ecc15061163b
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; mkIf (config.vars.zfs) { fileSystems = let
    inherit (attrs.fileSystems) base;
    fileSystems' = import ./resources/datasets.nix host;
in mapAttrs' (dataset: mountpoint: nameValuePair mountpoint (
    mkForce (base // { device = dataset; ${
        myIf.knull (hasInfix "persist" dataset) "neededForBoot"
    } = true; })
)) fileSystems'; }
#+end_src

***** global.nix

#+begin_src text
Help is available in the configuration.nix(5) man page
and in the NixOS manual (accessible by running ‘nixos-help’).
#+end_src

#+call: hash("")

#+RESULTS:
: 84e11f81345c124be7b087d5c8c17d6a

#+name: 84e11f81345c124be7b087d5c8c17d6a
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: {
    nixpkgs = nixpkgset;
    i18n = {
        # Select internationalisation properties.
        defaultLocale = "en_US.UTF-8";
    };
    time.timeZone = "America/Toronto";
    system = {
        # This value determines the NixOS release from which the default
        # settings for stateful data, like file locations and database versions
        # on your system were taken. It‘s perfectly fine and recommended to leave
        # this value at the release version of the first install of this system.
        # Before changing this value read the documentation for this option
        # (e.g. man configuration.nix or on https://nixos.org/nixos/options.html).
        # stateVersion = "20.09"; # Did you read the comment?
        autoUpgrade = {
            enable = true;
            allowReboot = false;
            flake = https://github.com/nixos/nixpkgs/archive/master.tar.gz;
        };
    };
    boot.binfmt.emulatedSystems = [
        "armv7l-linux"
        "aarch64-linux"
    ];

    # Flatpak
    xdg.portal.enable = true;

    environment.pathsToLink = [ "/share/nix-direnv" ];
    zramSwap = {
        enable = true;
        algorithm = "zstd";
    };
}
#+end_src

***** hardware.nix

#+call: hash("")

#+RESULTS:
: 3ae0b13c8f587784975d67a4717c20d8

#+name: 3ae0b13c8f587784975d67a4717c20d8
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; {
    hardware = {
        enableRedistributableFirmware = lib.mkDefault true;
        # Enable sound
        pulseaudio.enable = true;
    };
    sound.enable = true;
}
#+end_src

***** home.nix

#+call: hash("")

#+RESULTS:
: baefabe5722e89e236e4925fa4c88af2

#+name: baefabe5722e89e236e4925fa4c88af2
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; {
    # home-manager.users = let
    #     stc = {}
    #     inherit (config.vars) nixos zfs;
    # in listToAttrs (map (user: nameValuePair user (import /root/.config/nixpkgs/home.nix nixos zfs stc)) attrs.allUsers);
}
#+end_src

***** kernel.nix

#+call: hash("")

#+RESULTS:
: 1f6b4bbf4b1e571f3b746ff11b294b91

#+name: 1f6b4bbf4b1e571f3b746ff11b294b91
#+begin_src nix :tangle (jr/tangle-oreo)
boot = {
    # kernelPackages = pkgs.linuxPackages_latest_xen_dom0_hardened;
    # kernelPackages = pkgs."linuxPackages_xanmod_v5.10.4_cacule";
    kernelPackages = pkgs.linuxPackages_lqx;
    # kernelPackages = pkgs.linuxPackages_zen;
    kernelPatches = [
        # { name = "clear"; patch = ./patches/0110-initialize-ata-before-graphics.patch; }
        {
            name = "Enable ZSTD Compression";
            patch = null;
            extraConfig = ''
                RD_ZSTD y
                KERNEL_ZSTD y
                KERNEL_XZ n
            '';
        }
    ];
    # extraModulePackages = with config.boot.kernelPackages; [ anbox wireguard ];
};
#+end_src

***** memory.nix

Set the =SWAP= device if:

1. The configuration is not minimal, or
2. the =noSwap= variable is set to false.

I am currently not using =SWAP= on =ZFS Zvols= due to the issues detailed
[[https://github.com/openzfs/zfs/issues/7734][here]].

#+call: hash("")

#+RESULTS:
: da58947ae8facffd0bc1115d35641080

#+name: da58947ae8facffd0bc1115d35641080
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; mkIf (
    config.vars.minimal -> config.vars.noSwap
) { swapDevices = [{ device = "/dev/zvol/${host}/swap"; }]; }
#+end_src

***** networking.nix

#+call: hash("")

#+RESULTS:
: 8c1c76e68a6ad327be798ea5c62a7fc1

#+name: 8c1c76e68a6ad327be798ea5c62a7fc1
#+begin_src nix
{ config, lib, hostName, ... }: with builtins; with lib; with j; {
    networking = let
        primus = "58a4bafc38c2cc6e91ba27c7f1ca910c8fba857ee02f03648450b963db2519fc";
    in {
        inherit hostName;
        wireless = {
            enable = true; # Enables wireless support via wpa_supplicant.
            networks = {
                "Primus-17FE-2.4" = {
                    pskRaw = primus;
                    priority = 0;
                };
                "Primus-17FE" = {
                    pskRaw = primus;
                    priority = 1;
                };
            };
        };
        networkmanager.enable = false;

        # The global useDHCP flag is deprecated, therefore explicitly set to false here.
        # Per-interface useDHCP will be mandatory in the future, so this generated config
        # replicates the default behaviour.
        useDHCP = false;

        # Configure network proxy if necessary
        # proxy = {
        # default = "http://user:password@proxy:port/";
        # noProxy = "127.0.0.1,localhost,internal.domain";
        # };

        # Open ports in the firewall.
        # firewall = {
        # allowedTCPPorts = [ ... ];
        # allowedUDPPorts = [ ... ];

        # Or disable the firewall altogether.
        # enable = false;
        # };

        # wireguard.interfaces.wg0 = {
        #   generatePrivateKeyFile = true;
        #   privateKeyFile = "/persist/etc/wireguard/wg0";
        # };
    };
}
#+end_src

***** nix.nix

#+call: hash("")

#+RESULTS:
: c0cedf33f5b5d915586e1ff9899331b0

#+name: c0cedf33f5b5d915586e1ff9899331b0
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; {
    nix = rec {
        gc = foldToSet [
            { automatic = true; }
            { dates = "monthly"; }
            # {
            # 	dates = "monthly";
            # 	options = "-d";
            # }
            # {
            # 	dates = "daily";
            # 	options = "--delete-older-than 30d";
            # }
        ];
        optimise = {
            automatic = true;
            dates = [ "05:00" ];
        };
        autoOptimiseStore = true;
        extraOptions = attrs.configs.nix;
        useSandbox = true;
        binaryCaches = flatten [
            (map (dir: "file:///${dir}/") [
                "chimchar"
                "empoleon"
            ])
        ];
        # sandboxPaths = [];
    };
}
#+end_src

***** packages.nix

#+call: hash("")

#+RESULTS:
: 150fb2f9ed97ee98bfb4c13d444892d0

#+name: 150fb2f9ed97ee98bfb4c13d444892d0
#+begin_src nix :tangle (jr/tangle-oreo)
inputs@{ config, pkgs, sources, lib, ... } : { environment.systemPackages = import ../packages.nix inputs; }
#+end_src

***** persistence.nix

#+call: hash("")

#+RESULTS:
: a83c0f0caee15a1e432a618311cfb94f

#+name: a83c0f0caee15a1e432a618311cfb94f
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; {
    environment.${myIf.knull config.vars.zfs "persistence"} = attrs.persistence.system {};
}
#+end_src

***** power.nix

#+call: hash("")

#+RESULTS:
: 6be210bd87996e57ea0297c46c5b432b

#+name: 6be210bd87996e57ea0297c46c5b432b
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; {
    services.logind.lidSwitch = "hybrid-sleep";
    powerManagement = {
        enable = true;
        cpuFreqGovernor = mkForce "powersave";
    };
}
#+end_src

***** security.nix

This is mostly for Yubikey Authentication:

#+call: hash("")

#+RESULTS:
: 758b0e4461401df04a7c98e6aee9c027

#+name: 758b0e4461401df04a7c98e6aee9c027
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; {
    # For Yubikey SSH-GPG Authentication
    environment.shellInit = ''
        export GPG_TTY="$(tty)"
        gpg-connect-agent /bye
        export SSH_AUTH_SOCK="/run/user/$UID/gnupg/S.gpg-agent.ssh"
        echo UPDATESTARTUPTTY | gpg-connect-agent
    '';
    programs = {
        # Some programs need SUID wrappers, can be configured further or are
        # started in user sessions.
        # mtr.enable = true;
        gnupg.agent = {
            enable = true;
            enableSSHSupport = false;
            pinentryFlavor = "curses";
        };

        # For use with Yubikey SSH-GPG Authentication, set to false
        ssh.startAgent = true;
    };
    security.pam = {
        yubico = {
            enable = true;
            debug = true;
            mode = "challenge-response";
        };
        enableSSHAgentAuth = true;
    };
}
#+end_src

***** services.nix

#+call: hash("sanoid")

#+RESULTS:
: 6b796fbba5d593b48cdc5c6eadab9b65

#+name: 6b796fbba5d593b48cdc5c6eadab9b65
#+begin_src nix
${myIf.knull config.vars.zfs "sanoid"} = let
    sanoidBase = {
        useTemplate = [ "base" ];
        recursive = true;
    };
    disabled = { processChildrenOnly = true; };
in {
    enable = true;
    templates."base" = {
        autoprune = true;
        autosnap = true;

        # 6 snapshots an hour
        daily = 144;

        # 2 snapshots a minute
        hourly = 120;

        # 6 snapshots a day for 28 days
        monthly = 168;

        # Twice the weeks in a year
        yearly = 104;
    };

    datasets = listToAttrs (map (dataset: nameValuePair "${host}/${dataset}" sanoidBase) [
        host
        "system/persist"
        "virt"
        "omniverse"
    ]);
};
#+end_src

#+call: hash("syncoid")

#+RESULTS:
: 97c4bebd14fdabfc6ae83b9c0808043e

#+name: 97c4bebd14fdabfc6ae83b9c0808043e
#+begin_src nix
${myIf.knull config.vars.zfs "syncoid"} = let
    syncoidBase = mkMerge [{
        recursive = true;
        commonArgs = [
            "--compress zstd-slow"
            "--no-stream"
            "--no-sync-snap"
            "--create-bookmark"
        ];
        }
        (mkIf vars.encrypted {
            sendOptions = "vvwRI";
            recvOptions = "vvFs";
        })
        (mkIf (!vars.encrypted) {
            recvOptions = "vvFds";
            sendOptions = "vvRI";
        })
    ];
in {
    enable = false;
    sshKey = "/root/.ssh/id_ecdsa";
    commands = listToAttrs (map (dataset: nameValuePair "${host}/${dataset}" (syncoidBase // { target = ""; })) [
        host
        "virt"
        "system/persist"
        "omniverse"
    ]);
};
#+end_src

#+call: hash("")

#+RESULTS:
: 5aecf05c58be2fe47ff406f3fdb2a823

#+name: 5aecf05c58be2fe47ff406f3fdb2a823
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    services = {
        <<6b796fbba5d593b48cdc5c6eadab9b65>>

        <<97c4bebd14fdabfc6ae83b9c0808043e>>

        wakeonlan.interfaces = map (interface:
            { inherit interface; method = "magicpacket"; }
        ) (attrNames config.networking.interfaces);

        flatpak.enable = true;

        # For Yubikey
        udev.packages = with pkgs; [
            yubikey-personalization
            libu2f-host
        ];
        pcscd.enable = true;

        openssh = {
            enable = true;
            extraConfig = mkOrder 0 ''
            TCPKeepAlive yes
            ClientAliveCountMax 480
            ClientAliveInterval 3m
            '';
            permitRootLogin = "yes";
        };

        # Keybase
        kbfs.enable = true;
        keybase.enable = true;

        # Enable CUPS to print documents.
        printing.enable = true;

        # Enable the X11 windowing system.
        xserver = {
            enable = true;
            layout = "us";
            # xkbOptions = "eurosign:e";
            # Enable touchpad support.
            libinput = {
            enable = true;
            naturalScrolling = true;
            middleEmulation = true;
            tapping = true;
            };
            # synaptics.enable = true;
            desktopManager = { xterm.enable = false; };
            # "${ if (with config.vars; minimal || terminal) then null else "displayManager"}" = { defaultSession = "none+qtile"; };
            # "${ if (with config.vars; minimal || terminal) then null else "displayManager"}" = { startx.enable = true; };
            # "${ if (with config.vars; minimal || terminal) then null else "windowManager"}" = { qtile.enable = true; };
            # "${ if (with config.vars; minimal || terminal) then null else "displayManager"}" = { defaultSession = "none+exwm"; };
            # "${ if (with config.vars; minimal || terminal) then null else "windowManager"}" = { exwm.enable = true; };
            # displayManager = { defaultSession = "none+qtile"; };
            displayManager = { startx.enable = true; };
            windowManager = { qtile.enable = true; };
            # displayManager = { defaultSession = "none+exwm"; };
            # windowManager = { exwm.enable = true; };
            # desktopManager.gnome3.enable = true;
            # desktopManager.gnome3.enable = true;
            # displayManager.gdm.enable = true;
        };

        ${myIf.knull config.vars.zfs "zfs"} = {
            autoScrub.enable = true;

            # Managed by Sanoid
            autoSnapshot.enable = false;
        };
    };
}
#+end_src

***** shell.nix

#+call: hash("")

#+RESULTS:
: 7eb7fea5811e26ec2a492a053e899cf5

#+name: 7eb7fea5811e26ec2a492a053e899cf5
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; {
    programs = {
        xonsh.enable = true;
        fish.enable = true;
        zsh.enable = true;
    };
}
#+end_src

***** specialisation.nix

#+call: hash("base")

#+RESULTS:
: bcfc9f879ab6b1c92ceecdb3462cc32d

#+name: bcfc9f879ab6b1c92ceecdb3462cc32d
#+begin_src nix
{
    patches = {
        dir = rec {
            base = lib.j.paths.patches;
            "57" = "${base.surface}/5.7";
            "58" = "${base.surface}/5.8";
        };
        get = dir: with r; list {
            suffix = ".patch";
            dir = (/. + d);
            func = (file: v: { patch = file; name = name { inherit suffix file; }; });
        };
    };
    base = {
        settings = { inheritParentConfig = true; };
        kernel.extraConfig = ''
            SERIAL_DEV_BUS y
            SERIAL_DEV_CTRL_TTYPORT y
            SURFACE_SAM m
            SURFACE_SAM_SSH m
            SURFACE_SAM_SAN m
            SURFACE_SAM_DTX m
            INPUT_SOC_BUTTON_ARRAY m
            SURFACE_3_POWER_OPREGION m
            SURFACE_3_BUTTON m
            SURFACE_3_POWER_OPREGION m
            SURFACE_PRO3_BUTTON m
        '';
        patches = [
            { patch = /. + "${patches.dir.base._}/export_kernel_fpu_functions_5_3.patch"; name = "export_kernel_fpu_functions_5_3"; }
            { patch = /. + "${patches.dir.base._}/set_power_mgmt.patch"; name = "set_power_mgmt"; }
        ];
        iabg = [{ patch = /. + "${patches.dir.base._}/0110-initialize-ata-before-graphics.patch"; name = "0110-initialize-ata-before-graphics"; }];
    };
}
#+end_src

#+call: hash("")

#+RESULTS:
: 62aabe9c8df8861b6117e855abd978f6

#+name: 62aabe9c8df8861b6117e855abd978f6
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    specialisation = let
        specialisation_base =
            <<bcfc9f879ab6b1c92ceecdb3462cc32d>>;
        inherit (lib.j.paths.patches) _;
        base = {
            specialisation = { inheritParentConfig = true; };
            kernel = {
                kernelPatches = specialisation_base.base.iabg;
            };
        };
    in {
        clear = base.specialisation // {
            configuration = {
                config = {
                    boot = base.kernel // { kernelPackages = pkgs.linuxPackages_latest; };
                };
            };
        };
        zen = base.specialisation // {
            configuration = {
                config = {
                    boot = base.kernel // { kernelPackages = pkgs.linuxPackages_zen; };
                };
            };
        };
        bcachefs = base.specialisation // {
            configuration = {
                config = {
                    boot = base.kernel // {
                        kernelModules = [ "bcachefs" ];
                        initrd = {
                            kernelModules = [ "bcachefs" ];
                            availableKernelModules = [ "bcachefs" ];
                            supportedFilesystems = [ "bcachefs" ];
                        };
                        supportedFilesystems = [ "bcachefs" ];
                    };
                };
            };
        };
        clear_xen = base.specialisation // {
            inheritParentConfig = true;
            configuration = {
                config = {
                    boot = base.kernel // { kernelPackages = pkgs.linuxPackages_latest_xen_dom0; };
                };
            };
        };
    };
}
#+end_src

***** systemd.nix

#+call: hash("")

#+RESULTS:
: 5e996eb2911402ddd75e66eb5df1fc51

#+name: 5e996eb2911402ddd75e66eb5df1fc51
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    systemd = {
        packages = with pkgs; [ runit ly ];
        services = {
            runit.enable = true;
            ly.enable = true;
        };
    };
}
#+end_src

***** users.nix

#+call: hash("")

#+RESULTS:
: 9d513589a6349ecf2f69e7f3a3fd695d

#+name: 9d513589a6349ecf2f69e7f3a3fd695d
#+begin_src nix :tangle (jr/tangle-oreo)
inputs@{ config, lib, pkgs, sources, stc, ... }: with builtins; with lib; with j; {
    users = with attrs.users; let
        base = mkMerge [{
                hashedPassword = "$6$DoC/h6kR66Sa$aZKtTOXAqnan/jAC.4dH9tCYshheiKUZItR4g/kmMMLsfLQh0KslINL9zUTX2IjAZh9DE18eAh1AAz48.n/cm.";
                isNormalUser = true;
                createHome = true;
                extraGroups = [
                    "wheel"
                    "networkmanager"
                    "persist"
                ];
                openssh.authorizedKeys.keys = [
                    attrs.ssh.keys.master
                ];
                packages = import (
                    if (pathExists ../packages.nix) then ../packages.nix else ./packages.nix
                ) inputs;
            }
            (mkIf (!config.vars.minimal) {
                extraGroups = [ "libvirtd" "docker" ];
            })
        ];
    in rec {
        users = mkMerge [
            (genAttrs attrs.allUsers (user: base))
            {
                "${primary}" = {
                    uid = 4362;
                    home = attrs.allHomes.${primary};
                    description = "Jeet Ray";
                    group = primary;
                    extraGroups = [ secondary ];
                    shell = pkgs.xonsh;
                };
                "${secondary}" = {
                    uid = 1111;
                    home = attrs.allHomes.${secondary};
                    description = "Alicia Summers";
                    group = secondary;
                    extraGroups = [ primary ];
                    shell = pkgs.fish;
                };
                "${nightingale}" = {
                    uid = 8888;
                    home = attrs.allHomes.${nightingale};
                    description = "Curtis Nightingale";
                    group = "root";
                    extraGroups = [ primary secondary ];
                    shell = pkgs.zsh;
                };
                root = {
                    shell = mkForce pkgs.xonsh;
                    home = attrs.allHomes.root;
                    isNormalUser = mkForce false;
                    isSystemUser = mkForce true;
                };
            }
        ];

        mutableUsers = false;

        groups = {
            "${primary}" = {
                gid = config.users.users.${primary}.uid;
                members = [ primary secondary nightingale ];
            };
            "${secondary}" = {
                gid = config.users.users.${secondary}.uid;
                members = [ primary secondary nightingale ];
            };
            "${nightingale}" = {
                gid = config.users.users.${nightingale}.uid;
                members = [ nightingale ];
            };
        };
    };
}
#+end_src

***** variables.nix

#+call: hash("options")

#+RESULTS:
: e76b4601025ef4ed0071b29a0161182f

#+name: e76b4601025ef4ed0071b29a0161182f
#+begin_src nix
options = {
    vars = mkOption {
        default = mkDefault {  };
        type = with lib.types; attrsOf bool;
    };
};
#+end_src

#+call: hash("")

#+RESULTS:
: 33c7c54f72f832ea599cfbf1021691f9

#+name: 33c7c54f72f832ea599cfbf1021691f9
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, stc, ... }: with builtins; with lib; with j; {
    <<e76b4601025ef4ed0071b29a0161182f>>
    config.vars = {
        bootPart = mkDefault true;
        syncDevice = mkDefault false;
    } // (mapAttrs (
        n: v: mkDefault (if (isInt v) then (v == 1) else v)
    ) (default-stc // stc));
}
#+end_src

***** virtualisation.nix

#+call: hash("")

#+RESULTS:
: 03ee73c0ac41094064d4eac783592662

#+name: 03ee73c0ac41094064d4eac783592662
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    virtualisation = lib.mkIf (!config.vars.minimal) {
        xen.enable = false;
        lxd = { zfsSupport = true; };
        podman.enable = true;
        docker = {
            enable = true;
            storageDriver = "zfs";
            package = pkgs.docker;
            enableOnBoot = true;
        };
        libvirtd.enable = true;
    };
}
#+end_src

***** zfs.nix

#+call: hash("")

#+RESULTS:
: 43de72c9036fc67563aafc176269d329

#+name: 43de72c9036fc67563aafc176269d329
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; {
    boot = {
        kernelModules = [ "zfs" ];
        # loader.grub.zfsSupport = true;
        initrd = {
            postDeviceCommands = myIf.empty config.vars.zfs (mkAfter ''
                zfs rollback -r ${host}/system/root@blank
                zfs rollback -r ${host}/system/home@blank
            '');
            kernelModules = [ "zfs" ];
            availableKernelModules = [ "zfs" ];
        };
        zfs = {
            requestEncryptionCredentials = true;
            enableUnstable = true;
        };
        extraModulePackages = with config.boot.kernelPackages; [ zfsUnstable ];
    };
    # networking.hostId = substring 0 8 (readFile "/etc/machine-id");
}
#+end_src


**** overlays
***** base

#+call: hash("")

#+RESULTS:
: dc8e809f242cfa0de24ca1a4feb6134f

#+name: dc8e809f242cfa0de24ca1a4feb6134f
#+begin_src nix
let
    sc = { inherit pkgs stc; };
    stdenv = j.stdenv sc;
    config = j.config (sc // { inherit stdenv; });
in flatten [
    [(final: prev: { j = rec {
        inherit config stdenv sources;
        inherit (sources) nixpkgs;
        nixpkgset = 
            let
                withNPrefix = filterAttrs (
                    n: v: (hasPrefix nprefix n) || (n == nprefix)
                ) sources;
                withoutNPrefix = mapAttrs' (name: v: nameValuePair (
                    if (name == nprefix) then prefix else (
                        replaceStrings ["${nprefix}-"] [""] name
                    )
                ) v) withNPrefix;
            in removeAttrs withoutNPrefix (flatten [
                (filter (name: !elem name [
                    "pkgs"
                    "unstable"
                ]) (attrNames withoutNPrefix))
                [  ]
            ]);
        pkgset = (
            mapAttrs (n: v: import v { inherit config; }) nixpkgset
        ) // { "${channel}" = final; };
        channels = attrNames nixpkgset;
    };})]
    # [(
    #     final: prev: {
    #         fetchurl = prev.fetchurl.overrideAttrs (attrs: { patches = attrs.patches ++ [ ../patches/fetchurl.patch ];}); }
    # )]
    # [(
    #     final: prev: {
    #         fetchpypi = prev.fetchpypi.overrideAttrs (attrs: { patches = attrs.patches ++ [ ../patches/fetchpypi.patch ];}); }
    # )]
    [
        (import sources.emacs)
        (final: prev: {
            nur = import sources.nur {
                nurpkgs = prev;
                pkgs = prev;
            };
        })
        (import ("${sources.wip-pinebook-pro}/overlay.nix"))
        # sources.emacs.overlay
        # sources.nur.overlay
    ]
    [
        # (final: prev: { nix = sources.nix.packages.${system}.nix; })
        (final: prev: { nix = (import sources.nix).packages.${system}.nix; })
        (final: prev: { niv = (import sources.niv {}).niv; })
        (final: prev: { emacs-nox = final.emacsGit-nox; })
    ]
    [
        (final: prev: {
            systemd = prev.systemd.overrideAttrs (old: { withHomed = true; });
        })
        (final: prev: {
            kata-containers = prev.kata-containers or (
                prev.callPackage ./_kataContainers.nix {}
            );
        })
    ]
    (
        let
            dir = sources.mozilla;
            mozilla = final: prev: listToAttrs (map (file: nameValuePair
                (removeSuffix "-overlay" file)
                (import "${dir}/${file}.nix" final prev)
            ) (filter (file: hasSuffix "-overlay" file) (j.imprelib.listNames { inherit dir; })));
        in [
            (final: prev: { firefox = final.mozilla.firefox.latest.firefox-bin; })
            (final: prev: { firefox-unbuilt = prev.firefox; })
            (final: prev: { mozilla = mozilla final prev; })
        ]
    )

    # TODO
    # (map (kernel': let
    #     kernel = "linuxPackages_${kernel'}";
    # in [( final: prev: { "${kernel}" = prev."${kernel}".extend (self:
    #     <<ab69b7b5650b908a61c99f5d0b07b92b>>
    # );})]) [ "lqx" "testing_bcachefs" "zen" ])

    # TODO
    # (let base.mach-nix = {
    #     inherit pkgs sources lib;
    #     mach-nix = import sources.mach-nix { inherit pkgs; python = "python39"; };
    # }; in map (overlay: import overlay base.mach-nix) (j.imprelib.list { dir = ./_mach-nix; }))

    (flatten (map (file:
        [(final: prev: {
            "${j.imprelib.name { inherit file; }}" = import file {
                inherit sources pkgs lib;
            };
        })]
    ) (j.imprelib.list { dir = ./.; ignores = [ "nix" ]; })))

    # TODO
    # (
    #     <<624779f89c5c4412effd0af738d38bdc>>
    # )
]
#+end_src

***** overrides

#+call: hash("")

#+RESULTS:
: 89dc592c50565b862b8b7f8585a34890

#+name: 89dc592c50565b862b8b7f8585a34890
#+begin_src nix
let pkgsets' = { unstable = [ "git" "go" "webkitgtk" ]; };
in flatten (mapAttrsToList (
    channel': pkglist: map (
        pkg: [(final: prev: {
            "${pkg}" = if (channel' == channel) then prev.${pkg} else final.j.pkgset.${channel'}.${pkg};
        })]
    ) pkglist
) pkgsets')
#+end_src

***** _mach-nix

#+call: hash("inputs")

#+RESULTS:
: 8ec5744691821b51c17805abe3a39695

#+name: 8ec5744691821b51c17805abe3a39695
#+begin_src nix
{
  sources ? ((import (
        let
            lock = builtins.fromJSON (builtins.readFile ../flake.lock);
        in fetchTarball {
            url = "https://github.com/edolstra/flake-compat/archive/${lock.nodes.flake-compat.locked.rev}.tar.gz";
            sha256 = lock.nodes.flake-compat.locked.narHash;
        }
    ) { src =  ./. + "/.."; }).defaultNix),
  pkgs ? (import sources.nixpkgs {}),
  mach-nix ? (import sources.mach-nix { inherit pkgs; python = "python39"; }),
  ...
}
#+end_src

#+call: hash("extra")

#+RESULTS:
: fd90f4bebcfee78f3ce5049d7270da6c

#+name: fd90f4bebcfee78f3ce5049d7270da6c
#+begin_src nix
packagesExtra = [
    # "https://github.com/psf/requests/tarball/v2.22.0"
    (mach-nix.buildPythonPackage { src = sources.nanite; })      
    "https://files.pythonhosted.org/packages/bc/ab/c49f97516f78c2b0cacb4f45873abc4ca9872942a9c4c19ded8052c8edda/python-wifi-0.6.1.tar.bz2"
];
#+end_src

#+call: hash("providers")

#+RESULTS:
: b32c37f54eb384ffef676ce5785892e6

#+name: b32c37f54eb384ffef676ce5785892e6
#+begin_src nix
providers._defaults = "conda-forge,conda,wheel,sdist,nixpkgs";
#+end_src

#+call: hash("post")

#+RESULTS:
: 60a9ccf457d076fd00a2b7388fb3f993

#+name: 60a9ccf457d076fd00a2b7388fb3f993
#+begin_src emacs-lisp :var pkg="" :var version="" :var pythonPackages=""
(format-spec "
    newPkgs = machnixPy.nixpkgs;
    pythonPackages = newPkgs.python%v.pkgs;
    %p_py_%v = newPkgs.%p.override {
        %q = newPkgs.python%vPackages;
    };
    %p_with_pkgs = %p_py_%v.overrideAttrs (oa: {
        version = \"master\";
        src = sources.%p;
        inherit pythonPath;
    });
    finalOverlay = self: super: { %p = %p_with_pkgs; };
in finalOverlay" `((?p . ,pkg) (?q . ,pythonPackages) (?v . ,version)))
#+end_src

****** qtile.nix

#+call: hash("")

#+RESULTS:
: 90dea894ffe829f2e6306a244e87fa27

#+name: 90dea894ffe829f2e6306a244e87fa27
#+begin_src nix :tangle (jr/tangle-oreo)
<<8ec5744691821b51c17805abe3a39695>>:

with builtins; let

    # build a mach-nix python env
    machnixPy = mach-nix.mkPython {
        <<fd90f4bebcfee78f3ce5049d7270da6c>>
        requirements = ''
        cairocffi
        iwlib
        '';
        _.iwlib.buildInputs.add = [ pkgs.wirelesstools ];
        <<b32c37f54eb384ffef676ce5785892e6>>
        providers.cairocffi = "wheel,sdist";
    };

    pythonPath =
        oa.pythonPath
        ++ machnixPy.selectPkgs pythonPackages
        ++ (with pythonPackages; [
            # From https://github.com/NixOS/nixpkgs/issues/45038
            dateutil
            dbus-python
            keyring
            mpd2
            psutil
            pyxdg
            pygobject3
            nixpkgs
        ]);

<<60a9ccf457d076fd00a2b7388fb3f993(pkg="qtile", version="39", pythonPackages="python37Packages")>>
#+end_src

****** xonsh.nix

#+call: hash("")

#+RESULTS:
: 763dc29c9c55bfc541566514bc8fda66

#+name: 763dc29c9c55bfc541566514bc8fda66
#+begin_src nix :tangle (jr/tangle-oreo)
<<8ec5744691821b51c17805abe3a39695>>:

with builtins; let
    # build a mach-nix python env
    machnixPy = mach-nix.mkPython {
        <<fd90f4bebcfee78f3ce5049d7270da6c>>
        requirements = ''
        # add requirements here
        # jedi
        borgmatic
        dephell
        ply
        prompt_toolkit
        pygments
        pipx
        yubico-client
        ansible

        # add xontribs here
        # xonsh-direnv
        # xonsh-docker-tabcomplete
        # xonsh-vox-tabcomplete
        # xontrib-prompt-bar
        # xontrib-ssh-agent
        xonsh-autoxsh
        xontrib-autojump
        xontrib-fzf-widgets
        xontrib-kitty
        xontrib-pipeliner
        xontrib-powerline2
        xontrib-prompt-vi-mode
        xontrib-readable-traceback
        xontrib-schedule
        xontrib-z
        '';
        <<b32c37f54eb384ffef676ce5785892e6>>
    };

    pythonPath =
        (oa.pythonPath or [])
        ++ machnixPy.selectPkgs pythonPackages
        ++ (with pythonPackages; [
            ply
            prompt_toolkit
            pygments
            pipx
            yubico-client
            nixpkgs
        ]);

<<60a9ccf457d076fd00a2b7388fb3f993(pkg="xonsh", version="39", pythonPackages="python3Packages")>>
#+end_src

***** default.nix

#+call: hash("")

#+RESULTS:
: e7292651473712daff5abd4bee73fd9a

#+name: e7292651473712daff5abd4bee73fd9a
#+begin_src nix :tangle (jr/tangle-oreo)
with builtins; {
    stc ? ({ system = currentSystem; channel = "pkgs"; }),
    ...
} : with stc; let

    flake = (import (
        let
            lock = builtins.fromJSON (builtins.readFile ./flake.lock);
        in fetchTarball {
            url = "https://github.com/edolstra/flake-compat/archive/${lock.nodes.flake-compat.locked.rev}.tar.gz";
            sha256 = lock.nodes.flake-compat.locked.narHash;
        }
    ) { src =  ./.; }).defaultNix;

    sources = flake.inputs;

    nprefix = "nixpkgs";
    prefix = "pkgs";
    inherit (sources) nixpkgs;
    pkgs = import nixpkgs {
        inherit (stc) system;
        config = {
            <<ee56d4a974b19cdf64e1e8f02e47ccaa>>
        };
    };
    lib = nixpkgs.lib.extend (final: prev: {
        j = import ../lib {
            inherit sources pkgs;
            lib = final;
        };
    });
in with lib; flatten [
    (
        <<dc8e809f242cfa0de24ca1a4feb6134f>>
    )
    (
        <<89dc592c50565b862b8b7f8585a34890>>
    )
]
#+end_src

***** kernels

This is the base extension, overriding the =nativeBuildInputs= attribute to include the =zstd= package, to facilitate =zstd=
compression for the kernel:

#+call: hash("")

#+RESULTS:
: ab69b7b5650b908a61c99f5d0b07b92b

#+name: ab69b7b5650b908a61c99f5d0b07b92b
#+begin_src nix
const (super: { kernel = super.kernel.overrideDerivation (drv: {
    nativeBuildInputs = drv.nativeBuildInputs ++ [ pkgs.zstd ];
});})
#+end_src

****** xanmod cacule

Adapted from [[https://www.reddit.com/r/NixOS/comments/jtgi35/cant_build_custom_kernel/][here]]:

#+call: hash("")

#+RESULTS:
: 624779f89c5c4412effd0af738d38bdc

#+name: 624779f89c5c4412effd0af738d38bdc
#+begin_src nix
map (ver: let
        inherit ver;
        _ = makeExtensible { "linuxPackages_xanmod_v${ver}_cacule" = prev.recurseIntoAttrs (
            prev.linuxPackagesFor (
                prev.callPackage (
                    args@{ fetchFromGitHub, buildLinux, ... }: buildLinux (args // rec {
                        version = "${ver}-xanmod1";
                        modDirVersion = version;
                        src = sources."xanmodV${replace ["."] [""] ver}Cacule" // { extraPostFetch = '' rm $out/.config ''; };
                        kernelPatches = [];
                        # postConfigure = '' make ARCH=x86_64 mrproper '';
                        extraConfig = ''
                        #     USER_NS_UNPRIVILEGED y
                        #     FUNCTION_TRACER n
                        #     GRAPH_TRACER n
                        #     NUMA n
                            RD_ZSTD y
                            KERNEL_ZSTD y
                            KERNEL_XZ n
                        '';
                        extraMeta.branch = "${ver}-xanmod1";
                    } // (args.argsOverride or {}))
                ) {}
            )
        );};
    in [( final: prev: { "linuxPackages_xanmod_v${ver}_cacule" = _.extend (self:
        <<ab69b7b5650b908a61c99f5d0b07b92b>>
);})]) [ "5.9.14" "5.10.4" ]
#+end_src

***** flake.nix

#+call: hash("")

#+RESULTS:
: 4e3ff4df217af0a51d77a1a30c4a3f60

#+name: 4e3ff4df217af0a51d77a1a30c4a3f60
#+begin_src nix :tangle (jr/tangle-oreo)
{
    description = "Overlay Sources";

    inputs = {
        <<ff(name="flake-compat", ur="edolstra/flake-compat/master")>>
        <<ff(name="emacs", ur="nix-community/emacs-overlay/master")>>
        nur.url = "github:nix-community/nur/master";
        mach-nix.url = "github:davhau/mach-nix/master";
        <<ff(name="mozilla", ur="mozilla/nixpkgs-mozilla/master")>>
        nanite = {
            url = "git+https://gitlab.com/picotech/nanotech/nanite.git";
            flake = false;
        };
        <<ff(name="niv", ur="nmattia/niv/master")>>
        nix.url = "github:nixos/nix/master";
        <<ff(name="qtile", ur="qtile/qtile/master")>>
        <<ff(name="xonsh", ur="xonsh/xonsh/main")>>
        <<ff(name="wip-pinebook-pro", ur="shadowrylander/wip-pinebook-pro/master")>>
        nixpkgs.url = "github:nixos/nixpkgs/master";
        nixpkgs-20-03.url = "github:nixos/nixpkgs/nixos-20.03";
        nixpkgs-20-03-small.url = "github:nixos/nixpkgs/nixos-20.03-small";
        nixpkgs-20-09.url = "github:nixos/nixpkgs/nixos-20.09";
        nixpkgs-20-09-small.url = "github:nixos/nixpkgs/nixos-20.09-small";
        nixpkgs-unstable.url = "github:nixos/nixpkgs/nixos-unstable";
        nixpkgs-unstable-small.url = "github:nixos/nixpkgs/nixos-unstable-small";
        nixpkgs-master.url = "github:nixos/nixpkgs/master";
    };

    outputs = inputs@{ self, flake-compat, ... } : {  };
}
#+end_src

**** packages.nix

#+begin_src nix :tangle (jr/tangle-oreo)
inputs@{
    pkgs,
    lib,
    sources,
    stc,
    config,
    ...
} : with lib; with j; with stc; let
    inherit (config.vars) minimal terminal;
    inherit (attrs) versions;
    neither = !(minimal || terminal);
    mkifnt = myIf.drv (!terminal) pkgs.hello;
    mkifn = myIf.drv neither pkgs.hello;
    mkifnm = myIf.drv (!minimal) pkgs.hello;
    extra-container = let pkgSrc = sources.extraContainer; in pkgs.callPackage pkgSrc { inherit pkgSrc; };
in with pkgs; [
    # autojump
    # acpilight
    # (myIf.drv (elem system attrs.platforms.imd) pkgs.hello appimage-run)
    # (myIf.drv (elem system attrs.platforms.imd) pkgs.hello appimagekit)
    # assh
    # autossh
    # bat
    # bc
    # bcachefs-tools
    # btrfs-progs
    # byobu
    # cascadia-code
    # copyq
    # coreutils
    # ctop
    # curl
    # darling-dmg
    # ddar
    # diskus
    # dos2unix
    # elvish
    # entr
    # exa
    # exfat
    # fasd
    # fd
    # fff
    # ffmpeg
    # ffmpeg
    # figlet
    # filet
    # fzf
    # gcc
    # git
    # git-crypt
    # git-fire
    # gotop
    # gptfdisk
    # inetutils
    # libffi
    # lolcat
    # lorri
    # micro
    # mkpasswd
    # monkeysphere
    # mosh
    # mtr
    # neo-cowsay
    # neovim
    # niv
    # nix-direnv
    # nixops
    # nnn
    # nox
    # ntfs3g
    # pandoc
    # par2cmdline
    # parted
    # peru
    # pfetch
    # pmutils
    # ranger
    # ripgrep
    # rsync
    # sd
    # shellcheck
    # silver-searcher
    # snapper
    # libguestfs
    # qemu_xen_4_10-light
    # starship
    # sysstat
    # thefuck
    # thermald
    # tmux
    # tmuxp
    # tree
    # udftools
    # uutils-coreutils
    # vagrant
    # vim
    # wget
    # win-qemu
    # wtf
    # xclip
    # xenPackages.xen_4_10-light
    # xz
    # yadm
    # yubico-pam
    # yubico-piv-tool
    # yubikey-manager
    # yubikey-personalization
    # yubioath-desktop
] ++ (map mkifn [
    # gnome3.gnome-boxes
    # gnome3.gnome-tweaks
    # google-chrome
    # google-chrome-beta
    # google-chrome-dev
    # vivaldi
    # vivaldi-ffmpeg-codecs
    # vivaldi-widevine
    # vscodium
]) ++ (map mkifnm [
    # extra-container
    # haskellPackages.hocker
    # refind
]) ++ (map mkifnt [
    # alacritty
    # atom
    # (myIf.drv (elem system attrs.platforms.imd) pkgs.hello etcher)
    # firefox
    # gnome3.gnome-disk-utility
    # gparted
    # keybase-gui
    # kitty
    # libsForQt5.qtstyleplugin-kvantum
    # shadowfox
    # vlc
    # vscode
    # woeusb
    # xclip
    # xfce.thunar
    # yubikey-manager-qt
    # yubikey-personalization-gui
]) ++ (with pkgs.j.pkgset.20-09."emacs${versions.emacs}Packages"; [
    # (mkifnm exwm)
]) ++ (with pkgs."python${versions.python}Packages"; [
    # (myIf.drv (elem system attrs.platforms.imd) pkgs.hello pyls-black)
    # pyls-black
    # (mkifnm jupyter)
    # nixpkgs
    # poetry
]) ++ (with pkgs.gitAndTools; [
    # git-annex
    # git-extras
    # git-hub
    # gitflow
    # gh
    # hub
    # lab
]) ++ (map (npp: mkifnm pkgs."nix-prefetch-${npp}") [
    # "github"
    # "docker"
    # "scripts"
]) ++ (with pkgs.nur.repos; [
    # (mkifnt onny.foliate)
]) ++ [
    # # For emacs

    # # org-roam
    # sqlite

    # # org-md-export-to-markdown
    # nodePackages.prettier
] ++ (let
    p = "python${versions.python}Packages";
in [
    # (getAttr "black" (
    #     if (pkgs ? black) then pkgs else pkgs."${p}"
    # ))

    # (myIf.drv (
    #     (pkgs ? black-macchiato) || (pkgs."${p}" ? black-macchiato)
    # ) pkgs.hello (getAttr "black-macchiato" (
    #     if (pkgs ? black-macchiato) then pkgs else pkgs."${p}"
    # )))

    # (myIf.drv (pkgs ? duf) pkgs.hello (getAttr "duf" pkgs))
    # (myIf.drv (pkgs ? gitoxide) pkgs.hello (getAttr "gitoxide" pkgs))
    # (myIf.drv (pkgs ? glances) pkgs.hello (getAttr "glances" pkgs))
    # (myIf.drv (pkgs ? nixos-shell) pkgs.hello (getAttr "nixos-shell" pkgs))
    # (myIf.drv (pkgs ? obsidian && !neither) pkgs.hello (getAttr "obsidian" pkgs))
    # (myIf.drv (pkgs ? yubikey-agent) pkgs.hello (getAttr "yubikey-agent" pkgs))
    # (myIf.drv (pkgs ? zenith) pkgs.hello (getAttr "zenith" pkgs))
    # (myIf.drv (pkgs."${p}" ? pipx) pkgs.hello (getAttr "pipx" pkgs."${p}"))
])
#+end_src

**** platforms
***** shared
****** armv67l.nix

#+call: hash("")

#+RESULTS:
: ae4d89307b8e79de7de4d6b3b013fe4f

#+name: ae4d89307b8e79de7de4d6b3b013fe4f
#+begin_src nix
{ config, lib, ... }: with builtins; with lib; with j; {
    nix = {
        binaryCaches = [
            "http://nixos-arm.dezgeg.me/channel"
            "https://app.cachix.org/cache/thefloweringash-armv7"
        ];
        binaryCachePublicKeys = [
            "nixos-arm.dezgeg.me-1:xBaUKS3n17BZPKeyxL4JfbTqECsT+ysbDJz29kLFRW0=%"
            "thefloweringash-armv7.cachix.org-1:v+5yzBD2odFKeXbmC+OPWVqx4WVoIVO6UXgnSAWFtso="
        ];
    };
}
#+end_src

***** arm

****** default.nix

#+call: hash("")

#+RESULTS:
: 66a218b142afada2a828f04a8d8a3ba7

#+name: 66a218b142afada2a828f04a8d8a3ba7
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = imprelib.list { dir = ./.; };
    config = {
        # NixOS wants to enable GRUB by default
        boot.loader.grub.enable = false;
        # Enables the generation of /boot/extlinux/extlinux.conf
        boot.loader.generic-extlinux-compatible.enable = true;
    };
}
#+end_src

***** armv6l-linux

****** default.nix

#+call: hash("")

#+RESULTS:
: 72cb27fb954a94b3fb1f5fe55e70b000

#+name: 72cb27fb954a94b3fb1f5fe55e70b000
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = flatten [
        [ ../arm ../shared/armv67l.nix ]
        (imprelib.list { dir = ./.; })
    ];
}
#+end_src

***** armv7l-linux

****** default.nix

#+call: hash("")

#+RESULTS:
: c35840e7b11bd1168fcb3322bfb98fef

#+name: c35840e7b11bd1168fcb3322bfb98fef
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = flatten [
        [ ../arm ../shared/armv67l.nix ]
        (imprelib.list { dir = ./.; })
    ];
}
#+end_src

***** aarch64-linux

****** default.nix

#+call: hash("")

#+RESULTS:
: a5b3a096d1cdc7efefdc21274f566aef

#+name: a5b3a096d1cdc7efefdc21274f566aef
#+begin_src nix :tangle (jr/tangle-oreo)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = flatten [
        [ ../arm ]
        (imprelib.list { dir = ./.; })
    ];
}
#+end_src

**** repl.nix

#+call: hash("")

#+RESULTS:
: d97b95e355f4a2c3ea9b4b071a3b6f89

#+name: d97b95e355f4a2c3ea9b4b071a3b6f89
#+begin_src nix :tangle (jr/tangle-oreo)
let
  flake = builtins.getFlake (toString ./.);
  nixpkgs = import <nixpkgs> { };
in
{ inherit flake; }
// flake
// builtins
// nixpkgs
// nixpkgs.lib
// flake.nixosConfigurations
#+end_src

**** resources
***** users.json

#+call: hash("")

#+RESULTS:
: 4b4166b2bebff5d6dc0a9118372f6e36

#+name: 4b4166b2bebff5d6dc0a9118372f6e36
#+begin_src json :tangle (jr/tangle-oreo)
{
    "primary": "shadowrylander",
    "secondary": "frost",
    "nightingale": "curtis"
}
#+end_src

*** zsh
**** keephack

#+call: hash("pre")

#+RESULTS:
: 70d62a901e2d13d41930afa279c62a5f

#+name: 70d62a901e2d13d41930afa279c62a5f
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/grml/etc/zsh/keephack"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+call: hash("")

#+RESULTS:
: 7fa800ae7af5b2ef406e2ae619952c6a

#+name: 7fa800ae7af5b2ef406e2ae619952c6a
#+begin_src sh :tangle (jr/tangle-oreo)
<<70d62a901e2d13d41930afa279c62a5f()>>
#+end_src

* home
** .doom.d
*** makefile

#+call: hash("github")

#+RESULTS:
: 13efb36a9b3eacd11a9f3b4b7385f96b

#+name: 13efb36a9b3eacd11a9f3b4b7385f96b
#+begin_src text
shadowrylander/emacs-bankruptcy home/.doom.d/emacs-bankruptcy
chenyanming/spacemacs_module_for_doom home/.doom.d/modules/private/spacemacs
#+end_src

#+call: hash("gitlab")

#+RESULTS:
: 99d6a6f01dc482dc4142659f4b7a250a

#+name: 99d6a6f01dc482dc4142659f4b7a250a
#+begin_src text
picotech/use-package-hydra home/.doom.d/use-package-hydra
shadowrylander/use-package-hercules home/.doom.d/use-package-hercules
#+end_src

#+call: hash("")

#+RESULTS:
: dd1688f9a6d0de76df5c19584fff233c

#+name: dd1688f9a6d0de76df5c19584fff233c
#+begin_src makefile :tangle (jr/tangle-oreo)
init:
    -git clone --recurse-submodule https://github.com/<<13efb36a9b3eacd11a9f3b4b7385f96b>>
    -git clone --recurse-submodule https://gitlab.com/<<99d6a6f01dc482dc4142659f4b7a250a>>
.DEFAULT_GOAL := init
#+end_src

*** init.el

#+call: hash("")

#+RESULTS:
: 773fad046a07f82864e6bab4be9aeb4a

#+name: 773fad046a07f82864e6bab4be9aeb4a
#+begin_src emacs-lisp :tangle (jr/tangle-oreo)
;;; init.el -*- lexical-binding: t; -*-

(doom! :input
       ;;chinese
       ;;japanese
       ;;layout            ; auie,ctsrnm is the superior home row

       :completion
       company           ; the ultimate code completion backend
       helm              ; the *other* search engine for love and life
       ;;ido               ; the other *other* search engine...
       (ivy +fuzzy)               ; a search engine for love and life

       :ui
       deft              ; notational velocity for Emacs
       doom              ; what makes DOOM look the way it does
       doom-dashboard    ; a nifty splash screen for Emacs
       ;;doom-quit         ; DOOM quit-message prompts when you quit Emacs
       (emoji +unicode)  ; 🙂
       ;;fill-column       ; a `fill-column' indicator
       hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
       hydra
       indent-guides     ; highlighted indent columns
       ligatures         ; ligatures and symbols to make your code pretty again
       minimap           ; show a map of the code on the side
       modeline          ; snazzy, Atom-inspired modeline, plus API
       nav-flash         ; blink cursor line after big motions
       neotree           ; a project drawer, like NERDTree for vim
       ophints           ; highlight the region an operation acts on
       (popup +defaults)   ; tame sudden yet inevitable temporary windows
       tabs              ; a tab bar for Emacs
       treemacs          ; a project drawer, like neotree but cooler
       unicode           ; extended unicode support for various languages
       vc-gutter         ; vcs diff in the fringe
       vi-tilde-fringe   ; fringe tildes to mark beyond EOB
       (window-select +numbers)     ; visually switch windows
       workspaces        ; tab emulation, persistence & separate workspaces
       zen               ; distraction-free coding or writing

       :editor
       (evil +everywhere); come to the dark side, we have cookies
       file-templates    ; auto-snippets for empty files
       fold              ; (nigh) universal code folding
       (format +onsave)  ; automated prettiness
       god               ; run Emacs commands without modifier keys
       lispy             ; vim for lisp, for people who don't like vim
       multiple-cursors  ; editing in many places at once


       ;; NOTE: This causes lines to be deleted after pressing enter and `i'; go through its documentation
       objed             ; text object editing for the innocent


       (parinfer +rust)          ; turn lisp into python, sort of
       ;;rotate-text       ; cycle region at point between text candidates
       snippets          ; my elves. They type so I don't have to
       word-wrap         ; soft wrapping with language-aware indent

       :emacs
       dired             ; making dired pretty [functional]
       electric          ; smarter, keyword-based electric-indent
       ibuffer         ; interactive buffer management
       undo              ; persistent, smarter undo for your inevitable mistakes
       vc                ; version-control and Emacs, sitting in a tree

       :term
       ;;eshell            ; the elisp shell that works everywhere
       ;;shell             ; simple shell REPL for Emacs
       ;;term              ; basic terminal emulator for Emacs
       ;;vterm             ; the best terminal emulation in Emacs

       :checkers
       syntax              ; tasing you for every semicolon you forget
       spell             ; tasing you for misspelling mispelling
       grammar           ; tasing grammar mistake every you make

       :tools
       ansible
       ;;debugger          ; FIXME stepping through code, to help you add bugs
       direnv
       docker
       editorconfig      ; let someone else argue about tabs vs spaces
       ein               ; tame Jupyter notebooks with emacs
       (eval +overlay)     ; run code, run (also, repls)
       ;;gist              ; interacting with github gists
       ;;lookup              ; navigate your code and its documentation
       (lsp +eglot)
       magit             ; a git porcelain for Emacs
       make              ; run make tasks from Emacs
       pass              ; password manager for nerds
       ;;pdf               ; pdf enhancements
       ;;prodigy           ; FIXME managing external services & code builders
       ;;rgb               ; creating color strings
       taskrunner        ; taskrunner for all your projects
       terraform         ; infrastructure as code
       tmux              ; an API for interacting with tmux
       upload            ; map local to remote projects via ssh/ftp

       :os
       (:if IS-MAC macos)  ; improve compatibility with macOS
       tty               ; improve the terminal Emacs experience

       :lang
       ;;agda              ; types of types of types of types...
       (cc +lsp)                ; C/C++/Obj-C madness
       (clojure +lsp)           ; java with a lisp
       ;;common-lisp       ; if you've seen one lisp, you've seen them all
       ;;coq               ; proofs-as-programs
       ;;crystal           ; ruby at the speed of c
       ;;(csharp +lsp)            ; unity, .NET, and mono shenanigans
       data              ; config/data formats
       ;;(dart +flutter +lsp)   ; paint ui and not much else
       ;;(elixir +lsp)            ; erlang done right
       ;;(elm +lsp)               ; care for a cup of TEA?
       (emacs-lisp +lsp)        ; drown in parentheses
       ;;(erlang +lsp)            ; an elegant language for a more civilized age
       ;;ess               ; emacs speaks statistics
       ;;faust             ; dsp, but you get to keep your soul
       ;;(fsharp +lsp)            ; ML stands for Microsoft's Language
       ;;fstar             ; (dependent) types and (monadic) effects and Z3
       ;;gdscript          ; the language you waited for
       ;;(go +lsp)         ; the hipster dialect
       ;;(haskell +dante +lsp)  ; a language that's lazier than I am
       ;;hy                ; readability of scheme w/ speed of python
       ;;idris             ; a language you can depend on
       json              ; At least it ain't XML
       ;;(java +meghanada +lsp) ; the poster child for carpal tunnel syndrome
       ;;(javascript +lsp)        ; all(hope(abandon(ye(who(enter(here))))))
       ;;(julia +lsp)             ; a better, faster MATLAB
       ;;(kotlin +lsp)            ; a better, slicker Java(Script)
       (latex +lsp)             ; writing papers in Emacs has never been so fun
       ;;lean
       ;;factor
       ledger            ; an accounting system in Emacs
       ;;lua               ; one-based indices? one-based indices
       markdown          ; writing docs for people to ignore
       nim               ; python + lisp at the speed of c
       (nix +lsp)               ; I hereby declare "nix geht mehr!"
       ;;(ocaml +lsp)             ; an objective camel


       ;; TODO
       (org +roam)               ; organize your plain life in plain text
       ;;org               ; organize your plain life in plain text

       ;; org               ; organize your plain life in plain text
       ;;(php +lsp)               ; perl's insecure younger brother
       ;;plantuml          ; diagrams for confusing people more
       ;;(purescript +lsp)        ; javascript, but functional
       (python +lsp)            ; beautiful is better than ugly
       ;;qt                ; the 'cutest' gui framework ever
       ;;racket            ; a DSL for DSLs
       ;;raku              ; the artist formerly known as perl6
       ;;rest              ; Emacs as a REST client
       ;;rst               ; ReST in peace
       ;;(ruby +rails +lsp)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
       ;;(rust +lsp)              ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
       ;;(scala +lsp)             ; java, but good
       ;;scheme            ; a fully conniving family of lisps
       (sh +lsp)                ; she sells {ba,z,fi}sh shells on the C xor
       ;;sml
       ;;solidity          ; do you need a blockchain? No.
       ;;(swift +lsp)             ; who asked for emoji variables?
       ;;terra             ; Earth and Moon in alignment for performance.
       ;;web               ; the tubes
       yaml              ; JSON, but readable

       :email
       ;;(mu4e +gmail)
       ;;notmuch
       ;;(wanderlust +gmail)

       :app
       ;;calendar
       ;;irc               ; how neckbeards socialize
       ;;(rss +org)        ; emacs as an RSS reader
       ;;twitter           ; twitter client https://twitter.com/vnought

       :config

       ;; NOTE: I am manually tangling a README of the config-, init-, and package.el files instead
       ;;literate

       ;;(default +bindings +smartparens)
       (default +smartparens)

       :private spacemacs)
#+end_src

*** config.el

#+call: hash("")

#+RESULTS:
: 5121f652dcfd6166521ed3ccb7fdb62c

#+name: 5121f652dcfd6166521ed3ccb7fdb62c
#+begin_src emacs-lisp :tangle (jr/tangle-oreo)
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

;; (load! "help+20.el")
;; (when (eq (find-font (font-spec :family "all-the-icons")) nil) (all-the-icons-install-fonts))

;; Adapted From:
;; Answer: https://emacs.stackexchange.com/a/26840/31428
;; User: https://emacs.stackexchange.com/users/253/dan
;; Adapted From: https://emacsredux.com/blog/2020/06/14/checking-the-major-mode-in-emacs-lisp/
(defun jr/outline-folded-p nil
    "Returns non-nil if point is on a folded headline or plain list
    item."
    (interactive)
    (and (if (eq major-mode 'org-mode)
            (or (org-at-heading-p)
                (org-at-item-p))
            outline-on-heading-p)
        (invisible-p (point-at-eol))))

<<e66c89b1b0b03e47821d84d6bdd4e30f>>

<<b8e289dc4201435230e95e4bc961eff8>>

<<0f5b9694b164e724814320abc695bb5b>>

<<d265ec51e2ef69de5f99d16281d47afa>>

<<4027496311aaa540864858b0cc6d7781>>

<<0cbddafe342ce45b8c57c5feeb0a4237>>

<<60045541f36fe02d96c14630bbe3966a>>

<<8016354b1cb35e0587437e68baba41d8>>

<<58043a4011d978b07d42cdbe23366db4>>

<<f6fbad3008b5eaa412ac27f2ba12bd42>>

;; Answer: https://stackoverflow.com/a/57075163
;; User: https://stackoverflow.com/users/2708138/tobias
(defun jr/eval-after-load-all (my-features form)
    "Run FORM after all MY-FEATURES are loaded.
    See `eval-after-load' for the possible formats of FORM."
    (if (null my-features)
        (if (functionp form)
        (funcall form)
    (eval form))
    (eval-after-load (car my-features)
        `(lambda nil
    (eval-after-load-all
        (quote ,(cdr my-features))
        (quote ,form))))))

;; Adapted From:
;; Answer: https://stackoverflow.com/a/57075163
;; User: https://stackoverflow.com/users/2708138/tobias
;; (defun jr/eval-after-load-some (my-features form)
;;     "Run FORM after all MY-FEATURES are loaded.
;;     See `eval-after-load' for the possible formats of FORM."
;;     (if (any my-features)
;;         (if (functionp form)
;;         (funcall form)
;;     (eval form))
;;     (eval-after-load (car my-features)
;;         `(lambda nil
;;     (eval-after-load-all
;;         (quote ,(cdr my-features))
;;         (quote ,form))))))

;; From: https://www.masteringemacs.org/article/speed-up-emacs-libjansson-native-elisp-compilation

(if (and (fboundp 'native-comp-available-p)
       (native-comp-available-p))
  (message "Native compilation is available")
(message "Native complation is *not* available"))
(if (functionp 'json-serialize)
  (message "Native JSON is available")
(message "Native JSON is *not* available"))

;; Adapted From:
;; From: https://emacs.stackexchange.com/a/19507
;; User: https://emacs.stackexchange.com/users/50/malabarba
;; (setq byte-compile-warnings (not t))
;; (setq byte-compile warnings (not obsolete))

;; From: https://emacsredux.com/blog/2014/07/25/configure-the-scratch-buffers-mode/
;; (setq initial-major-mode 'org-mode)

;; (add-to-list 'org-src-lang-modes '("nix-repl" . nix-mode))
;; (org-babel-do-load-languages 'org-babel-load-languages '((nix-mode . t)))
;; (json (if (assoc :json params) (nth (+ (cl-position :json params) 1) params) nil))
;; (optargs (if (assoc '-- params) (nthcdr (+ (cl-position '-- params) 1) params) nil))
;; (if (or (eq json nil) (<= json 0)) "" "--json")
;; (if optargs (format "%s" optargs) "")
;; (format "%s" (cdr params))

;; Follow symlinks
(setq vc-follow-symlinks t)

;; Use Python Syntax Highlighting for ".xonshrc" files
;; (setq auto-mode-alist 
;;       (append '(".*\\.xonshrc\\'" . python-mode)
;;               auto-mode-alist))
;; (setq auto-mode-alist 
;;       (append '(".*\\.xsh\\'" . python-mode)
;;              auto-mode-alist))

;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
;; Adapted From: https://www.reddit.com/r/emacs/comments/8fz6x2/relative_number_with_line_folding/dy7lmh7?utm_source=share&utm_medium=web2x&context=3
(setq-default display-line-numbers 'relative)

;; Adapted From:
;; Answer: https://unix.stackexchange.com/a/152151
;; User: https://unix.stackexchange.com/users/72170/ole
;; No more typing the whole yes or no. Just y or n will do.
;; Makes *scratch* empty.
(setq initial-scratch-message "")

;; Removes *scratch* from buffer after the mode has been set.
(defun jr/remove-scratch-buffer nil
  (if (get-buffer "*scratch*")
      (kill-buffer "*scratch*")))
(add-hook 'after-change-major-mode-hook 'jr/remove-scratch-buffer)

;; Removes *messages* from the buffer.
(setq-default message-log-max nil)
(kill-buffer "*Messages*")

;; Removes *Completions* from buffer after you've opened a file.
(add-hook 'minibuffer-exit-hook
      '(lambda nil
         (let ((buffer "*Completions*"))
           (and (get-buffer buffer)
                (kill-buffer buffer)))))

;; Don't show *Buffer list* when opening multiple files at the same time.
(setq inhibit-startup-buffer-menu t)

;; Show only one active window when opening multiple files at the same time.
(add-hook 'window-setup-hook 'delete-other-windows)

(fset 'yes-or-no-p 'y-or-n-p)

;; From: https://kundeveloper.com/blog/autorevert/
;; Auto revert files when they change
(global-auto-revert-mode t)
;; Also auto refresh dired, but be quiet about it
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)

;; Answer: https://emacs.stackexchange.com/a/51829
;; User: https://emacs.stackexchange.com/users/2370/tobias
;; (defun jr/set-buffer-save-without-query nil
;;     "Set `buffer-save-without-query' to t."
;;     (unless (variable-binding-locus 'buffer-save-without-query)
;;         (setq buffer-save-without-query t)))

;; (add-hook #'find-file-hook #'jr/set-buffer-save-without-query)

;; The following avoids being ask to allow the file local
;; setting of `buffer-save-without-query'.
;; IMHO it is not a big risk:
;; The malicious code that must not be saved
;; should never be allowed to enter Emacs in the first place.
;; (put 'buffer-save-without-query 'safe-local-variable #'booleanp)

(setq doom-theme 'exo-ui-red-dark)
;; (setq doom-theme 'dracula-orange-dark)
;; (setq doom-theme 'dracula-purple-dark)
;; (setq doom-theme 'doom-gruvbox)
;; (setq doom-theme nil)
;; From: https://github.com/hlissner/emacs-doom-themes#common-issues
;; (let ((height (face-attribute 'default :height)))
;;   ;; for all linum/nlinum users
;;   (set-face-attribute 'linum nil :height height)
;;   ;; only for `linum-relative' users:
;;   (set-face-attribute 'linum-relative-current-face nil :height height)
;;   ;; only for `nlinum-relative' users:
;;   ;; (set-face-attribute 'nlinum-relative-current-face nil :height height)
;; )

(setq user-full-name "Jeet Ray"
      user-mail-address "aiern@protonmail.com")

(setq doom-font (font-spec :family "Cartograph CF" :size 15 :weight 'light)
      doom-variable-pitch-font (font-spec :family "sans" :size 13))

;; (dump-emacs-portable "~/.emacs.d/garboder")
#+end_src

**** use-package

***** always defer package loading

Quoted from [[Use-Package's Loading packages in sequence
][https://github.com/jwiegley/use-package#loading-packages-in-sequence]]:

#+begin_quote
NOTE: pay attention if you set use-package-always-defer to t, and also use the :after keyword, as you will need to specify how the
declared package is to be loaded: e.g., by some :bind. If you're not using one of the mechanisms that registers autoloads, such as
:bind or :hook, and your package manager does not provide autoloads, it's possible that without adding :defer 2 to those declarations,
your package will never be loaded.
#+end_quote

Quoted from [[Use-Package's Notes about lazy loading][https://github.com/jwiegley/use-package#notes-about-lazy-loading]]:

#+begin_quote
In almost all cases you don't need to manually specify :defer t. This is implied whenever :bind or :mode or :interpreter is used.
Typically, you only need to specify :defer if you know for a fact that some other package will do something to cause your package to
load at the appropriate time, and thus you would like to defer loading even though use-package isn't creating any autoloads for you.
You can override package deferral with the :demand keyword. Thus, even if you use :bind, using :demand will force loading to occur
immediately and not establish an autoload for the bound key.
#+end_quote

Quoted from [[Use-Package's Modes and interpreters][https://github.com/jwiegley/use-package#modes-and-interpreters]]:

#+begin_quote
Similar to :bind, you can use :mode and :interpreter to establish a deferred binding within the auto-mode-alist and interpreter-mode-alist variables.
...
If you aren't using :commands, :bind, :bind*, :bind-keymap, :bind-keymap*, :mode, :interpreter, or :hook
(all of which imply :defer; see the docstring for use-package for a brief description of each), you can still defer loading with the :defer keyword...
#+end_quote

Quoted from [[Use-Package's Magic handlers][https://github.com/jwiegley/use-package#magic-handlers]]:

#+begin_quote
Similar to :mode and :interpreter, you can also use :magic and :magic-fallback to cause certain function to be run if the beginning of a file matches
a given regular expression.
...
This registers an autoloaded command for pdf-view-mode, defers loading of pdf-tools, and runs pdf-view-mode if the beginning of a buffer matches the string "%PDF".
#+end_quote

Quoted from [[RYO-Modal's Use-package keyword][https://github.com/Kungsgeten/ryo-modal#use-package-keyword]]:

#+begin_quote
Ryo-modal also provides a use-package keyword: :ryo, which is similar to :bind in that it implies :defer t and create autoloads for the bound commands.
The keyword is followed by one or more key-binding commands, using the same syntax as used by ryo-modal-keys...
#+end_quote

Quoted from [[General's Use-package Keywords][https://github.com/noctuid/general.el#use-package-keywords]]:

#+begin_quote
:general is similar to :bind in that it implies :defer t whenever there are bound commands that can be autoloaded
(e.g. it will not imply :defer t if the only bound command is to a lambda, for example). Whenever autoloadable commands are bound,
use-package will create autoloads for them (though this is usually not necessary).
#+end_quote

Quoted from [[General's :ghook Keyword][https://github.com/noctuid/general.el#ghook-keyword]]:

#+begin_quote
:ghook is intended to be used to add a package’s minor mode enabling function to a user-specified hook, so that when hook is run,
the package will be loaded and the mode enabled. This means that :ghook will usually imply :defer t. While it does not always imply :defer t,
it will add any non-lambda functions to :commands (this is the same behavior as :hook).
Though this is usually unnecessary (the commands probably already have autoloads), it will in turn imply :defer t.
#+end_quote

Quoted from [[General's :gfhook Keyword][https://github.com/noctuid/general.el#gfhook-keyword]]:

#+begin_quote
Unlike :ghook, :gfhook never adds functions to :commands and therefore never implies :defer t.
This is because the functions specified are ones that should be run when turning on (or toggling) the mode(s) the package provides.
The specified functions are external to the package, could be called elsewhere, and therefore should not trigger the package to load.
#+end_quote

Also see [[this comment][https://github.com/jwiegley/use-package/issues/738#issuecomment-447631609]].

Note that I assume that [[chords][https://github.com/jwiegley/use-package#use-package-chords]] also defer and create autoloads.

And in my experience... Not a good idea; much too confusing. Use
[[the arguments here][https://www.reddit.com/r/emacs/comments/j2xezg/usepackage_best_practices/]] to decide whether to use this or =:defer <n>= instead.

#+call: hash("ad")

#+RESULTS:
: 3bea610856c41a0d7902afd1c523b3fa

#+name: 3bea610856c41a0d7902afd1c523b3fa
#+begin_src emacs-lisp
(setq use-package-always-defer t)
#+end_src

#+call: hash("")

#+RESULTS:
: e66c89b1b0b03e47821d84d6bdd4e30f

#+name: e66c89b1b0b03e47821d84d6bdd4e30f
#+begin_src emacs-lisp
;; <<3bea610856c41a0d7902afd1c523b3fa>>

;; From: https://github.com/hartzell/straight.el/commit/882649137f73998d60741c7c8c993c7ebbe0f77a#diff-b335630551682c19a781afebcf4d07bf978fb1f8ac04c6bf87428ed5106870f5R1649
;; (setq straight-disable-byte-compilation t)

;; Adapted From: https://github.com/jwiegley/use-package#use-package-chords
;; Important: https://github.com/noctuid/general.el/issues/53#issuecomment-307262154
(use-package! use-package-chords
        :demand t
        :hook (after-init . key-chord-mode))

(use-package! use-package-hydra
        :demand t
        :load-path "use-package-hydra"
        :custom (hydra-hint-display-type 'lv))
(use-package! use-package-hercules
        :demand t
        :load-path "use-package-hercules")
#+end_src

**** org-mode

#+call: hash("")

#+RESULTS:
: 0f5b9694b164e724814320abc695bb5b

#+name: 0f5b9694b164e724814320abc695bb5b
#+begin_src emacs-lisp
(use-package! org
        :init
            ;; I'm using ox-pandoc
            ;; (setq org-export-backends '(md gfm latex odt org))
            (setq org-directory "/tmp")
            (setq org-roam-directory org-directory)
        :hook
            ((org-mode . 'jr/org-babel-tangle-append-setup)
            ;; (kill-emacs . 'org-babel-tangle)

            ;; Adapted From: https://www.reddit.com/r/emacs/comments/6klewl/org_cyclingto_go_from_folded_to_children_skipping/djniygy?utm_source=share&utm_medium=web2x&context=3
            (org-cycle . (lambda (state) (interactive) (when (eq state 'children) (setq org-cycle-subtree-status 'subtree)))))
        :config
            (org-babel-lob-ingest "/README.org")

            <<2d63732674461dc2b644efd020455882>>

            <<2797cdf9a536de59551ab5e470544e74>>

            <<d5f827b029c135ec0d04907f50c759b7>>

            ;; Adapted From:
            ;; Answer: https://emacs.stackexchange.com/a/37791/31428
            ;; User: https://emacs.stackexchange.com/users/12497/toothrot
            (defun jr/go-to-parent nil (interactive)
                (outline-up-heading (if (and (or (org-at-heading-p) (invisible-p (point))) (invisible-p (point-at-eol))
                        (>= (org-current-level) 2))
                    1 0)))

            (defun jr/evil-close-fold nil (interactive) (jr/go-to-parent) (evil-close-fold))

            (defun jr/org-cycle nil (interactive) (
                if (jr/outline-folded-p) (org-cycle) (jr/evil-close-fold)))

            ;; Note: Not in the `:general' section 'cause I have no idea how to define `<backtab>'
            (define-key evil-normal-state-map (kbd "<backtab>") 'jr/evil-close-fold)
            (define-key evil-insert-state-map (kbd "<backtab>") 'jr/evil-close-fold)

            <<ed55930dc36029c49a46d842fd0ffc1b>>
        :general
            <<3df3d7bde7eda0546c77ba9a5b2aa82d>>
            ;; (progn (:keymaps '(override insert)
            ;;     "TAB" nil)
            ;; (:keymaps '(override insert)
            ;;     "TAB" 'jr/org-cycle))
        :ryo ("o" :hydra
            '(hydra-org nil
                  "A hydra for org-mode!"
                  ("o" org-babel-tangle "tangle")
                  ("a" jr/org-babel-tangle-append "tangle append")
                  ("f" org-babel-tangle-file "tangle file")
                  ("i" ryo-modal-mode "cancel" :color blue)
                  ("q" nil "cancel" :color blue)))
        :custom
            (org-descriptive-links t)
            (org-confirm-babel-evaluate nil)
            (org-startup-folded t)
            (org-src-fontify-natively t)
            (org-src-window-setup 'current-window))

(use-package! org-numbers-overlay
        :load-path "emacs-bankruptcy/site-lisp"
        :hook (org-mode . org-numbers-overlay-mode))
#+end_src

***** org-babel-tangle-append

This is adapted from
[[https://emacs.stackexchange.com/questions/28098/how-to-change-org-mode-babel-tangle-write-to-file-way-as-append-instead-of-overr/38898#38898][How to change Org-mode babel tangle write to file way as append instead of override by default?
]], by [[https://emacs.stackexchange.com/users/2370/tobias][Tobias]]:

#+call: hash("")

#+RESULTS:
: 2d63732674461dc2b644efd020455882

#+name: 2d63732674461dc2b644efd020455882
#+begin_src emacs-lisp
(defun jr/org-babel-tangle-append nil
  "Append source code block at point to its tangle file.
The command works like `org-babel-tangle' with prefix arg
but `delete-file' is ignored."
  (interactive)
  (cl-letf (((symbol-function 'delete-file) #'ignore))
    (org-babel-tangle '(4))))

(defun jr/org-babel-tangle-append-setup nil
  "Add key-binding C-c C-v C-t for `jr/org-babel-tangle-append'."
  (org-defkey org-mode-map (kbd "C-c C-v +") 'jr/org-babel-tangle-append))
#+end_src

***** org-babel-tangle-multiple

This is from
[[https://emacs.stackexchange.com/questions/39032/tangle-the-same-src-block-to-different-files/39039#39039][tangle the same src block to different files
]], by [[https://emacs.stackexchange.com/users/2370/tobias][Tobias]]:

#+call: hash("")

#+RESULTS:
: 2797cdf9a536de59551ab5e470544e74

#+name: 2797cdf9a536de59551ab5e470544e74
#+begin_src emacs-lisp
(defun org-babel-tangle-collect-blocks-handle-tangle-list (&optional language tangle-file)
  "Can be used as :override advice for `org-babel-tangle-collect-blocks'.
Handles lists of :tangle files."
  (let ((counter 0) last-heading-pos blocks)
    (org-babel-map-src-blocks (buffer-file-name)
      (let ((current-heading-pos
         (org-with-wide-buffer
          (org-with-limited-levels (outline-previous-heading)))))
    (if (eq last-heading-pos current-heading-pos) (cl-incf counter)
      (setq counter 1)
      (setq last-heading-pos current-heading-pos)))
      (unless (org-in-commented-heading-p)
    (let* ((info (org-babel-get-src-block-info 'light))
           (src-lang (nth 0 info))
           (src-tfiles (cdr (assq :tangle (nth 2 info))))) ; Tobias: accept list for :tangle
      (unless (consp src-tfiles) ; Tobias: unify handling of strings and lists for :tangle
        (setq src-tfiles (list src-tfiles))) ; Tobias: unify handling
      (dolist (src-tfile src-tfiles) ; Tobias: iterate over list
        (unless (or (string= src-tfile "no")
            (and tangle-file (not (equal tangle-file src-tfile)))
            (and language (not (string= language src-lang))))
          ;; Add the spec for this block to blocks under its
          ;; language.
          (let ((by-lang (assoc src-lang blocks))
            (block (org-babel-tangle-single-block counter)))
        (setcdr (assoc :tangle (nth 4 block)) src-tfile) ; Tobias: 
        (if by-lang (setcdr by-lang (cons block (cdr by-lang)))
          (push (cons src-lang (list block)) blocks)))))))) ; Tobias: just ()
    ;; Ensure blocks are in the correct order.
    (mapcar (lambda (b) (cons (car b) (nreverse (cdr b)))) blocks)))

(defun org-babel-tangle-single-block-handle-tangle-list (oldfun block-counter &optional only-this-block)
  "Can be used as :around advice for `org-babel-tangle-single-block'.
If the :tangle header arg is a list of files. Handle all files"
  (let* ((info (org-babel-get-src-block-info))
     (params (nth 2 info))
     (tfiles (cdr (assoc :tangle params))))
    (if (null (and only-this-block (consp tfiles)))
    (funcall oldfun block-counter only-this-block)
      (cl-assert (listp tfiles) nil
         ":tangle only allows a tangle file name or a list of tangle file names")
      (let ((ret (mapcar
          (lambda (tfile)
            (let (old-get-info)
              (cl-letf* (((symbol-function 'old-get-info) (symbol-function 'org-babel-get-src-block-info))
                 ((symbol-function 'org-babel-get-src-block-info)
                  `(lambda (&rest get-info-args)
                     (let* ((info (apply 'old-get-info get-info-args))
                        (params (nth 2 info))
                        (tfile-cons (assoc :tangle params)))
                       (setcdr tfile-cons ,tfile)
                       info))))
            (funcall oldfun block-counter only-this-block))))
          tfiles)))
    (if only-this-block
        (list (cons (cl-caaar ret) (mapcar #'cadar ret)))
      ret)))))

(advice-add 'org-babel-tangle-collect-blocks :override #'org-babel-tangle-collect-blocks-handle-tangle-list)
(advice-add 'org-babel-tangle-single-block :around #'org-babel-tangle-single-block-handle-tangle-list)
#+end_src

***** org-roam

Taken from [[Org-Roam's GitHub README][https://github.com/org-roam/org-roam#installation]], adapted by yours truely:

#+call: hash("")

#+RESULTS:
: 3df3d7bde7eda0546c77ba9a5b2aa82d

#+name: 3df3d7bde7eda0546c77ba9a5b2aa82d
#+begin_src emacs-lisp
(:keymaps 'org-roam-mode-map
      "C-c n" '(:ignore t :which-key "Org-Roam")
      "C-c n l" 'org-roam
      "C-c n f" 'org-roam-find-file
      "C-c n g" 'org-roam-graph)
(:keymaps 'org-mode-map
      "C-c n i" 'org-roam-insert
      "C-c n I" 'org-roam-insert-immediate)
#+end_src

***** languages

#+call: hash("")

#+RESULTS:
: d5f827b029c135ec0d04907f50c759b7

#+name: d5f827b029c135ec0d04907f50c759b7
#+begin_src emacs-lisp
<<04dbf8eb8aa0b8101102b13044392cc8>>

<<a9ce3aa0a02c096218d0bd9f8646d606>>

<<bc74035cf2335eb01654c90f7518def5>>

<<7bd7723280e47c56c1734e5ce06c5ecb>>
#+end_src

****** nix

#+call: hash("")

#+RESULTS:
: 04dbf8eb8aa0b8101102b13044392cc8

#+name: 04dbf8eb8aa0b8101102b13044392cc8
#+begin_src emacs-lisp
(use-package! nix-mode
    :commands (org-babel-execute:nix)
    :mode ("\\.nix\\'")
    :config
        ;; Adapted From:
        ;; Answer: https://emacs.stackexchange.com/a/61442
        ;; User: https://emacs.stackexchange.com/users/20061/zeta
        (defun org-babel-execute:nix (body params)
            "Execute a block of Nix code with org-babel."
            (message "executing Nix source code block")
            (let ((in-file (org-babel-temp-file "n" ".nix"))
                (json (or (cdr (assoc :json params)) nil))
                (opts (or (cdr (assoc :opts params)) nil))
                (args (or (cdr (assoc :args params)) nil))
                (read-write-mode (or (cdr (assoc :read-write-mode params)) nil))
                (eval (or (cdr (assoc :eval params)) nil))
                (show-trace (or (cdr (assoc :show-trace params)) nil)))
            (with-temp-file in-file
                (insert body))
            (org-babel-eval
                (format "nix-instantiate %s %s %s %s %s %s %s"
                    (if (xor (eq json nil) (<= json 0)) "" "--json")
                    (if (xor (eq show-trace nil) (<= show-trace 0)) "" "--show-trace")
                    (if (xor (eq read-write-mode nil) (<= read-write-mode 0)) "" "--read-write-mode")
                    (if (xor (eq eval nil) (<= eval 0)) "" "--eval")
                    (if (eq opts nil) "" opts)
                    (if (eq args nil) "" args)
                    (org-babel-process-file-name in-file))
            ""))))
#+end_src

****** xonsh

#+call: hash("")

#+RESULTS:
: a9ce3aa0a02c096218d0bd9f8646d606

#+name: a9ce3aa0a02c096218d0bd9f8646d606
#+begin_src emacs-lisp
(use-package! xonsh-mode
    :commands
        (org-babel-execute:xonsh
        org-babel-expand-body:xonsh)
    :mode ("\\.xonshrc\\'" "\\.xsh\\'")
    :config
        ;; Adapted From:
        ;; Answer: https://emacs.stackexchange.com/a/61442
        ;; User: https://emacs.stackexchange.com/users/20061/zeta
        (defun org-babel-execute:xonsh (body params)
            "Execute a block of Xonsh code with org-babel."
            (message "executing Xonsh source code block")
            (let ((in-file (org-babel-temp-file "x" ".xsh"))
                (opts (or (cdr (assoc :opts params)) nil))
                (args (or (cdr (assoc :args params)) nil)))
            (with-temp-file in-file
                (insert body))
            (org-babel-eval
                (format "xonsh %s %s %s"
                    (if (eq opts nil) "" opts)
                    (if (eq args nil) "" args)
                    (org-babel-process-file-name in-file))
            ""))))
#+end_src

****** dockerfile

#+call: hash("")

#+RESULTS:
: bc74035cf2335eb01654c90f7518def5

#+name: bc74035cf2335eb01654c90f7518def5
#+begin_src emacs-lisp
(use-package! dockerfile-mode
    :config
        (org-babel-do-load-languages 'org-babel-load-languages
            (append org-babel-load-languages
                '((Dockerfile . t))))
    :mode ("\\Dockerfile\\'"))
#+end_src

****** vimrc

#+call: hash("")

#+RESULTS:
: 7bd7723280e47c56c1734e5ce06c5ecb

#+name: 7bd7723280e47c56c1734e5ce06c5ecb
#+begin_src emacs-lisp
(use-package! vimrc-mode
    :commands
        (org-babel-execute:vimrc
        org-babel-expand-body:vimrc)
    :mode "\\.vim\\(rc\\)?\\'")
#+end_src

**** modal modes

#+call: hash("setup")

#+RESULTS:
: d3797553f252eabca75070bb3374df05

#+name: d3797553f252eabca75070bb3374df05
#+begin_src emacs-lisp :var map="" :var mode="" :var prefix=""
;; Adapted From:
;; Answer: https://emacs.stackexchange.com/a/7381/31428
;; User: https://emacs.stackexchange.com/users/719/adobe
(format-spec ":hercules
    (:show-funs #'jr/%p-hercules-show
    :hide-funs #'jr/%p-hercules-hide
    :toggle-funs #'jr/%p-hercules-toggle
    :keymap '%m
    ;; :transient t
    )
:config
    (defun jr/%p-hercules-toggle nil (interactive))
    (add-to-list 'modal-modes '%n)

    (defun jr/toggle-%p nil (interactive)
        (funcall 'jr/toggle-inner '%n \"%p\" (bound-and-true-p %n) '%m))" `((?m . ,map) (?n . ,mode) (?p . ,prefix)))
#+end_src

# I HAVE SPENT SO LONG SEARCHING FOR THIS! Basically, I want to have my cake and eat it too, i.e. use =RYO Modal=, =Emacs Mode=,
# =God Mode=, =Modalka=, =Xah-Fly-Keys=, etc. , and =Evil Mode=, at the same time. I searched for so long for to be able to override =evil='s keybindings
# in =ryo-modal-mode=, and eventually found [[the function to define an overriding keymap][https://github.com/noctuid/evil-guide#evils-tools]]
# (directed from [[here][https://github.com/emacs-evil/evil/issues/511#issuecomment-273754917]], THOUGH NOTE THAT THE FUNCTION IS INCORRECT!),
# which allows me to force =ryo-modal-mode='s keybindings to have a higher priority compared to =evil='s.

#+call: hash("")

#+RESULTS:
: b8e289dc4201435230e95e4bc961eff8

#+name: b8e289dc4201435230e95e4bc961eff8
#+begin_src emacs-lisp
<<e8fba38bca841d9f8d89cd15b15754bd>>

<<8c01d74b243996d2524244ea38efedf0>>

(use-package! evil
        :hook (doom-init-ui . jr/evil-hercules-toggle)
        :init
            ;; From:
            ;; Answer: https://stackoverflow.com/questions/25542097/emacs-evil-mode-how-to-change-insert-state-to-emacs-state-automatically/56206909#56206909
            ;; User: https://stackoverflow.com/users/1259257/mshohayeb
            (setq evil-disable-insert-state-bindings t)
            (defun jr/evil-hercules-toggle nil (interactive))
            (defun jr/evil-quit nil (interactive) (funcall (general-simulate-key ":q! <RET>")))
            ;; (setq evil-want-keybinding nil)
            ;; (setq evil-want-integration t)
        :general
            (:keymaps 'override

                ;; Used on Android
                "∅" 'evil-save-and-close
                "æ" 'jr/evil-quit

                (general-chord ";'") 'evil-execute-in-emacs-state

                ;; NOTE: Will not toggle if hercules is transient
                (general-chord ";;") 'jr/evil-hercules-toggle)

        :config
            <<e1785de4290e315a93e1f67553025f69>>

            <<d34ff1a4219491ae3aee30b275fd9212>>

            <<913cb77bdade14e8a517edbee7410b9a>>

            <<c323d6a8a89df885749c42fd2a0bc858>>

            <<452c54e1a8e466b834ef13df6b9e238c>>

            ;; From: https://www.reddit.com/r/emacs/comments/lp45zd/help_requested_in_configuring_ryomodal/gp3rfx9?utm_source=share&utm_medium=web2x&context=3
            ;; Kept for documentation porpoises
            ;; (eval
            ;;       `(ryo-modal-keys
            ;;             ("l l" ,(general-simulate-key ":wq <RET>") :first '(evil-normal-state) :name "wq")
            ;;             ("l p" ,(general-simulate-key ":q <RET>") :first '(evil-normal-state) :name "q")
            ;;             ("l o" ,(general-simulate-key ":w <RET>") :first '(evil-normal-state) :name "w")
            ;;             ("l q" ,(general-simulate-key ":q! <RET>") :first '(evil-normal-state) :name "q!")))

            ;; Use to get command name:
            ;; Eg: (cdr (assoc "q" evil-ex-commands))
            ;; Then "C-x C-e" (eval-last-sexp)
        :ryo
            ("l" :hydra
                  '(evil-exits (:color blue)
                        "A hydra for getting the fuck outta' here!"
                        ("l" evil-save-and-close ":wq")
                        ("p" quit ":q")

                        ;; TODO: These may not be working due to native compilation, or general-simulate-key;
                        ;; use another emacs version, or kbd?
                        ("o" (funcall (general-simulate-key ":w <RET>")) ":w")
                        ("q" (funcall (general-simulate-key ":q! <RET>")) ":q!")

                        ("`" nil "cancel"))
                    :first '(evil-normal-state)
                    :name "evil exits")
            (";" jr/ryo-hercules-toggle :name "toggle keymap")
        :hercules
            (:show-funs #'jr/evil-hercules-show
            :hide-funs #'jr/evil-hercules-hide
            :toggle-funs #'jr/evil-hercules-toggle
            :keymap 'evil-normal-state-map
            ;; :transient t
            ))

;; Adapted From: https://github.com/mohsenil85/evil-evilified-state and https://github.com/syl20bnr/spacemacs
(use-package! evil-evilified-state :after evil)
#+end_src

***** hercules

#+call: hash("")

#+RESULTS:
: e8fba38bca841d9f8d89cd15b15754bd

#+name: e8fba38bca841d9f8d89cd15b15754bd
#+begin_src emacs-lisp
(use-package! hercules
        :demand t
        ;; :hook (doom-init-ui . (lambda nil (interactive)
        ;;     (which-key--show-popup (cons 0.25 0.5))))
        :init
            (setq which-key-enable-extended-define-key t)
            (setq which-key-idle-delay 0.1)
            (setq which-key-idle-secondary-delay nil)
        :custom

            ;; NOTE: When using the side window, this doesn't matter, apparently;
            ;; only the hercules transient property does
            (which-key-persistent-popup t)

            (which-key-allow-evil-operators t)

            ;; NOTE: This will cause the which-key maps for the operator states to show up,
            ;; breaking functionality such as `d 13 <arrow-down>', etc.
            ;; (which-key-show-operator-state-maps t)

            ;; TODO: Choose a fun one!
            (which-key-separator " | ")

            (which-key-popup-type 'side-window)
            (which-key-side-window-location '(right bottom left top))

            ;; If this percentage is too small, the keybindings frame will appear at the bottom
            (which-key-side-window-max-width 0.5)

            (which-key-side-window-max-height 0.25))
#+end_src

***** ryo modal

#+call: hash("")

#+RESULTS:
: 8c01d74b243996d2524244ea38efedf0

#+name: 8c01d74b243996d2524244ea38efedf0
#+begin_src emacs-lisp
(use-package! ryo-modal
        :demand t
        :preface
            ;; (setq modal-modes '(evil-mode))
            (setq modal-modes '())

            ;; Adapted From:
            ;; Answer: https://emacs.stackexchange.com/a/42240
            ;; User: user12563
            (defun jr/disable-all-modal-modes nil
                (interactive)
                (mapc
                    (lambda (mode-symbol)
                        (when (functionp mode-symbol)
                        ;; some symbols are functions which aren't normal mode functions
                            (ignore-errors 
                                (funcall mode-symbol -1))))
                        modal-modes))

            ;; Answer: https://stackoverflow.com/a/14490054/10827766
            ;; User: https://stackoverflow.com/users/1600898/user4815162342
            (defun jr/keymap-symbol (keymap)
                "Return the symbol to which KEYMAP is bound, or nil if no such symbol exists."
                (catch 'gotit
                        (mapatoms (lambda (sym)
                            (and (boundp sym)
                                    (eq (symbol-value sym) keymap)
                                    (not (eq sym 'keymap))
                                    (throw 'gotit sym))))))

            ;; Adapted From: https://gitlab.com/jjzmajic/hercules.el/-/blob/master/hercules.el#L83
            (defun jr/toggle-inner (mode prefix mode-on map) (interactive)
                (jr/disable-all-modal-modes)
                (funcall (intern (concat "jr/" prefix "-hercules-hide")))
                (if mode-on
                    (progn
                        (evil-mode 1)
                        (internal-push-keymap 'evil-mode-map 'overriding-terminal-local-map))
                    (funcall mode 1)
                    (internal-push-keymap (symbol-value map) 'overriding-terminal-local-map)
                    (funcall (intern (concat "jr/" prefix "-hercules-show")))))

        :general
            (:keymaps 'override
                  (general-chord "kk") 'jr/toggle-ryo
                  "M-w M-w" 'jr/ryo-hercules-toggle)
        <<d3797553f252eabca75070bb3374df05(map="ryo-modal-mode-map", mode="ryo-modal-mode", prefix="ryo")>>

            ;; From: https://github.com/Kungsgeten/ryo-modal#which-key-integration
            (push '((nil . "ryo:.*:") . (nil . "")) which-key-replacement-alist))
#+end_src

***** god mode

#+call: hash("")

#+RESULTS:
: e1785de4290e315a93e1f67553025f69

#+name: e1785de4290e315a93e1f67553025f69
#+begin_src emacs-lisp
(use-package! god-mode
        :general
            (:keymaps 'override
                  (general-chord "jj") 'jr/toggle-god
                  (general-chord "';") 'god-execute-with-current-bindings

                  ;; NOTE: Will not toggle if hercules is transient
                  "C-;" 'jr/god-hercules-toggle)
        :hook
            (doom-first-buffer-hook . (lambda nil (interactive)
                (god-mode -1)
                (god-local-mode -1)))
        <<d3797553f252eabca75070bb3374df05(map="global-map", mode="god-local-mode", prefix="god")>>
            (which-key-enable-god-mode-support))
#+end_src

***** xah-fly-keys

#+call: hash("")

#+RESULTS:
: d34ff1a4219491ae3aee30b275fd9212

#+name: d34ff1a4219491ae3aee30b275fd9212
#+begin_src emacs-lisp
(use-package! xah-fly-keys
        :general
            (:keymaps 'xah-fly-command-map
                ";" 'jr/xah-hercules-toggle)
        :ryo
            ("m" :hydra
                  '(modal-modes nil
                        "A modal hydra!"
                        ("x" jr/toggle-xah "xah-fly-keys")
                        ("`" nil "cancel" :color blue)) :name "modal modes")
        <<d3797553f252eabca75070bb3374df05(map="xah-fly-command-map", mode="xah-fly-keys", prefix="xah")>>)
#+end_src

***** objed

#+call: hash("")

#+RESULTS:
: 913cb77bdade14e8a517edbee7410b9a

#+name: 913cb77bdade14e8a517edbee7410b9a
#+begin_src emacs-lisp
(use-package! objed
        :general
            (:keymaps 'override
                (general-chord "ii") 'jr/toggle-objed)
            (:keymaps 'objed-map
                ";" 'jr/objed-hercules-toggle)
        :hook
            (after-init . (lambda nil (interactive)
                (objed-mode -1)))
        <<d3797553f252eabca75070bb3374df05(map="objed-map", mode="objed-mode", prefix="objed")>>)
#+end_src

***** kakoune

#+call: hash("")

#+RESULTS:
: c323d6a8a89df885749c42fd2a0bc858

#+name: c323d6a8a89df885749c42fd2a0bc858
#+begin_src emacs-lisp
;; Use `ryo-modal'
(use-package! kakoune)
#+end_src

***** modalka

#+call: hash("")

#+RESULTS:
: 452c54e1a8e466b834ef13df6b9e238c

#+name: 452c54e1a8e466b834ef13df6b9e238c
#+begin_src emacs-lisp
;; Assign to `xah-fly-keys' mode's previous general keybinding, i.e. `[['
(use-package! modalka)
#+end_src

**** minibuffer

#+call: hash("")

#+RESULTS:
: d265ec51e2ef69de5f99d16281d47afa

#+name: d265ec51e2ef69de5f99d16281d47afa
#+begin_src emacs-lisp
<<b7ccdbd9b486c4c7b221f9a885c076dc>>

(ryo-modal-key "x" :hydra
      '(hydra-execute nil
            "A hydra for launching stuff!"
            ("c" counsel-M-x "counsel")
            ("h" helm-smex-major-mode-commands "helm smex major mode")
            ("s" helm-smex "helm smex")
            ("e" execute-extended-command "M-x")
            ("q" nil "cancel" :color blue)) :first '(evil-insert-state) :name "execute order 65")

;; TODO: Does this work? Or do I have to pull the hydra out?
(general-def "C-S-p" 'hydra-execute)
#+end_src

***** helm

#+call: hash("")

#+RESULTS:
: b7ccdbd9b486c4c7b221f9a885c076dc

#+name: helm
#+begin_src emacs-lisp
;; Adapted From: https://github.com/clemera/helm-ido-like-guide
(use-package! helm-ido-like
    :hook after-init
    :after
        (helm-swoop
        helm-flx
        helm-fuzzier
        helm-smex
        smex
        dash))
#+end_src

**** git

#+call: hash("")

#+RESULTS:
: 4027496311aaa540864858b0cc6d7781

#+name: 4027496311aaa540864858b0cc6d7781
#+begin_src emacs-lisp
<<d4938f230a99ce9f6c1fb2db970a897c>>
;; (use-package! gitattributes-mode)
#+end_src

***** git-gutter

#+call: hash("")

#+RESULTS:
: d4938f230a99ce9f6c1fb2db970a897c

#+name: d4938f230a99ce9f6c1fb2db970a897c
#+begin_src emacs-lisp
(use-package! git-gutter
      :ryo ("g" :hydra
            '(hydra-git nil
                  "A hydra for git!"
                  ("g" magit-status "magit" :color blue)
                  ("j" git-gutter:next-hunk "next")
                  ("k" git-gutter:previous-hunk "previous")
                  ("d" git-gutter:popup-hunk "diff")
                  ("s" git-gutter:stage-hunk "stage")
                  ("r" git-gutter:revert-hunk "revert")
                  ("m" git-gutter:mark-hunk "mark")
                  ("q" nil "cancel" :color blue)))
)
#+end_src

**** buffer

#+call: hash("")

#+RESULTS:
: 0cbddafe342ce45b8c57c5feeb0a4237

#+name: 0cbddafe342ce45b8c57c5feeb0a4237
#+begin_src emacs-lisp
(remove-hook 'doom-first-buffer-hook #'global-hl-line-mode)

(use-package! writeroom-mode
    :general (:keymaps 'override (general-chord "zz") 'writeroom-mode)
    :custom (writeroom-fullscreen-effect t)
    :hook after-init)

(use-package! rainbow-delimiters
      :hook ((prog-mode . rainbow-delimiters-mode)

            ;; Add more modes here
            ))
#+end_src

**** terminal

#+call: hash("")

#+RESULTS:
: 60045541f36fe02d96c14630bbe3966a

#+name: 60045541f36fe02d96c14630bbe3966a
#+begin_src emacs-lisp
;; <<4250ee7991caad7d0b372c862bb7ea60>>

;; (ansi-term-color-vector [unspecified "white" "red" "green" "yellow" "royal blue" "magenta" "cyan" "white"] t)
;; (ansi-color-names-vector [unspecified "white" "red" "green" "yellow" "royal blue" "magenta" "cyan" "white"] t)
;; (fringe-mode (quote (1 . 1)) nil (fringe))

;; <<89ad94f1851f27ff068c501e83a47f34>>

<<c10ad90226a9f6a574b7ceb93390d6e0>>

;; NOTE: Not working
;; <<4019311714fe7bab6950a6a8202833f6>>

;; <<cf7d26f4d252982b512c2d9108f5cb86>>

<<6703a9628cab6263b981af4274971ef2>>

#+end_src

***** term

#+call: hash("")

#+RESULTS:
: 4250ee7991caad7d0b372c862bb7ea60

#+name: 4250ee7991caad7d0b372c862bb7ea60
#+begin_src emacs-lisp
(use-package! term
    :general
        (:keymaps 'term-mode-map
            "C-c C-c" 'term-interrupt-subjob
            "C-m"     'term-send-raw
            "C-S-c"   'term-interrupt-subjob
            "M-,"     'term-send-input
            "M-b"     'term-send-backward-word
            "M-d"     'term-send-forward-kill-word
            "M-DEL"   'term-send-backward-kill-word
            "M-f"     'term-send-forward-word
            "M-o"     'term-send-backspace)
    :custom
        (term-unbind-key-list '("C-z" "C-x" "C-c" "C-h" "C-l" "<ESC>"))
        (term-buffer-maximum-size 16384)
        (term-default-bg-color "#000000") '(term-default-fg-color "#AAAAAA"))
#+end_src

***** vterm

#+call: hash("")

#+RESULTS:
: 89ad94f1851f27ff068c501e83a47f34

#+name: 89ad94f1851f27ff068c501e83a47f34
#+begin_src emacs-lisp
(use-package! vterm
    :custom
        (vterm-shell "/usr/bin/env xonsh")
        (vterm-always-compile-module t)
        (vterm-kill-buffer-on-exit t))
#+end_src

***** multi-term

#+call: hash("")

#+RESULTS:
: c10ad90226a9f6a574b7ceb93390d6e0

#+name: c10ad90226a9f6a574b7ceb93390d6e0
#+begin_src emacs-lisp
(use-package! multi-term
    :custom
        (multi-term-program "/usr/bin/env xonsh")
        (multi-term-scroll-show-maximum-output t))
#+end_src

***** emux

Mostly from [[Emux's After Installing Section][https://github.com/re5et/emux#after-installing]]:

#+call: hash("")

#+RESULTS:
: 4019311714fe7bab6950a6a8202833f6

#+name: 4019311714fe7bab6950a6a8202833f6
#+begin_src emacs-lisp
(use-package! emux-session
    :config
        (emux-completing-read-command (quote ido-completing-read))

        (defun jr/make-frame nil (interactive) (modify-frame-parameters (make-frame) ((name . "emux"))))
        (defun jr/select-emux nil (interactive) (select-frame-by-name "emux"))
    :general
        (:keymaps 'override
            ;; ""          'jr/make-frame
            ;; ""          'jr/select-emux
            "C-x c"     'emux-term-create
            "C-x P"     'emux-session-load-template)
        (:keymaps 'term-mode-map
            "C-S-p"     'previous-line
            "C-S-r"     'isearch-backward
            "C-S-s"     'isearch-forward
            "C-S-y"     'emux-term-yank
            "C-x -"     'emux-term-vsplit
            "C-x |"     'emux-term-hsplit
            "C-x B"     'emux-jump-to-buffer
            "C-x C-S-k" 'emux-session-destroy
            "C-x C"     'emux-screen-create
            "C-x c"     'emux-term-create
            "C-x K"     'emux-term-destroy
            "C-x M-s"   'emux-jump-to-screen
            "C-x P"     'emux-session-load-template
            "C-x R"     'emux-screen-rename
            "C-x r"     'emux-term-rename
            "C-x s"     'emux-screen-switch
            "C-x S"     'emux-session-switch
            "M-."       'comint-dynamic-complete

            ";" 'jr/emux-hercules-toggle)
    :hercules
        (:show-funs #'jr/emux-hercules-show
        :hide-funs #'jr/emux-hercules-hide
        :toggle-funs #'jr/emux-hercules-toggle
        :keymap 'term-mode-map
        ;; :transient t
        )
    ;; :hook (after-init . emux-mode)
        )
#+end_src

***** elscreen

#+call: hash("")

#+RESULTS:
: cf7d26f4d252982b512c2d9108f5cb86

#+name: cf7d26f4d252982b512c2d9108f5cb86
#+begin_src emacs-lisp
(use-package! elscreen
    :hook
        ;; (emacs-startup . elscreen-start)
        (after-init . elscreen-start)
    :custom
        ;; NOTE: Remember to escape the backslash
        (elscreen-prefix-key "C-S-\\")
    :hercules
        (:show-funs #'jr/elscreen-hercules-show
        :hide-funs #'jr/elscreen-hercules-hide
        :toggle-funs #'jr/elscreen-hercules-toggle
        :keymap 'elscreen-map
        ;; :transient t
        ))
#+end_src

***** escreen

#+call: hash("")

#+RESULTS:
: 6703a9628cab6263b981af4274971ef2

#+name: 6703a9628cab6263b981af4274971ef2
#+begin_src emacs-lisp
(load! "escreen.el")
(use-package! escreen
    :hook
        (after-init . escreen-install)
    :general
        (:keymaps 'override
            (general-chord "\\\\") 'jr/escreen-hercules-toggle)
    :config
        (defun jr/escreen-hercules-toggle nil(interactive))

        ;; Adapted From: https://tapoueh.org/blog/2009/09/escreen-integration/

        ;; add C-\ l to list screens with emphase for current one
        (defun escreen-get-active-screen-numbers-with-emphasis nil
        "what the name says"
        (interactive)
            (let ((escreens (escreen-get-active-screen-numbers))
                (emphased ""))

                (dolist (s escreens)
                    (setq emphased
                        (concat emphased (if (= escreen-current-screen-number s)
                            (propertize (number-to-string s)
                                ;;'face 'custom-variable-tag) " ")
                                'face 'info-title-3)
                                ;;'face 'font-lock-warning-face)
                                ;;'face 'secondary-selection)
                            (number-to-string s))
                        " ")))
                (message "escreen: active screens: %s" emphased)))

        ;; (global-set-key (kbd "C-\\ l") 'escreen-get-active-screen-numbers-with-emphasis)

        (defun dim:escreen-goto-last-screen nil (interactive)
            (escreen-goto-last-screen)
            (escreen-get-active-screen-numbers-with-emphasis))

        (defun dim:escreen-goto-prev-screen (&optional n) (interactive "p")
            (escreen-goto-prev-screen n)
            (escreen-get-active-screen-numbers-with-emphasis))

        (defun dim:escreen-goto-next-screen (&optional n) (interactive "p")
            (escreen-goto-next-screen n)
            (escreen-get-active-screen-numbers-with-emphasis))

        ;; (define-key escreen-map escreen-prefix-char 'dim:escreen-goto-last-screen)

        ;; (global-set-key (kbd "M-[") 'dim:escreen-goto-prev-screen)
        ;; (global-set-key (kbd "M-]") 'dim:escreen-goto-next-screen)
        ;; (global-set-key (kbd "C-\\ DEL") 'dim:escreen-goto-prev-screen)
        ;; (global-set-key (kbd "C-\\ SPC") 'dim:escreen-goto-next-screen)

        ;; (global-set-key '[s-mouse-4] 'dim:escreen-goto-prev-screen)
        ;; (global-set-key '[s-mouse-5] 'dim:escreen-goto-next-screen)

        ;; add support for C-\ from terms
        ;; (require 'term)
        ;; (define-key term-raw-map escreen-prefix-char escreen-map)
        ;; (define-key term-raw-map (kbd "M-[") 'dim:escreen-goto-prev-screen)
        ;; (define-key term-raw-map (kbd "M-]") 'dim:escreen-goto-next-screen)
    :hercules
        (:show-funs #'jr/escreen-hercules-show
        :hide-funs #'jr/escreen-hercules-hide
        :toggle-funs #'jr/escreen-hercules-toggle
        :keymap 'escreen-map
        ;; :transient t
        ))
#+end_src

**** window manager

#+call: hash("")

#+RESULTS:
: 8016354b1cb35e0587437e68baba41d8

#+name: 8016354b1cb35e0587437e68baba41d8
#+begin_src emacs-lisp
<<e77fd0ac138b6ad85673ea56d24b1cfe>>
#+end_src

***** exwm

#+call: hash("")

#+RESULTS:
: e77fd0ac138b6ad85673ea56d24b1cfe

#+name: e77fd0ac138b6ad85673ea56d24b1cfe
#+begin_src emacs-lisp
#+end_src

**** system

#+call: hash("")

#+RESULTS:
: 58043a4011d978b07d42cdbe23366db4

#+name: 58043a4011d978b07d42cdbe23366db4
#+begin_src emacs-lisp
<<8df0b63f0fd76eebb81255e9cb13e72f>>
<<a150a1120f94eead3d23c10b77f66dda>>
#+end_src

***** paths

Adapted from [[Ergoemacs' Emacs Lisp Code for Setting PATH and exec-path section][http://ergoemacs.org/emacs/emacs_env_var_paths.html]]:

# TODO: Combine the current `$PATH' with `exec-path'

#+call: hash("")

#+RESULTS:
: 8df0b63f0fd76eebb81255e9cb13e72f

#+name: 8df0b63f0fd76eebb81255e9cb13e72f
#+begin_src emacs-lisp
;; (eval `(let ((mypaths
;;     '(
;;         ,(concat "/home/" (getenv "USER") "/.nix-profile/bin")
;;         "/home/linuxbrew/.linuxbrew/bin"
;;         "/usr/bin"
;;         "/usr/sbin"
;;         ,(concat "/home/" (getenv "USER") "/.emacs.d/bin")
;;         ,(concat "/home/" (getenv "USER") "/.doom.d"))))
;;     ;; (setenv "PATH" (mapconcat 'identity mypaths ";") )
;;     (setq exec-path (append mypaths (list "." exec-directory)) )
;; ))
(use-package! exec-path-from-shell :demand t)
#+end_src

***** etc

#+call: hash("")

#+RESULTS:
: a150a1120f94eead3d23c10b77f66dda

#+name: a150a1120f94eead3d23c10b77f66dda
#+begin_src emacs-lisp
#+end_src

**** etc

#+call: hash("")

#+RESULTS:
: f6fbad3008b5eaa412ac27f2ba12bd42

#+name: f6fbad3008b5eaa412ac27f2ba12bd42
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)

;; From:
;; Answer: https://stackoverflow.com/questions/24832699/emacs-24-untabify-on-save-for-everything-except-makefiles
;; User: https://stackoverflow.com/users/2677392/ryan-m
(defun untabify-everything ()
  (untabify (point-min) (point-max)))
(defun untabify-everything-on-save ()
  (add-hook 'before-save-hook 'untabify-everything)
  nil)

;; Adapted From:
;; Answer: https://stackoverflow.com/a/24857101/10827766
;; User: https://stackoverflow.com/users/936762/dan
(defun untabify-except-makefiles nil
  "Replace tabs with spaces except in makefiles."
  (unless (derived-mode-p 'makefile-mode)
    (untabify-everything)))

(add-hook 'before-save-hook 'untabify-except-makefiles)

(general-auto-unbind-keys)
(when (featurep! :module spacemacs) (use-package! spacemacs
    :init (remove-hook 'org-load-hook #'+org-init-keybinds-h)
    :hook (doom-init-ui . spacemacs/home)))
#+end_src

*** packages.el

#+call: hash("")

#+RESULTS:
: c7d72604b58a79d5829fe508390b7d98

#+name: c7d72604b58a79d5829fe508390b7d98
#+begin_src emacs-lisp :tangle (jr/tangle-oreo)
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el

(setq straight-disable-byte-compilation t)

;; From: https://github.com/clemera/helm-ido-like-guide
(package! helm-swoop)
(package! helm-flx)
(package! helm-fuzzier)
(package! helm-smex)
(package! smex)
(package! dash)
(package! s)

(package! help-macro+)
(package! help-fns+)
(package! help-mode+)

(package! use-package-chords)
(package! rainbow-delimiters)
(package! xah-fly-keys)
(package! multi-term)
(package! exwm)
(package! leaf)
(package! manage-minor-mode)
(package! kakoune)
(package! modalka)
(package! dockerfile-mode)
(package! ox-pandoc)

;; From: https://github.com/mohsenil85/evil-evilified-state and https://github.com/syl20bnr/spacemacs
(package! bind-map)

(package! hercules
    :recipe (:host gitlab :repo "jjzmajic/hercules.el" :branch "master"))
(package! vimrc-mode
    :recipe (:host github :repo "mcandre/vimrc-mode" :branch "master"))
(package! xonsh-mode
    :recipe (:host github :repo "seanfarley/xonsh-mode" :branch "master"))
(package! evil-evilified-state
    :recipe (:host github :repo "shadowrylander/evil-evilified-state" :branch "master"))
(package! helm-ido-like
    :recipe (:host github :repo "shadowrylander/helm-ido-like-guide" :branch "master"))
(package! ryo-modal
    :recipe (:host github :repo "kungsgeten/ryo-modal" :branch "master"))
(package! emux
    :recipe (:host github :repo "re5et/emux" :branch "master"))
(package! elscreen
    :recipe (:host github :repo "knu/elscreen" :branch "master"))
(package! exec-path-from-shell
    :recipe (:host github :repo "purcell/exec-path-from-shell" :branch "master"))
#+end_src

*** org-tangle

Adapted from: https://github.com/hlissner/doom-emacs/blob/develop/bin/org-tangle

#+call: hash("")

#+RESULTS:
: 83c3bfeb4ead1c7f196c8c263b4ba388

#+name: 83c3bfeb4ead1c7f196c8c263b4ba388
#+begin_src emacs-lisp :tangle (jr/tangle-oreo) :shebang "#!/usr/bin/env sh"
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-

(setq org-confirm-babel-evaluate nil)

(require 'cl-lib)
(require 'ox)
(require 'ob-tangle)

<<ed55930dc36029c49a46d842fd0ffc1b>>

(defun usage ()
  (with-temp-buffer
    (insert (format "%s %s [OPTIONS] [TARGETS...]\n"
                    "[1mUsage:[0m"
                    (file-name-nondirectory load-file-name))
            "\n"
            "A command line interface for tangling org-mode files. TARGETS can be\n"
            "files or folders (which are searched for org files recursively).\n"
            "\n"
            "This is useful for literate configs that rely on command line\n"
            "workflows to build it.\n"
            "\n"
            "[1mExample:[0m\n"
            "  org-tangle some-file.org\n"
            "  org-tangle literate/config/\n"
            "  org-tangle -p -l sh scripts.org > do_something.sh\n"
            "  org-tangle -p -l python -t tagA -t tagB file.org | python\n"
            "\n"
            "[1mOptions:[0m\n"
            "  -a --all\t\tTangle all blocks by default\n"
            "  -l --lang LANG\tOnly tangle blocks written in LANG\n"
            "  -p --print\t\tPrint tangled output to stdout than to files\n"
            "  -t --tag TAG\n"
            "     --and TAG\n"
            "     --or TAG\n"
            "    Lets you tangle org blocks by tag. You may have more than one\n"
            "    of these options.\n")
    (princ (buffer-string))))

(defun *org-babel-tangle (orig-fn &rest args)
  "Don't write tangled blocks to files, print them to stdout."
  (cl-letf (((symbol-function 'write-region)
             (lambda (start end filename &optional append visit lockname mustbenew)
               (princ (buffer-string)))))
    (apply orig-fn args)))

(defun *org-babel-tangle-collect-blocks (&optional language tangle-file)
  "Like `org-babel-tangle-collect-blocks', but will ignore blocks that are in
trees with the :notangle: tag."
  (let ((counter 0) last-heading-pos blocks)
    (org-babel-map-src-blocks (buffer-file-name)
      (let ((current-heading-pos
             (org-with-wide-buffer
              (org-with-limited-levels (outline-previous-heading)))))
        (if (eq last-heading-pos current-heading-pos) (cl-incf counter)
          (setq counter 1)
          (setq last-heading-pos current-heading-pos)))
      (unless (org-in-commented-heading-p)
        (require 'org)
        (let* ((tags (org-get-tags-at))
               (info (org-babel-get-src-block-info 'light))
               (src-lang (nth 0 info))
               (src-tfile (cdr (assq :tangle (nth 2 info)))))
          (cond ((member "notangle" tags))

                ((and (or or-tags and-tags)
                      (or (not and-tags)
                          (let ((a (cl-intersection and-tags tags :test #'string=))
                                (b and-tags))
                            (not (or (cl-set-difference a b :test #'equal)
                                     (cl-set-difference b a :test #'equal)))))
                      (or (not or-tags)
                          (cl-intersection or-tags tags :test #'string=))
                      t))

                ((or (not (or all-blocks src-tfile))
                     (string= src-tfile "no")  ; tangle blocks by default
                     (and tangle-file (not (equal tangle-file src-tfile)))
                     (and language (not (string= language src-lang)))))

                ;; Add the spec for this block to blocks under its language.
                ((let ((by-lang (assoc src-lang blocks))
                       (block (org-babel-tangle-single-block counter)))
                   (if by-lang
                       (setcdr by-lang (cons block (cdr by-lang)))
                     (push (cons src-lang (list block)) blocks))))))))
    ;; Ensure blocks are in the correct order.
    (mapcar (lambda (b) (cons (car b) (nreverse (cdr b)))) blocks)))
(advice-add #'org-babel-tangle-collect-blocks
            :override #'*org-babel-tangle-collect-blocks)

(defvar all-blocks nil)
(defvar and-tags nil)
(defvar or-tags nil)
(let (lang srcs and-tags or-tags)
  (pop argv)
  (while argv
    (let ((arg (pop argv)))
      (pcase arg
        ((or "-h" "--help")
         (usage)
         (error ""))
        ((or "-a" "--all")
         (setq all-blocks t))
        ((or "-l" "--lang")
         (setq lang (pop argv)))
        ((or "-p" "--print")
         (advice-add #'org-babel-tangle :around #'*org-babel-tangle))
        ((or "-t" "--tag" "--and")
         (push (pop argv) and-tags))
        ("--or"
         (push (pop argv) or-tags))
        ((guard (string-match-p "^--lang=" arg))
         (setq lang (cadr (split-string arg "=" t t))))
        ((guard (file-directory-p arg))
         (setq srcs
               (append (directory-files-recursively arg "\\.org$")
                       srcs)))
        ((guard (file-exists-p arg))
         (push arg srcs))
        (_ (error "Unknown option or file: %s" arg)))))

  (dolist (file srcs)
    (let ((backup (make-temp-file (file-name-base file) nil ".backup.org")))
      (unwind-protect
          ;; Prevent slow hooks from interfering
          (let (org-mode-hook)
            ;; We do the ol' switcheroo because `org-babel-tangle' writes
            ;; changes to the current file, which would be imposing on the user.
            (copy-file file backup t)
            (with-current-buffer (find-file-noselect file)
              ;; Tangling doesn't expand #+INCLUDE directives, so we do it
              ;; ourselves, since includes are so useful for literate configs!
              ;; (org-export-expand-include-keyword)
              (org-babel-tangle nil nil lang)))
        (ignore-errors (copy-file backup file t))
        (ignore-errors (delete-file backup)))))
  (kill-emacs 0))
#+end_src

*** org-tangle-functions.el

#+call: hash("")

#+RESULTS:
: ed55930dc36029c49a46d842fd0ffc1b

#+name: ed55930dc36029c49a46d842fd0ffc1b
#+begin_src emacs-lisp :tangle (jr/tangle-oreo)
(defun jr/get-header nil (interactive)
    (nth 4 (org-heading-components)))
(defun jr/tangle-path nil (interactive)
    (string-remove-prefix "/" (concat
        (org-format-outline-path (org-get-outline-path)) "/"
            (jr/get-header))))
(defun jr/tangle-oreo nil (interactive)
    (org-babel-lob-ingest "./strange.aiern.org")
    (jr/tangle-path))
(defun jr/get-theme-from-header nil (interactive)
    (string-remove-suffix "-theme.el" (jr/get-header)))
#+end_src

** .gitattributes

#+call: hash("")

#+RESULTS:
: 0e934803846ff23710dd8874b37bcd39

#+name: 0e934803846ff23710dd8874b37bcd39
#+begin_src gitattributes :tangle (jr/tangle-oreo)
<<08dbff12d7941b00d17c353f5fe4e078>>
#+end_src

** .xonsh.d
*** fzf_tmux_dir_file.sh

#+call: hash("")

#+RESULTS:
: 0de7faf0cd17a1a0331065aecac3d1f3

#+name: 0de7faf0cd17a1a0331065aecac3d1f3
#+begin_src sh :tangle (jr/tangle-oreo)
echo $(find "$1" | fzf-tmux)
#+end_src

*** fzf_tmux_pkg.sh

#+call: hash("")

#+RESULTS:
: 4e80721df27f5fe6796c0a85ae03d390

#+name: 4e80721df27f5fe6796c0a85ae03d390
#+begin_src sh :tangle (jr/tangle-oreo)
echo $(dpkg --get-selections | fzf-tmux)
#+end_src

** .xonshrc

#+call: hash("")

#+RESULTS:
: 7ac499a656c336e7e715cc4c56df6fac

#+name: 7ac499a656c336e7e715cc4c56df6fac
#+begin_src xonsh :tangle (jr/tangle-oreo)
<<b7a800fefe161963d69a4d47eb645f78>>
#+end_src

#+call: hash("hm")

#+RESULTS:
: c440f22ba3bfdf95901cc661a825d4b0

#+name: c440f22ba3bfdf95901cc661a825d4b0
#+begin_src nix
".xonshrc".text = let
    python_ver = concatStringsSep "." (stringToCharacters attrs.versions.python);
    Channel = toCapital channel;
in with attrs.commands; ''
homeManager = True

<<7ac499a656c336e7e715cc4c56df6fac>>
'' + (myIf.empty nixos ''

<<8bdf510b6e8257d68db1657608ac1add>>
'');
#+end_src

*** nixos

#+call: hash("")

#+RESULTS:
: 8bdf510b6e8257d68db1657608ac1add

#+name: 8bdf510b6e8257d68db1657608ac1add
#+begin_src xonsh
#################
# NixOS ${Channel}
#################

aliases["rebuild"] = lambda args, stdin=None: $(${rebuild} @(args) -p ${host})
aliases["install"] = lambda args, stdin=None: $(${install})

# TODO: Revise this
def _deploy(args, stdin=None):
    sudo nixops create /etc/nixos/nixops/home.nix -d home
    sudo nixops set-args --arg hostName ${get {
        set = all.hostName;
        stc = (filterAttrs (n: v: elem n j.attrs.stc) stc) // { inherit (stc) host; };
    }} -d home
    if "all" in args:
        sudo nixops deploy -d home
aliases["deploy"] = _deploy
#+end_src

** zsh

#+call: hash("")

#+RESULTS:
: e3c9522290eaca30dc3548b3373abbee

#+name: e3c9522290eaca30dc3548b3373abbee
#+begin_src nix
zsh = let zedFile = file: let
    grml = "${sources.grml}/etc/zsh/${file}";
in myIf.empty (pathExists grml) (readFile grml); in {
    enable = true;
    enableAutosuggestions = true;
    enableVteIntegration = true;
    autocd = true;

    # TODO: Maybe this could be all paths in $PATH?
    cdpath = [  ];

    defaultKeymap = "viins";
    history.extended = true;
    initExtra = '' '';
    # initExtraFirst = '' '';
    initExtraBeforeCompInit = (zedFile "zshrc") + ''
        source ${homeDirectory}/.nix-profile/etc/profile.d/hm-session-vars.sh
    '';
    profileExtra = (zedFile "zprofile") + '' '';
    envExtra = (zedFile "zshenv") + '' '';
    loginExtra = (zedFile "zlogin") + '' '';
    logoutExtra = (zedFile "zlogout") + '' '';
    oh-my-zsh = {
        enable = false;
        plugins = [  ];
        extraConfig = '' '';
        # theme = "sushi";
        custom = "";
    };
    plugins = [  ];
    prezto = {
        enable = true;
        editor = {
            dotExpansion = true;
            keymap = "vi";
        };
        extraConfig = '' '';
        extraFunctions = [  ];
        extraModules = [  ];
        pmodules = [  ];
        pmoduleDirs = [  ];
        # prompt.theme = "paradox";
        tmux.itermIntegration = true;
        utility.safeOps = true;
    };
    inherit shellAliases;
    shellGlobalAliases = {  };
};
starship.enableZshIntegration = true;
#+end_src

** .zshrc

#+call: hash("pre")

#+RESULTS:
: 9d1f2431e218c2cb00bf6f327a47eb2e

#+name: 9d1f2431e218c2cb00bf6f327a47eb2e
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/grml/etc/zsh/zshrc"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            ""))
    "\nsource ~/.nix-profile/etc/profile.d/hm-session-vars.sh\n"
    "eval \"$(starship init zsh)\"")
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+call: hash("")

#+RESULTS:
: eedec1f071fc8797a259ee4782ef4ae1

#+name: eedec1f071fc8797a259ee4782ef4ae1
#+begin_src sh :tangle (jr/tangle-oreo)
<<9d1f2431e218c2cb00bf6f327a47eb2e()>>
#+end_src

** .zshenv

#+call: hash("pre")

#+RESULTS:
: 4574f2b39635370ecb451f6bb98ac782

#+name: 4574f2b39635370ecb451f6bb98ac782
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/grml/etc/zsh/zshenv"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+call: hash("")

#+RESULTS:
: e4bdd7035e68ad25bf7601a613a30286

#+name: e4bdd7035e68ad25bf7601a613a30286
#+begin_src sh :tangle (jr/tangle-oreo)
<<4574f2b39635370ecb451f6bb98ac782()>>
#+end_src

** .zprofile

#+call: hash("pre")

#+RESULTS:
: 78ce427e065f3552c838fe54085acdfd

#+name: 78ce427e065f3552c838fe54085acdfd
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/grml/etc/zsh/zprofile"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+call: hash("")

#+RESULTS:
: 756501ce3e856f5ca93fffddf7d1fb22

#+name: 756501ce3e856f5ca93fffddf7d1fb22
#+begin_src sh :tangle (jr/tangle-oreo)
<<78ce427e065f3552c838fe54085acdfd()>>
#+end_src

** .zlogout

#+call: hash("pre")

#+RESULTS:
: 1ed1e29f1f67c0bdc343b12368df60a5

#+name: 1ed1e29f1f67c0bdc343b12368df60a5
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/grml/etc/zsh/zlogout"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+call: hash("")

#+RESULTS:
: 87b1d7b7615b7888dc93cc7b7924808f

#+name: 87b1d7b7615b7888dc93cc7b7924808f
#+begin_src sh :tangle (jr/tangle-oreo)
<<1ed1e29f1f67c0bdc343b12368df60a5()>>
#+end_src

** .zlogin

#+call: hash("pre")

#+RESULTS:
: cec0e99ea02e55fb6dbf99f230a283c5

#+name: cec0e99ea02e55fb6dbf99f230a283c5
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/grml/etc/zsh/zlogin"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+call: hash("")

#+RESULTS:
: fff4069a824df27cfa8f20481fcb466d

#+name: fff4069a824df27cfa8f20481fcb466d
#+begin_src sh :tangle (jr/tangle-oreo)
<<cec0e99ea02e55fb6dbf99f230a283c5()>>
#+end_src

** .config
*** kitty

#+call: hash("programs")

#+RESULTS:
: d46b4b74ffb23d4335d4797f45067031

#+name: 6b65ba25e46bf89e07ec8b638f44e9c3
#+begin_src nix
kitty = {
    enable = true;
    extraConfig = readFile "${homeDirectory}/${primary.user}/home/.config/kitty/kitty.conf";
    settings.font_family = "Cartograph CF Light Italic";
};
#+end_src

#+call: hash("theme")

#+RESULTS:
: 338a3b4e851f416dd70aa64a977efb96

#+name: 338a3b4e851f416dd70aa64a977efb96
#+begin_src text
Monokai_Soda
#+end_src

#+call: hash("files")

#+RESULTS:
: 6b65ba25e46bf89e07ec8b638f44e9c3

#+name: 6b65ba25e46bf89e07ec8b638f44e9c3
#+begin_src nix
".config/kitty/theme.conf".source = sources.kittyThemes + "/themes/<<338a3b4e851f416dd70aa64a977efb96>>.conf";
#+end_src

**** kitty.conf

#+call: hash("")

#+RESULTS:
: d5cad3354664f4ad4e5802cf2dc76abd

#+name: d5cad3354664f4ad4e5802cf2dc76abd
#+begin_src conf :tangle (jr/tangle-oreo)
include ./theme.conf
#+end_src

**** theme.conf

#+call: hash("pre")

#+RESULTS:
: 641e23c8f738164a8ff4f2234396e19d

#+name: 641e23c8f738164a8ff4f2234396e19d
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/kittyThemes/themes/<<338a3b4e851f416dd70aa64a977efb96>>.conf"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

#+call: hash("")

#+RESULTS:
: bc36e158c20fa8907fa07bb998f74ddc

#+name: bc36e158c20fa8907fa07bb998f74ddc
#+begin_src conf :tangle (jr/tangle-oreo)
<<641e23c8f738164a8ff4f2234396e19d()>>
#+end_src

*** qtile

#+call: hash("")

#+RESULTS:
: 20def59e134751937775a539588c359a

#+name: 20def59e134751937775a539588c359a
#+begin_src nix
".config/qtile/config.py".source = "${homeDirectory}/${primary.user}/home/.config/qtile/config.py";
#+end_src

**** config.py

#+call: hash("")

#+RESULTS:
: 7e005c00414442d051268853d7f8cb48

#+name: 7e005c00414442d051268853d7f8cb48
#+begin_src python :tangle (jr/tangle-oreo)
<<56382ca914291d6df41adbd417b19df2>>
#+end_src

*** fish

#+call: hash("")

#+RESULTS:
: 9c831035ff1aab8cf5467639c4b6ddc4

#+name: 9c831035ff1aab8cf5467639c4b6ddc4
#+begin_src nix
fish = {
    enable = true;
    package = pkgs.fish;
    functions = shellAliases // {
        sf = "source ~/.config/fish/config.fish";
    };
    interactiveShellInit = ''
        bass source ${homeDirectory}/.nix-profile/etc/profile.d/hm-session-vars.sh
    '';
    plugins = [
        {
            name = "bass";
            src = fetchGit {
                url = "https://github.com/edc/bass";
                ref = "master";
            };
        }
    ];
};
starship.enableFishIntegration = true;
#+end_src

**** config.fish

#+call: hash("")

#+RESULTS:
: 9c0077fdacc601fe6caec99e8c8f75d6

#+name: 9c0077fdacc601fe6caec99e8c8f75d6
#+begin_src fish :tangle (jr/tangle-oreo)
bass source ~/.nix-profile/etc/profile.d/hm-session-vars.sh
alias sf=source ~/.config/fish/config.fish
alias n=exit
alias c=clear
starship init fish | source
#+end_src

*** ion

#+call: hash("")

#+RESULTS:
: b370468cc7d7048c2fca654384bf409f

#+name: b370468cc7d7048c2fca654384bf409f
#+begin_src nix
".config/ion/initrc".source = "${homeDirectory}/${primary.user}/home/.config/ion/initrc";
#+end_src

**** initrc

#+call: hash("")

#+RESULTS:
: d00469abd110d42d30147634bf86ace9

#+name: d00469abd110d42d30147634bf86ace9
#+begin_src ion :tangle (jr/tangle-oreo)
eval $(starship init ion)
#+end_src

*** powershell

#+call: hash("")

#+RESULTS:
: 8a50158d25e446dd85b7a0c8bda9c113

#+name: 8a50158d25e446dd85b7a0c8bda9c113
#+begin_src nix
".config/powershell/Microsoft.PowerShell_profile.ps1".source = "${homeDirectory}/${primary.user}/home/.config/powershell/Microsoft.PowerShell_profile.ps1";
#+end_src

**** Microsoft.PowerShell_profile.ps1

#+call: hash("")

#+RESULTS:
: f1e0f68a73ddf5bce156364bd43b5524

#+name: f1e0f68a73ddf5bce156364bd43b5524
#+begin_src powershell :tangle (jr/tangle-oreo)
Invoke-Expression (&starship init powershell)
#+end_src

*** nixpkgs

#+call: hash("pre")

#+RESULTS:
: 1ed0e2f1a5109f8af2a280a16b4eb269

#+name: 1ed0e2f1a5109f8af2a280a16b4eb269
#+begin_src emacs-lisp :var oc=""
(format-spec "
    with builtins;
    with (getFlake \"/etc/nixos\");
    with lib;
    with j;
let stc = legacyPackages.hostName.${getEnv \"HOSTNAME\"};
in getAttrFromPath (attrValues stc) legacyPackages.%o" `((?o . ,oc)))
#+end_src

#+call: hash("")

#+RESULTS:
: 43603ebd7da002155f7108935561456a

#+name: 43603ebd7da002155f7108935561456a
#+begin_src nix
".config/nixpkgs/overlays.nix".source = "${homeDirectory}/${primary.user}/home/.config/nixpkgs/overlays.nix";
".config/nixpkgs/config.nix".source = "${homeDirectory}/${primary.user}/home/.config/nixpkgs/config.nix";
".config/nix/nix.conf".text = attrs.configs.nix;
#+end_src

**** overlays.nix

#+call: hash("")

#+RESULTS:
: 2b4d9f0b772a93416e5f4674ed96ed87

#+name: 2b4d9f0b772a93416e5f4674ed96ed87
#+begin_src nix :tangle (jr/tangle-oreo)
<<1ed0e2f1a5109f8af2a280a16b4eb269(oc="overlays")>>
#+end_src

**** config.nix

#+call: hash("")

#+RESULTS:
: 9c8535c9269073f1e3c081f7595eb7fe

#+name: 9c8535c9269073f1e3c081f7595eb7fe
#+begin_src nix :tangle (jr/tangle-oreo)
<<1ed0e2f1a5109f8af2a280a16b4eb269(oc="config")>>
#+end_src

**** home.nix

#+call: hash("vars")

#+RESULTS:
: 7f0e66916c2f315cb8ef3f098a5299db

#+name: 7f0e66916c2f315cb8ef3f098a5299db
#+begin_src nix
fromAll = category: get {
    set = all.${category};
    stc = removeAttrs (
        attrNames attrs.home-manager-integer-defaults
    ) stc;
};
pkgs = fromAll "pkgs";
overlays = fromAll "overlays";
config = fromAll "config";

integer-default-truths = mapAttrs (
    n: v: v == 1
) (filterAttrs (n: v: isInt v) stc);

primary = {
    user = attrs.users.primary;
    home = attrs.allHomes.${primary.user};
};
homeDirectory = attrs.allHomes.${user};

baseOptions = {
    # force = true;
};

userName  = primary.user;
userEmail = "aiern@protonmail.com";

links' = rec {
    cookiejar = {
        source = "/${host}/b/cj";
        target = "cj";
    };
    picotech = {
        source = "${cookiejar.source}/cc/.pico";
        target = ".pico";
    };
    byobu = {
        source = "${homeDirectory}/.tmux.conf";
        target = ".byobu/.tmux.conf";
    };
};
links = mapAttrs (link: st: {
    inherit (st) target;
    source = /. + st.source;
}) (filterAttrs (link: st: pathExists (/. + st.source)) links');

shellAliases = {
    n = "exit";
    c = "clear";
};

withLink = link: with link; { "${target}" = { inherit source; }; };

hash = user: j.hostName { stc = stc // { inherit user; }; };
#+end_src

#+call: hash("programs")

#+RESULTS:
: b8786b3a304b41cac890b67b0d489482

#+name: b8786b3a304b41cac890b67b0d489482
#+begin_src nix
({
    <<e3c9522290eaca30dc3548b3373abbee>>
})
({
    <<c0f02c8e18aaf90b2db3568216a0f7b4>>
})
({
    <<9c831035ff1aab8cf5467639c4b6ddc4>>
})
({
    <<4790b5c880f2991fff358970c8ae652f>>
})
({
    <<6c9703c9e8d7c1dfd7081a89ba30b713>>
})
({
    <<0f713b3a4ffd4b5c77b96597753d4d77>>
})
({
    <<6b65ba25e46bf89e07ec8b638f44e9c3>>
})
({
    <<5e11372671a7413353f2df031f63bcda>>
})
({
    <<b7bb86447f895ccb29ee0524e2f0ab42>>
})
({
    <<7701583d01c93a70b96d051e6eee2ea8>>
})
#+end_src

#+call: hash("files")

#+RESULTS:
: 33a8f6e58d91e946436eee8b8f8a1fa5

#+name: 33a8f6e58d91e946436eee8b8f8a1fa5
#+begin_src nix
({
    <<246ca7e4d33bc1b57d6cee0768532d38>>
})
({
    <<c440f22ba3bfdf95901cc661a825d4b0>>
})
({
    <<686d2e9e79fc3a96bf63b5d18b5eb4cb>>
})
({
    <<b370468cc7d7048c2fca654384bf409f>>
})
({
    <<8a50158d25e446dd85b7a0c8bda9c113>>
})
({
    <<41e1a054113e318e196b0a8a0ccf5cb5>>
})
({
    <<8c9f6caafcb32cd315c3f5a8d52f4b19>>
})
({
    <<e530065768d9c227fc6b5cb199d6af41>>
})
({
    <<948976000227fb0afe43a2da70bcb5c6>>
})
({
    <<20def59e134751937775a539588c359a>>
})
({
    <<6b65ba25e46bf89e07ec8b638f44e9c3>>
})
({
    <<43603ebd7da002155f7108935561456a>>
})
#+end_src

#+call: hash("")

#+RESULTS:
: 0fdd9f7014b87a898a3c8660a3df9d07

#+name: 0fdd9f7014b87a898a3c8660a3df9d07
#+begin_src nix :tangle (jr/tangle-oreo)
with builtins; let
    base = { stc, all, flake, ... }:
        with builtins;
        with lib;
        with j;
        with stc;
        with integer-default-truths;
    let
        <<7f0e66916c2f315cb8ef3f098a5299db>>
    in rec {
        inherit lib;
        nixpkgs = { inherit (stc) system; inherit overlays config; };
        fonts.fontconfig.enable = mkForce true;
        imports = [ "${sources.impermanence}/home-manager.nix" ];
        useUserPackages = true;
        useGlobalPkgs = true;
        backupFileExtension = "bak";
        verbose = true;

        # TODO
        sharedModules = [
            {  }
        ];

        extraSpecialArgs = flake.legacyPackages.make.specialArgs { inherit stc; };

        programs = foldToSet (map (set: mapAttrs (
            n: v: baseOptions // v
        ) set) (flatten [
            [
                {
                    home-manager = {
                        enable = true;
                        path = sources.home-manager.outPath;
                    };
                }
                <<b8786b3a304b41cac890b67b0d489482>>
            ]
        ]));

        services = {
            gpg-agent = {
                enable = true;
                enableSshSupport = false;
                pinentryFlavor = "curses";
            };
            emacs = {
                enable = true;
                package = if (programs ? emacs) then programs.emacs.package else pkgs.emacsGcc;
            };
        };

        home = let
            persistence = {
                ${
                    myIf.knull (nixos && zfs) "persistence"
                } = attrs.persistence.home { inherit user; };
            };

            seqList = [

                # !!! CAREFUL! THE ORDER HERE MATTERS! !!!
                persistence

            ];

        in sequence seqList (foldToSet [{
                packages = import ../../etc/nixos/packages.nix { inherit stc lib pkgs; };
                file = foldToSet (map (set: mapAttrs (
                    n: v: { force = true; } // v
                ) set) (flatten [
                    [
                        ({ ".hgignore".source = "${homeDirectory}/${primary.user}/home/.hgignore"; })
                        (let source = "/persist/home/root/${primary.user}"; in foldToSet [
                            (myIf.set (user == "root") (attrs.link "/" "${source}/system"))
                            (attrs.link homeDirectory "${source}/home")
                            {
                                "${primary.user}".source = source;
                                ${myIf.knull (user == "root") "/usr/local/etc/doas.conf"}.text = ''
                                    permit keepenv :wheel
                                    permit nopass keepenv root as root
                                '';
                            })
                            <<33a8f6e58d91e946436eee8b8f8a1fa5>>
                        ]
                    ]
                    (map withLink (attrValues links))
                ]));
            }
            persistence
        ]);
    };

    flake = (import (
        let
            lock = builtins.fromJSON (builtins.readFile /etc/nixos/flake.lock);
        in fetchTarball {
            url = "https://github.com/edolstra/flake-compat/archive/${lock.nodes.flake-compat.locked.rev}.tar.gz";
            sha256 = lock.nodes.flake-compat.locked.narHash; }
        ) {
            src =  /etc/nixos;
        }).defaultNix
    inherit (flake) all;

in with lib; with j; forAllSystems' {
    inherit all;
    func = base;
    inherit extraListSets;
    inheritance = { inherit all flake; };
}
#+end_src

*** nix
**** nix.conf

#+call: hash("")

#+RESULTS:
: 5585804cafd4d120113b762c4e097541

#+name: 5585804cafd4d120113b762c4e097541
#+begin_src conf
<<4f8559fab44b31eee3bd94b54447bea2>>
min-free = 262144000
max-free = 1073741824
#+end_src

*** yadm
**** bootstrap

#+call: hash("")

#+RESULTS:
: 6fe6b364d9fba7cd66bd9cf730282b2a

#+name: 6fe6b364d9fba7cd66bd9cf730282b2a
#+begin_src python :tangle (jr/tangle-oreo)
<<5918a1d90f5b7e61007371faf087dff7>>
#+end_src

** .bashrc

#+call: hash("hm")

#+RESULTS:
: c0f02c8e18aaf90b2db3568216a0f7b4

#+name: c0f02c8e18aaf90b2db3568216a0f7b4
#+begin_src nix
bash = {
    enable = true;
    enableVteIntegration = true;
    initExtra = ''
        source ${homeDirectory}/.nix-profile/etc/profile.d/hm-session-vars.sh
    '';
    inherit shellAliases;
    shellOptions = [  ];
};
starship.enableBashIntegration = true;
#+end_src

#+call: hash("")

#+RESULTS:
: f14c4cd75f29401f56be846a13cb86c2

#+name: f14c4cd75f29401f56be846a13cb86c2
#+begin_src sh :tangle (jr/tangle-oreo)
source ~/.nix-profile/etc/profile.d/hm-session-vars.sh
alias c=clear
alias n=exit
alias sb=source ~/.bashrc
eval "$(starship init bash)"
#+end_src

** rc.elv

#+call: hash("hm")

#+RESULTS:
: 686d2e9e79fc3a96bf63b5d18b5eb4cb

#+name: 686d2e9e79fc3a96bf63b5d18b5eb4cb
#+begin_src nix
"rc.elv".source = "${homeDirectory}/${primary.user}/home/rc.elv";
#+end_src

#+call: hash("")

#+RESULTS:
: 8563464483cb5d919d84774684320f18

#+name: 8563464483cb5d919d84774684320f18
#+begin_src elvish :tangle (jr/tangle-oreo)
# use epm
# epm:install github.com/tylerreckart/gondolin
# use github.com/tylerreckart/gondolin/gondolin
eval (starship init elvish)
#+end_src

** .SpaceVim.d

#+call: hash("")

#+RESULTS:
: 41e1a054113e318e196b0a8a0ccf5cb5

#+name: 41e1a054113e318e196b0a8a0ccf5cb5
#+begin_src nix
".config/nvim" = {
    source = sources.spacevim;
    recursive = true;
};
".vim" = {
    source = sources.spacevim;
    recursive = true;
};
".SpaceVim.d/init.toml".source = "${homeDirectory}/${primary.user}/home/.SpaceVim.d/init.toml";
".SpaceVim.d/autoload/vimrc.vim".source = "${homeDirectory}/${primary.user}/home/.SpaceVim.d/autoload/vimrc.vim";
#+end_src

*** init.toml

#+call: hash("")

#+RESULTS:
: ef0ca6b027b247fed6e95bb31f027708

#+name: ef0ca6b027b247fed6e95bb31f027708
#+begin_src conf :tangle (jr/tangle-oreo)
<<610e9954e5b1fa36fd50580e2061424f>>
#+end_src

*** autoload
**** vimrc.vim

#+call: hash("")

#+RESULTS:
: e4619751678bb7065fc7ec1a80a0ff98

#+name: e4619751678bb7065fc7ec1a80a0ff98
#+begin_src vimrc :tangle (jr/tangle-oreo)
<<a9f44e9cd05fda5b5e5dffb41d946748>>
#+end_src

** makefile

#+call: hash("repos")

#+RESULTS:
: 7e5d38a2c9af18003ca89c3dad2d1b97

#+name: 7e5d38a2c9af18003ca89c3dad2d1b97
#+begin_src text
scop/bash-completion resources/bashCompletions
xero/figlet-fonts resources/xeroFigletFonts
grml/grml-etc-core resources/grml
SpaceVim/SpaceVim home/.vim
hlissner/doom-emacs home/.emacs.d
dexpota/kitty-themes resources/kittyThemes
aleclearmind/nested-tmux resources/aleclearmind
gpakosz/.tmux resources/oh-my-tmux
powerline/powerline resources/powerline
tmux-plugins/tpm resources/tpm
#+end_src

#+call: hash("")

#+RESULTS:
: c9792b0b851c8df28651f125f42b1868

#+name: c9792b0b851c8df28651f125f42b1868
#+begin_src makefile :tangle (jr/tangle-oreo)
init:
    -git clone --recurse-submodule https://github.com/<<7e5d38a2c9af18003ca89c3dad2d1b97>>
    -ln -sf home/.vim home/.config/nvim
#+end_src

** git

#+call: hash("programs")

#+RESULTS:
: 4790b5c880f2991fff358970c8ae652f

#+name: 4790b5c880f2991fff358970c8ae652f
#+begin_src nix
git = {
    # File at ~/.config/git/config
    enable = true;
    package = pkgs.git;
    lfs.enable = true;
    extraConfig = {
        core = {
            excludesfile = "${homeDirectory}/.gitignore";
            attributesfile = "${homeDirectory}/.gitattributes";
        };

        # TODO: Add the greater-than sizes
        annex.largefiles = ''
            include=**/__pycache__/* or \
            include=**/dist/* or \
            include=**/tests/* or \
            include=**/deprecated/* or \
            include=**/unfinished/* or \
            include=**/.vscode/* or \
            include=**/*.test.* or \
            include=**/*.envrc
        '';

    };
    inherit userEmail userName;
};
#+end_src

#+call: hash("files")

#+RESULTS:
: 246ca7e4d33bc1b57d6cee0768532d38

#+name: 246ca7e4d33bc1b57d6cee0768532d38
#+begin_src nix
".gitignore".text = "${homeDirectory}/${primary.user}/home/.gitignore";
".gitattributes".text = "${homeDirectory}/${primary.user}/home/.gitattributes";
#+end_src

** .gitignore

#+call: hash("")

#+RESULTS:
: 1ea4bb5fe97c460bf6cd50db65f78bbe

#+name: 1ea4bb5fe97c460bf6cd50db65f78bbe
#+begin_src gitignore :tangle (jr/tangle-oreo)
_gsdata_
.boar
.git
.hg
**/__pycache__
**/_build
**/.vscode
**/*.!sync
**/*.bts
**/*.envrc
**/*.swp
**/*.sync
**/*.test.*
**/*.tmp
**/deprecated
**/dist
**/result
**/tests
**/unfinished
temp
#+end_src

** .hgrc

#+call: hash("hm")

#+RESULTS:
: 6c9703c9e8d7c1dfd7081a89ba30b713

#+name: 6c9703c9e8d7c1dfd7081a89ba30b713
#+begin_src nix
mercurial = {
    enable = true;
    package = pkgs.mercurial;
    inherit userEmail userName;
    ignoresRegexp = [];
    extraConfig = {
        extensions = {
            # hgext = {
            #     bookmarks = "";
            #     convert = "";
            # };
            # hggit = "/usr/lib/python2.7/site-packages/hggit";
            hggit = "";
            strip = "";
            share = "";
        };
        trusted = {
            users = primary.user;
            groups = primary.user;
        };
        git.blockdothg = "false";
        ui.ignore = "${homeDirectory}/.hgignore";
    };
};
#+end_src

** .hgignore

#+call: hash("")

#+RESULTS:
: 9f58d4089d36710d31eaed9419ed38cd

#+name: 9f58d4089d36710d31eaed9419ed38cd
#+begin_src gitignore :tangle (jr/tangle-oreo)
<<1ea4bb5fe97c460bf6cd50db65f78bbe>>
#+end_src

** emacs

#+call: hash("programs")

#+RESULTS:
: 0f713b3a4ffd4b5c77b96597753d4d77

#+name: 0f713b3a4ffd4b5c77b96597753d4d77
#+begin_src nix
emacs = {
    enable = true;
    package = pkgs.emacsGcc;
    overrides = final: prev: {
        magit-delta = super.magit-delta.overrideAttrs (eprev: {
            buildInputs = eprev.buildInputs ++ [ pkgs.git ];
        });
    };
    # extraPackages = with pkgs."emacs${j.attrs.versions.emacs}Packages"; [
    #     sqlite3
    #     emacsql-sqlite3
    # ];
};
#+end_src

#+call: hash("files")

#+RESULTS:
: 8c9f6caafcb32cd315c3f5a8d52f4b19

#+name: 8c9f6caafcb32cd315c3f5a8d52f4b19
#+begin_src nix
# ".doom.d/system_init.el".text = ''
#   (add-to-list 'exec-path "${pkgs."emacs${j.attrs.versions.emacs}Packages".emacsql-sqlite3}/bin")
#   (add-to-list 'exec-path "${pkgs."emacs${j.attrs.versions.emacs}Packages".sqlite3}/bin")
# '';
".doom.d".source = "${homeDirectory}/${primary.user}/home/.doom.d";
".emacs.d".source = sources.doom-emacs;
#+end_src

** starship

#+call: hash("")

#+RESULTS:
: b7bb86447f895ccb29ee0524e2f0ab42

#+name: b7bb86447f895ccb29ee0524e2f0ab42
#+begin_src nix
starship = {
    enable = true;
    package = pkgs.starship;
    settings = {

    };
};
#+end_src

** .tmux.conf

#+call: hash("")

#+RESULTS:
: f8c37c2c0aee46bde39319b837f36e16

#+name: f8c37c2c0aee46bde39319b837f36e16
#+begin_src conf :tangle (jr/tangle-oreo)
<<67bb84ea2b3abf4eba054728fef72e40>>
#+end_src

** .byobu
*** .tmux.conf

#+call: hash("")

#+RESULTS:
: 376191d12bcf3a386a37cd100cf20711

#+name: 376191d12bcf3a386a37cd100cf20711
#+begin_src conf :tangle (jr/tangle-oreo)
<<67bb84ea2b3abf4eba054728fef72e40>>
#+end_src

** tmux

#+call: hash("programs")

#+RESULTS:
: 5e11372671a7413353f2df031f63bcda

#+name: 5e11372671a7413353f2df031f63bcda
#+begin_src nix
<<8182b9565b9c8ccb0a8f2c87319c9955>>
#+end_src

#+call: hash("files")

#+RESULTS:
: e530065768d9c227fc6b5cb199d6af41

#+name: e530065768d9c227fc6b5cb199d6af41
#+begin_src nix
".tmuxp/default.yaml".text = "session_name: default";
#+end_src

** .direnvrc

#+call: hash("")

#+RESULTS:
: 0f61833f5f550b3981d8bf80354f4bc5

#+name: 0f61833f5f550b3981d8bf80354f4bc5
#+begin_src shell :tangle (jr/tangle-oreo)
source $HOME/.nix-direnv/direnvrc
source $HOME/.config/direnv/direnvrc

if [ -f /run/current-system/sw/share/nix-direnv/direnvrc ]; then
    source /run/current-system/sw/share/nix-direnv/direnvrc
fi
#+end_src

** direnv

#+call: hash("programs")

#+RESULTS:
: 7701583d01c93a70b96d051e6eee2ea8

#+name: 7701583d01c93a70b96d051e6eee2ea8
#+begin_src nix
direnv = {
    # File at ~/.config/direnv/direnvrc
    enable = true;
    enableBashIntegration = true;
    enableFishIntegration = true;
    enableNixDirenvIntegration = true;
    enableZshIntegration = true;
    stdlib = ''
        use_flake() {
            watch_file flake.nix
            watch_file flake.lock
            eval "$(nix print-dev-env --profile "$(direnv_layout_dir)/flake-profile")"
        }
    '';
};
#+end_src

#+call: hash("files")

#+RESULTS:
: 948976000227fb0afe43a2da70bcb5c6

#+name: 948976000227fb0afe43a2da70bcb5c6
#+begin_src nix
".direnvrc".source = "${homeDirectory}/${primary.user}/home/.direnvrc";
#+end_src


* wheee

#+call: hash("")

#+RESULTS:
: 98b2f4dcc6b880dfefca30da2b287931

#+name: 98b2f4dcc6b880dfefca30da2b287931
#+begin_src python :tangle (jr/tangle-oreo) :shebang "#!/usr/bin/env python3.9"
import argparse
import os
from sys import argv
from itertools import zip_longest
from subprocess import run
parser = argparse.ArgumentParser()
parser.add_argument("-D", "--directory", default="/etc/nixos")
parser.add_argument("-f", "--flake", action="store_true")
parser.add_argument("-F", "--file")
parser.add_argument("-c", "--command", default="switch")
parser.add_argument("-s", "--hash", action="store_true")
parser.add_argument("--use-hash")
parser.add_argument("-v", "--verbose", action="store_true")
parser.add_argument("-d", "--dry-run", action="store_true")
parser.add_argument("-m", "--home-manager", action="store_true")
parser.add_argument("-H", "--host", required=True)
parser.add_argument("-u", "--user", default="root")
args, unknown = parser.parse_known_args(argv[1:])

homeManager = args.home_manager or args.file

def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx"
    args = [iter([
        s.removeprefix("--") if s.startswith("--") else s for s in iterable
    ])] * n
    return zip_longest(*args, fillvalue=fillvalue)

unknown = dict(grouper(unknown, 2, ""))

if homeManager:
    unknown["user"] = args.user
unknown["host"] = args.host

commandPre = f"nix-instantiate --read-write-mode --show-trace --eval -E 'let j = import " + os.path.dirname(os.path.realpath(argv[0])) + "/lib {  }; in j.hostName"

commandSet = "{ stc = j.attrs.default-stc // " + ("j.attrs.home-manager-default-stc" if homeManager else "{  }") + " // { "
for k, v in unknown.items():
    commandSet += f'{k} = "{v}"; '
commandSet += "};"

hashCommand = " ".join([
    commandPre,
    commandSet,
    "}'",
])

flake = lambda _hash: f'--flake "{args.directory}#{_hash}"' if args.flake else (
    f'-A {_hash} -f {args.file or "~/.config/nixpkgs/home.nix"}' if homeManager else ""
)

if homeManager:
    command = lambda _hash: f"home-manager {args.command} {flake(_hash)}"
else:
    command = lambda _hash: f'nixos-rebuild {args.command} --impure --show-trace {flake(_hash)}'

getHash = lambda: args.use_hash or run(hashCommand, shell = True, capture_output = True, text = True).stdout.strip().strip('\"')

if args.verbose or args.dry_run:
    if args.hash:
        print(hashCommand)
    else:
        _hash = getHash()
        print(command(getHash()))
if not args.dry_run:
    if args.hash:
        print(getHash())
    else:
        run(command(getHash()), shell = True)
#+end_src
